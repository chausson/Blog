{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/gif/animation.gif","path":"gif/animation.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/gif/heartIncomplete.gif","path":"gif/heartIncomplete.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/0.75.png","path":"img/0.75.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/0.9.png","path":"img/0.9.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/1.05.png","path":"img/1.05.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/CHWebView设计图.png","path":"img/CHWebView设计图.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/fileMeum.png","path":"img/fileMeum.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/mvc.png","path":"img/mvc.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image3.png","path":"img/pod_image3.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image5.png","path":"img/pod_image5.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/webview.png","path":"img/webview.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/gif/heart.gif","path":"gif/heart.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/Mediator1.jpeg","path":"img/Mediator1.jpeg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/Mediator2.jpeg","path":"img/Mediator2.jpeg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/Mediator3.jpeg","path":"img/Mediator3.jpeg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/Mediator4.jpg","path":"img/Mediator4.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image1.png","path":"img/pod_image1.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image4.png","path":"img/pod_image4.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image6.png","path":"img/pod_image6.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/protocol/1.png","path":"img/protocol/1.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/protocol/2.png","path":"img/protocol/2.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/GitSource/master.png","path":"img/GitSource/master.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/pod_image2.png","path":"img/pod_image2.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/GitSource/cache.png","path":"img/GitSource/cache.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/gif/WebView.gif","path":"gif/WebView.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/GitSource/branch.png","path":"img/GitSource/branch.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/image.zip","path":"img/image.zip","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/Signature.png","path":"img/Signature.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"96014bad9407ae905b18dd000722a1a51469bb12","modified":1483098344000},{"_id":"themes/jacman/.DS_Store","hash":"c382e91dd2f72e2007a9380b6d7aa9dfc80f8231","modified":1482293906000},{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1464675056000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1464675056000},{"_id":"themes/jacman/README.md","hash":"045d64cd0f901b3801e7d84dbf6af078b9d68dff","modified":1464675056000},{"_id":"themes/jacman/README_zh.md","hash":"41480e35a26cdd26da09a39c5c25b377887eadcb","modified":1464675056000},{"_id":"themes/jacman/_config.yml","hash":"36c0e4e2da02591ea164eb7b49e9392bd991d22b","modified":1467787635000},{"_id":"source/_posts/.DS_Store","hash":"0e096ab6357a3263351685286ce58fb7c13538dc","modified":1552495254218},{"_id":"source/_posts/APP端和服务器的Request验证.md","hash":"8988822c0a9433af4fd9c7ce37771e6d0381cc71","modified":1477466926000},{"_id":"source/_posts/CHWebView搞定JS与OC交互.md","hash":"be35517a910f5abf184a3420259120bd6aea5eb9","modified":1473049789000},{"_id":"source/_posts/Carthage的入门.md","hash":"2d5ef878b3d38d6bf67143695cf286a0a1470f0b","modified":1479980166000},{"_id":"source/_posts/Git从入门到进阶.md","hash":"4b21e9f8126c820e1312c89a1d484fd1514b94aa","modified":1489660281000},{"_id":"source/_posts/JSONExport-源码解析.md","hash":"36dd10cb17e0728426136ff5a359bb1a8f02941c","modified":1552495378375},{"_id":"source/_posts/UIWebView与WKWebView.md","hash":"d9a121e466d4733791dd1109e053d0d8dffaacec","modified":1472002657000},{"_id":"source/_posts/Method Swizzling理解.md","hash":"62b99bd70a424402f09381422bd795fa84e7c698","modified":1470795620000},{"_id":"source/_posts/代码Review系列(1)——CHChat聊天组件.md","hash":"57a3c34d8af4767efc9cfe31dcd57852876f5720","modified":1470795568000},{"_id":"source/_posts/iOS中的MVC架构模式.md","hash":"6c1fe166cf7d92b2987a3245638a48dea7d22cf7","modified":1482323394000},{"_id":"source/_posts/函数响应式编程概念.md","hash":"f7322d59ef3e172371e1576e0870d930faa4b035","modified":1484034613000},{"_id":"source/_posts/制作Pod类库.md","hash":"35934a05aa96a2d48ebc05ce2a2748d9be135769","modified":1476088869000},{"_id":"source/_posts/如何建立属于自己的技术博客网站.md","hash":"668d48c14698fb098751736612136eb4f16e3c9a","modified":1464776138000},{"_id":"source/_posts/如何正确使用UIImage加载图片.md","hash":"9456983215e9eb99bc33a7348eecb82a9434995c","modified":1470795684000},{"_id":"source/_posts/简单易用的HUD.md","hash":"ec5f57c07f2d47c6f0b919475338a4fa437f0064","modified":1471434596000},{"_id":"source/_posts/组件化之路的尝试.md","hash":"d4da24c67495c7a4fd8bd0c13f4ab5ac712b6325","modified":1483531198000},{"_id":"source/_posts/自动化构建工具Jenkins.md","hash":"d293f9bd49f80109543cc956363deb35869b027e","modified":1477908711000},{"_id":"source/_posts/面向协议-POP-以面向对象-OOP.md","hash":"4298f5ffa7f23dcbda94b60d7527549686d52ff0","modified":1488371316000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1467179631000},{"_id":"source/about/index.md","hash":"f1598d2cde4a7c04d90249153298c33135c82962","modified":1467179959000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1464675056000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1464675056000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1464675056000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1464675056000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1464675056000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1464675056000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1464675056000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1464675056000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1464675056000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1464675056000},{"_id":"themes/jacman/source/.DS_Store","hash":"60c369fbfc895c7d56563f69fab27fe735ce1dba","modified":1483079440000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1464675056000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1464675056000},{"_id":"themes/jacman/source/css/.DS_Store","hash":"9c7e4e0c9e06a16717e285d136648036f97626c7","modified":1482293577000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1457801102000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1457801102000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1457801102000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1457801102000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1457801102000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1457801102000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1457801102000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1457801102000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1457801102000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1457801102000},{"_id":"themes/jacman/source/gif/animation.gif","hash":"4aa0e64886808e155dc2ca4c1cf9a5d04860094b","modified":1467710599000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1457801102000},{"_id":"themes/jacman/source/gif/heartIncomplete.gif","hash":"5ba2b2feb3aba2d4c76bf36e430421c9b53bd4e7","modified":1468897529000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1457801102000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1457801102000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1457801102000},{"_id":"themes/jacman/source/img/.DS_Store","hash":"463d9b6dbeda2f70fbbec551a99967c654df3cad","modified":1489649050000},{"_id":"themes/jacman/source/img/0.75.png","hash":"30db72bb6f4e69d3af801ecc936014f0eaaa5f61","modified":1468849860000},{"_id":"themes/jacman/source/img/0.9.png","hash":"0f6f35a5ba5478435a27e0faae75a3c124013e78","modified":1468850319000},{"_id":"themes/jacman/source/img/1.05.png","hash":"bc330a111a9b58bc8fd3aeb2208a90dd7d2d1c35","modified":1468850149000},{"_id":"themes/jacman/source/img/CHWebView设计图.png","hash":"54c223064c06df4eef2227950bb7e63357a56148","modified":1472025750000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1457801102000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1457801102000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1457801102000},{"_id":"themes/jacman/source/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1457801102000},{"_id":"themes/jacman/source/img/fileMeum.png","hash":"d2fc4f27273e5c7f30b9bb4962e21b7b568de1d9","modified":1467170543000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1457801102000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1457801102000},{"_id":"themes/jacman/source/img/mvc.png","hash":"e3cf85737e09222ec95fd771a5e7e0f5c10590b5","modified":1481262036000},{"_id":"themes/jacman/source/img/pod_image3.png","hash":"a8ca4d6f33c4381ca0e60e81589db34f45db7f1e","modified":1474532196000},{"_id":"themes/jacman/source/img/pod_image5.png","hash":"5f843629cef43ed938c9d8444001058cb326c84b","modified":1474532213000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1457801102000},{"_id":"themes/jacman/source/img/webview.png","hash":"cb9715daf2d1f48ccd386edaf3fbf087165e0291","modified":1470654463000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1457801102000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1457801102000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1457801102000},{"_id":"themes/jacman/source/gif/heart.gif","hash":"a2cc46fef4937266b3ff23c0622d982923552512","modified":1468834726000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1457801102000},{"_id":"themes/jacman/source/img/Mediator1.jpeg","hash":"8e87e766fad63b3865afb3a82560ba9b1f986e51","modified":1483069388000},{"_id":"themes/jacman/source/img/Mediator2.jpeg","hash":"170281a487f5f5d01d4ad68389434f0cd874a729","modified":1483076846000},{"_id":"themes/jacman/source/img/Mediator3.jpeg","hash":"31166868017d42adae953e360cee112ae0a21d60","modified":1483079354000},{"_id":"themes/jacman/source/img/Mediator4.jpg","hash":"2f5bde38a9f6336bd8ab3b24d5341a63c46d2506","modified":1483530745000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1457801102000},{"_id":"themes/jacman/source/img/pod_image1.png","hash":"694a73af435a98ed0b3db3257f05a2cc00f3fc69","modified":1474532162000},{"_id":"themes/jacman/source/img/pod_image4.png","hash":"5544e2f17b81bd2b81aa1f8912182cb19d4b415b","modified":1474532204000},{"_id":"themes/jacman/source/img/pod_image6.png","hash":"de5db9f85134bc637c9debf069fc59843e95d1b0","modified":1474532221000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1464675056000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1464675056000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1457801102000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1457801102000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"fbd8d10e6dbf8c94bd09aa0fb456f23b2f02a9ea","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5ea1c28a19da709af4619e0ffcbd5261c3d54669","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1457801102000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1457801102000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1457801102000},{"_id":"themes/jacman/source/img/protocol/1.png","hash":"6fae3da8f46ef1a7a5b7f0626f013e9cfbe89341","modified":1488370786000},{"_id":"themes/jacman/source/img/protocol/2.png","hash":"86627c20c2c9b845fa2c80f6a15740acdf96423b","modified":1488370806000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1457801102000},{"_id":"themes/jacman/source/img/GitSource/master.png","hash":"b16b64e8ea3ea5d1cc29b2e48958c4c4388bf6c7","modified":1489655467000},{"_id":"themes/jacman/source/img/pod_image2.png","hash":"269a025dc15036f70a3b2298ca3c42fc14cfa3a9","modified":1474532181000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1457801102000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1457801102000},{"_id":"themes/jacman/source/img/GitSource/cache.png","hash":"b1e300b5eb2dc4bd6c061e713ffd1133cab7a65b","modified":1489648845000},{"_id":"themes/jacman/source/gif/WebView.gif","hash":"855e15e6870c39eed19cbbb162f3f70c289d16d5","modified":1471874114000},{"_id":"themes/jacman/source/img/GitSource/branch.png","hash":"deddee0e02ed8f2d07d02a856385b8035818ee6b","modified":1489655485000},{"_id":"themes/jacman/source/img/image.zip","hash":"98197bea26c5542c161767474d4eceac6977da45","modified":1474532284000},{"_id":"themes/jacman/source/img/Signature.png","hash":"31bfd7385812f7952672f775350d27fbdd0e081c","modified":1477449624000},{"_id":"public/about/index.html","hash":"25ba111e554721f4127fb087c8756261fff4dbc1","modified":1552496323718},{"_id":"public/2017/01/10/函数响应式编程概念/index.html","hash":"3b565c4e87571a41014076bba60a63ac8aa6f07c","modified":1552496323718},{"_id":"public/2016/11/24/Carthage的入门/index.html","hash":"515b0943e71ea06c61531df8bd271ae9964eaac1","modified":1552496323719},{"_id":"public/2016/10/21/APP端和服务器的Request验证/index.html","hash":"446d5a5ba711c515cfb6078dcdfc7e257a2d214b","modified":1552496323719},{"_id":"public/2016/08/17/简单易用的HUD/index.html","hash":"f91bb9330a98d26493ba884aefa7427c90380d93","modified":1552496323719},{"_id":"public/archives/page/2/index.html","hash":"03b60300bfb5580f593837a10118eb112f67c734","modified":1552496323719},{"_id":"public/archives/2016/index.html","hash":"b7c3f921e29030c53f4ec04f3817019202813905","modified":1552496323719},{"_id":"public/archives/index.html","hash":"3ac6e0fb279df4b962f277ff1912a9488153699d","modified":1552496323719},{"_id":"public/archives/2016/page/2/index.html","hash":"6d04704de3e142dc9a427197fd593d711a515b1b","modified":1552496323719},{"_id":"public/archives/2016/06/index.html","hash":"7dd2895c4c1a3cdbad3881dc4154731e70a9587a","modified":1552496323719},{"_id":"public/archives/2016/07/index.html","hash":"df09a305f8a300d7c2eae59b52b6b9224bc0086d","modified":1552496323719},{"_id":"public/archives/2016/08/index.html","hash":"3061d811d1ca706f01130b955ab90dbc3e9461ed","modified":1552496323719},{"_id":"public/archives/2016/09/index.html","hash":"4aa1d269c8cb97ca5f33984a2eac6ac0430246ea","modified":1552496323719},{"_id":"public/archives/2016/10/index.html","hash":"e61a3c7fc3c1cf49c6cc397d4f8b474fa00e7309","modified":1552496323719},{"_id":"public/archives/2016/11/index.html","hash":"d48c4e13cd07b7864e9c546726526b5bf545f55c","modified":1552496323729},{"_id":"public/archives/2016/12/index.html","hash":"1f54cec8286de093d6e30ca748041fd82f11c4b6","modified":1552496323729},{"_id":"public/archives/2017/index.html","hash":"441d2779de73eaa6258f870a4a56d88074dc4d52","modified":1552496323729},{"_id":"public/archives/2017/01/index.html","hash":"58235957f55e6fb2478bd182e0b17f9d4e79144b","modified":1552496323729},{"_id":"public/archives/2017/03/index.html","hash":"06f3bd2f7b24a5d459bce12072a478ef71d15d9f","modified":1552496323729},{"_id":"public/archives/2019/index.html","hash":"30a5f087ffbbf9bb27a530ee98bd53ff5472e376","modified":1552496323729},{"_id":"public/archives/2019/03/index.html","hash":"1ad65a1736ebd119f1382fa4bffd05b0c49e813e","modified":1552496323729},{"_id":"public/categories/小知识/index.html","hash":"58784574d83e55898d167bf72af639eba6a953ae","modified":1552496323730},{"_id":"public/categories/组件/index.html","hash":"fadff7154453a0da4d5115ad09ad3d64d93fe28b","modified":1552496323730},{"_id":"public/categories/设计模式/index.html","hash":"e1ded9f7fbcbf6cddbe58fbc012c6165f00e30f9","modified":1552496323730},{"_id":"public/categories/环境搭建/index.html","hash":"9fcb53a6c11f209e6b2753b8ac4cdd229d061544","modified":1552496323730},{"_id":"public/categories/图片/index.html","hash":"7d60109b05995b42fea7655c39932c68ef1f31f1","modified":1552496323730},{"_id":"public/categories/设计模式-分类/index.html","hash":"2a48727f53a2f6047478124aa13a9b72b352390a","modified":1552496323730},{"_id":"public/index.html","hash":"1a294254f5e341136cec584b2d21556d3b3953d9","modified":1552496323730},{"_id":"public/page/2/index.html","hash":"c12e3e670831e4cdaa6a2f8c9cd3a342fb6d7789","modified":1552496323730},{"_id":"public/2019/03/14/JSONExport-源码解析/index.html","hash":"1ec26a8378b65ea3f8f96938ce9d5067aa41db93","modified":1552496323730},{"_id":"public/2017/03/16/Git从入门到进阶/index.html","hash":"897c6a0ea646358b4396de77a719248ac85e156c","modified":1552496323730},{"_id":"public/2017/03/01/面向协议-POP-以面向对象-OOP/index.html","hash":"89ba447937bdc74b87f7f3a1c6f2dd8168881aac","modified":1552496323730},{"_id":"public/2016/12/30/组件化之路的尝试/index.html","hash":"b610b3808a245b675e2f5ac119efc2031594dad8","modified":1552496323731},{"_id":"public/2016/12/09/iOS中的MVC架构模式/index.html","hash":"930393fd1b4753033006b76766c570a9a715dc52","modified":1552496323731},{"_id":"public/2016/10/31/自动化构建工具Jenkins/index.html","hash":"689864136722e677bb424b568999f24cdfa42213","modified":1552496323731},{"_id":"public/2016/09/22/制作Pod类库/index.html","hash":"35871a6fe2497459cd7c6558e6ff14278e87c4b3","modified":1552496323731},{"_id":"public/2016/08/23/CHWebView搞定JS与OC交互/index.html","hash":"9ab186d95e54c06494711a1b19c4193a761e976e","modified":1552496323731},{"_id":"public/2016/08/09/UIWebView与WKWebView/index.html","hash":"783fd7557221345214b7f6a3cf8d8bb66c26c6a4","modified":1552496323731},{"_id":"public/2016/08/01/Method Swizzling理解/index.html","hash":"f52a927b3e856544974382755498cda5e1f89aca","modified":1552496323731},{"_id":"public/2016/07/04/如何正确使用UIImage加载图片/index.html","hash":"bf5cc222a3f4d1f4f9f60cfbefceffa9314e883d","modified":1552496323731},{"_id":"public/2016/06/28/代码Review系列(1)——CHChat聊天组件/index.html","hash":"ba155562be77d55f473905be2320d02de124d2b6","modified":1552496323731},{"_id":"public/2016/06/01/如何建立属于自己的技术博客网站/index.html","hash":"6ae3fb51ce899b897936c6fe2d0daa45895349ce","modified":1552496323731},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1552496323746},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1552496323746},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1552496323746},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1552496323746},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1552496323746},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1552496323746},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1552496323746},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1552496323746},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1552496323746},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1552496323746},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1552496323746},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1552496323746},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1552496323746},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1552496323746},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1552496323747},{"_id":"public/gif/animation.gif","hash":"4aa0e64886808e155dc2ca4c1cf9a5d04860094b","modified":1552496323747},{"_id":"public/gif/heartIncomplete.gif","hash":"5ba2b2feb3aba2d4c76bf36e430421c9b53bd4e7","modified":1552496323747},{"_id":"public/img/0.9.png","hash":"0f6f35a5ba5478435a27e0faae75a3c124013e78","modified":1552496323747},{"_id":"public/img/0.75.png","hash":"30db72bb6f4e69d3af801ecc936014f0eaaa5f61","modified":1552496323747},{"_id":"public/img/1.05.png","hash":"bc330a111a9b58bc8fd3aeb2208a90dd7d2d1c35","modified":1552496323747},{"_id":"public/img/CHWebView设计图.png","hash":"54c223064c06df4eef2227950bb7e63357a56148","modified":1552496323747},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1552496323747},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1552496323748},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1552496323748},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1552496323748},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1552496323748},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1552496323748},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1552496323748},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1552496323748},{"_id":"public/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1552496323748},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1552496323748},{"_id":"public/img/fileMeum.png","hash":"d2fc4f27273e5c7f30b9bb4962e21b7b568de1d9","modified":1552496323748},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1552496323748},{"_id":"public/img/mvc.png","hash":"e3cf85737e09222ec95fd771a5e7e0f5c10590b5","modified":1552496323748},{"_id":"public/img/pod_image3.png","hash":"a8ca4d6f33c4381ca0e60e81589db34f45db7f1e","modified":1552496323749},{"_id":"public/img/pod_image5.png","hash":"5f843629cef43ed938c9d8444001058cb326c84b","modified":1552496323749},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1552496323749},{"_id":"public/img/webview.png","hash":"cb9715daf2d1f48ccd386edaf3fbf087165e0291","modified":1552496323749},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1552496323749},{"_id":"public/img/protocol/2.png","hash":"86627c20c2c9b845fa2c80f6a15740acdf96423b","modified":1552496323749},{"_id":"public/img/protocol/1.png","hash":"6fae3da8f46ef1a7a5b7f0626f013e9cfbe89341","modified":1552496323749},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1552496324347},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1552496324350},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1552496324351},{"_id":"public/gif/heart.gif","hash":"a2cc46fef4937266b3ff23c0622d982923552512","modified":1552496324351},{"_id":"public/img/Mediator3.jpeg","hash":"31166868017d42adae953e360cee112ae0a21d60","modified":1552496324352},{"_id":"public/img/Mediator1.jpeg","hash":"8e87e766fad63b3865afb3a82560ba9b1f986e51","modified":1552496324352},{"_id":"public/img/Mediator4.jpg","hash":"2f5bde38a9f6336bd8ab3b24d5341a63c46d2506","modified":1552496324352},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1552496324352},{"_id":"public/img/Mediator2.jpeg","hash":"170281a487f5f5d01d4ad68389434f0cd874a729","modified":1552496324352},{"_id":"public/img/pod_image1.png","hash":"694a73af435a98ed0b3db3257f05a2cc00f3fc69","modified":1552496324353},{"_id":"public/img/pod_image4.png","hash":"5544e2f17b81bd2b81aa1f8912182cb19d4b415b","modified":1552496324353},{"_id":"public/img/pod_image6.png","hash":"de5db9f85134bc637c9debf069fc59843e95d1b0","modified":1552496324353},{"_id":"public/img/GitSource/master.png","hash":"b16b64e8ea3ea5d1cc29b2e48958c4c4388bf6c7","modified":1552496324353},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1552496324360},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1552496324360},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1552496324360},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1552496324360},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1552496324360},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1552496324360},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1552496324360},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1552496324360},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1552496324360},{"_id":"public/css/style.css","hash":"b5eaeb39d7bad8e1695c17d1a49cf5fa3fc24a74","modified":1552496324360},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1552496324361},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1552496324361},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1552496324361},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1552496324361},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1552496324366},{"_id":"public/img/pod_image2.png","hash":"269a025dc15036f70a3b2298ca3c42fc14cfa3a9","modified":1552496324366},{"_id":"public/img/GitSource/cache.png","hash":"b1e300b5eb2dc4bd6c061e713ffd1133cab7a65b","modified":1552496324369},{"_id":"public/img/GitSource/branch.png","hash":"deddee0e02ed8f2d07d02a856385b8035818ee6b","modified":1552496324371},{"_id":"public/gif/WebView.gif","hash":"855e15e6870c39eed19cbbb162f3f70c289d16d5","modified":1552496324379},{"_id":"public/img/image.zip","hash":"98197bea26c5542c161767474d4eceac6977da45","modified":1552496324387},{"_id":"public/img/Signature.png","hash":"31bfd7385812f7952672f775350d27fbdd0e081c","modified":1552496324391}],"Category":[{"name":"小知识","_id":"cjt7g84or00034x2ntoeooaps"},{"name":"组件","_id":"cjt7g84p400074x2nlqjf6qkm"},{"name":"设计模式","_id":"cjt7g84pi000g4x2ncfbw8nis"},{"name":"环境搭建","_id":"cjt7g84px000m4x2nytg15l46"},{"name":"图片","_id":"cjt7g84q8000u4x2n43hi2l38"},{"name":"设计模式#分类","_id":"cjt7g84q9000x4x2nloek4es1"}],"Data":[],"Page":[{"title":"关于我","date":"2016-06-29T05:52:42.000Z","_content":"\n# Chausson\n[github](https://github.com/chausson/)\n## 简介\n\t暂时没有任何信息\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-06-29 13:52:42\n#description: 暂时没有任何信息\n---\n\n# Chausson\n[github](https://github.com/chausson/)\n## 简介\n\t暂时没有任何信息\n\n","updated":"2016-06-29T05:59:19.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjt7g84oj00014x2nt791p127","content":"<h1 id=\"Chausson\"><a href=\"#Chausson\" class=\"headerlink\" title=\"Chausson\"></a>Chausson</h1><p><a href=\"https://github.com/chausson/\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><pre><code>暂时没有任何信息\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Chausson\"><a href=\"#Chausson\" class=\"headerlink\" title=\"Chausson\"></a>Chausson</h1><p><a href=\"https://github.com/chausson/\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><pre><code>暂时没有任何信息\n</code></pre>"}],"Post":[{"title":"APP端和服务器的Request验证","date":"2016-10-21T09:30:47.000Z","_content":"\n# 为什么需要验证\n常规的网络请求多数App都会使用第三方网络请求,在多数情况下,我们只需要熟悉每个第三方提供API接口就足够支持大部分业务,往往会忽略一些安全问题。\n\n如果说我们的app请求被抓包，所有的接口信息被截获，这样任何一个开发人员掌握了我们的业务接口以及业务字段，就可以伪造发起一个假请求来攻击服务器，导致服务器瘫痪，数据错乱等严重性问题。\n\n# 如何避免\n我们可以利用每个接口传递的业务参数，设想一下，如果攻击者知道了我们的业务key以及接口的地址，那他就可以把想要修改的值伪造出来进行请求。\n最有效的方式是我们只要对每个request做验证签名的动作就在请求的时候做防护。\n为了防止恶意伪造的请求，app和服务器这边协商统一唯一的Key作为验证签名的钥匙。\n\n# 实现的流程是\n* 首先约定一个app和服务器的key\n* 将业务参数和key转换成一个MD532位编码\n* 将编码存放在请求头中传入服务器\n* 服务器将业务参数和key进行编码与请求头中的编码进行验证，如果是则代表是一个有效的请求。\n\n<img src=\"/img/Signature.png\"  title=\"Signature\">\n","source":"_posts/APP端和服务器的Request验证.md","raw":"---\ntitle: APP端和服务器的Request验证\ndate: 2016-10-21 17:30:47\ntags:\ncategories: 小知识 #分类\n---\n\n# 为什么需要验证\n常规的网络请求多数App都会使用第三方网络请求,在多数情况下,我们只需要熟悉每个第三方提供API接口就足够支持大部分业务,往往会忽略一些安全问题。\n\n如果说我们的app请求被抓包，所有的接口信息被截获，这样任何一个开发人员掌握了我们的业务接口以及业务字段，就可以伪造发起一个假请求来攻击服务器，导致服务器瘫痪，数据错乱等严重性问题。\n\n# 如何避免\n我们可以利用每个接口传递的业务参数，设想一下，如果攻击者知道了我们的业务key以及接口的地址，那他就可以把想要修改的值伪造出来进行请求。\n最有效的方式是我们只要对每个request做验证签名的动作就在请求的时候做防护。\n为了防止恶意伪造的请求，app和服务器这边协商统一唯一的Key作为验证签名的钥匙。\n\n# 实现的流程是\n* 首先约定一个app和服务器的key\n* 将业务参数和key转换成一个MD532位编码\n* 将编码存放在请求头中传入服务器\n* 服务器将业务参数和key进行编码与请求头中的编码进行验证，如果是则代表是一个有效的请求。\n\n<img src=\"/img/Signature.png\"  title=\"Signature\">\n","slug":"APP端和服务器的Request验证","published":1,"updated":"2016-10-26T07:28:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84od00004x2nikht6aiy","content":"<h1 id=\"为什么需要验证\"><a href=\"#为什么需要验证\" class=\"headerlink\" title=\"为什么需要验证\"></a>为什么需要验证</h1><p>常规的网络请求多数App都会使用第三方网络请求,在多数情况下,我们只需要熟悉每个第三方提供API接口就足够支持大部分业务,往往会忽略一些安全问题。</p>\n<p>如果说我们的app请求被抓包，所有的接口信息被截获，这样任何一个开发人员掌握了我们的业务接口以及业务字段，就可以伪造发起一个假请求来攻击服务器，导致服务器瘫痪，数据错乱等严重性问题。</p>\n<h1 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h1><p>我们可以利用每个接口传递的业务参数，设想一下，如果攻击者知道了我们的业务key以及接口的地址，那他就可以把想要修改的值伪造出来进行请求。<br>最有效的方式是我们只要对每个request做验证签名的动作就在请求的时候做防护。<br>为了防止恶意伪造的请求，app和服务器这边协商统一唯一的Key作为验证签名的钥匙。</p>\n<h1 id=\"实现的流程是\"><a href=\"#实现的流程是\" class=\"headerlink\" title=\"实现的流程是\"></a>实现的流程是</h1><ul>\n<li>首先约定一个app和服务器的key</li>\n<li>将业务参数和key转换成一个MD532位编码</li>\n<li>将编码存放在请求头中传入服务器</li>\n<li>服务器将业务参数和key进行编码与请求头中的编码进行验证，如果是则代表是一个有效的请求。</li>\n</ul>\n<p><img src=\"/img/Signature.png\" title=\"Signature\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么需要验证\"><a href=\"#为什么需要验证\" class=\"headerlink\" title=\"为什么需要验证\"></a>为什么需要验证</h1><p>常规的网络请求多数App都会使用第三方网络请求,在多数情况下,我们只需要熟悉每个第三方提供API接口就足够支持大部分业务,往往会忽略一些安全问题。</p>\n<p>如果说我们的app请求被抓包，所有的接口信息被截获，这样任何一个开发人员掌握了我们的业务接口以及业务字段，就可以伪造发起一个假请求来攻击服务器，导致服务器瘫痪，数据错乱等严重性问题。</p>\n<h1 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h1><p>我们可以利用每个接口传递的业务参数，设想一下，如果攻击者知道了我们的业务key以及接口的地址，那他就可以把想要修改的值伪造出来进行请求。<br>最有效的方式是我们只要对每个request做验证签名的动作就在请求的时候做防护。<br>为了防止恶意伪造的请求，app和服务器这边协商统一唯一的Key作为验证签名的钥匙。</p>\n<h1 id=\"实现的流程是\"><a href=\"#实现的流程是\" class=\"headerlink\" title=\"实现的流程是\"></a>实现的流程是</h1><ul>\n<li>首先约定一个app和服务器的key</li>\n<li>将业务参数和key转换成一个MD532位编码</li>\n<li>将编码存放在请求头中传入服务器</li>\n<li>服务器将业务参数和key进行编码与请求头中的编码进行验证，如果是则代表是一个有效的请求。</li>\n</ul>\n<p><img src=\"/img/Signature.png\" title=\"Signature\"></p>\n"},{"title":"Carthage的入门","date":"2016-11-24T09:36:06.000Z","_content":"","source":"_posts/Carthage的入门.md","raw":"---\ntitle: Carthage的入门\ndate: 2016-11-24 17:36:06\ntags:\n---\n","slug":"Carthage的入门","published":1,"updated":"2016-11-24T09:36:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84on00024x2ndfwxgcsg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"CHWebView搞定JS与OC交互","date":"2016-08-23T05:31:45.000Z","_content":"\n之前写过一篇文章分析[UIWebView与WKWebView](http://chausson.github.io/2016/08/09/UIWebView%E4%B8%8EWKWebView/),在这基础之实现继承自UIView的控件\nCHWebView ,将它作为一个Container包装UIWebView和WKWebView\n\nGithub地址：https://github.com/chausson/CHWebView\n（给开源的一个Star,谢谢）\n\n# 实现的功能\n* 实现JS与OC的调用\n* 自带默认进度条属性和协议\n* 将UIWebView和WKWebView统一API\n\n# 如何调用OC的方法\n\n1.Object-C需要使用CHWebView并且注册函数名称\n\n2.注册接收对象(使用CHWebViewController的话默认已经注册)\n\n3.实现注册的函数\n\n类似这样\n``` obj-c\n- (NSArray<NSString *> *)registerJavascriptName{\n    return @[@\"fetchMessage\",@\"show\"];\n}\n- (NSObject *)registerJavaScriptHandler{\n    return self;\n}\n- (void)fetchMessage:(NSDictionary *)dic{\n   \n}\n- (void)show{\n  \n}\n```\n\n4.JS如何调用?\n\n当OC这边都准备完毕,通过一行代码即可实现调用OC的方法\n\nOC将方法名获取后通过RunTime的机制发送消息给注册的对象\n\nhtml这边可以直接使用NativeBridge对象了,NativeBridge({name},{param})\n\nname '表示OC的函数名称'\n\nparam '表示需要传入的参数，支持Array,int,object,json'\n\n像这样\n``` javascript\n   function nativeFounction() {\n       var obj = { 'message' : 'Hello, JS!', 'numbers' : [ 1, 2, 3 ] };\n       window.NativeBridge('fetchMessage',obj)\n   }\n    function showUIFuction(){\n       window.NativeBridge('show')\n    }\n```\n\nCHWebView中使用的是WKWebView基于webkit的支持，WKWebView在加载这个Web的时候，默认会注册一个webkit.messageHandlers的对象，同时我在加载完成后注入了一个NativeBridge的对象，目的是为了webkit.messageHandlers和JSContent注入对象API的统一。当然也可以自己手动在加载web的时候导入这段JS\n``` javascript\n  window.NativeBridge = function(name,message){\n    var iosDevice = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n    if(iosDevice){\n       // Apple\n       if(this.hasOwnProperty(name)){\n            eval(\"window.\"+name+\"(message)\")\n       }else{\n            if(message == null){\n                message = ''\n           }\n            eval(\"webkit.messageHandlers.\"+name+\".postMessage(message)\")\n       }\n    }\n}\n```\n\n\n# OC调用JS方法\nWebView本身就支持调用js的方法，所以很方便，只需要实现CHWebView中的invokeJavaScript:把JS执行的方法传入就可以。\n\n# 进度条属性\nCHWebView中有一个协议是更新当前web加载进度的，UIWebView中是在web加载的时候添加一个监听器去监听每次的请求数量作为一个进度加载，WKWebView则是对系统默认的进度条属性进行监听。\n``` obj-c\n\t- (void)webView:(CHWebView *)webVie  updateProgress:(NSProgress *)progress;\n```\n\n# CHWebView设计图\n\n<img src=\"/img/CHWebView设计图.png\"  title=\"CHWebView设计图\">\n\n# Demo\n\n<img src=\"/gif/WebView.gif\"  title=\"CHWebView\">\n\n","source":"_posts/CHWebView搞定JS与OC交互.md","raw":"---\ntitle: CHWebView搞定JS与OC交互\ncategories: 组件 #分类\ndate: 2016-08-23 13:31:45\n#tags: [博客] #WebView\ntags:\n---\n\n之前写过一篇文章分析[UIWebView与WKWebView](http://chausson.github.io/2016/08/09/UIWebView%E4%B8%8EWKWebView/),在这基础之实现继承自UIView的控件\nCHWebView ,将它作为一个Container包装UIWebView和WKWebView\n\nGithub地址：https://github.com/chausson/CHWebView\n（给开源的一个Star,谢谢）\n\n# 实现的功能\n* 实现JS与OC的调用\n* 自带默认进度条属性和协议\n* 将UIWebView和WKWebView统一API\n\n# 如何调用OC的方法\n\n1.Object-C需要使用CHWebView并且注册函数名称\n\n2.注册接收对象(使用CHWebViewController的话默认已经注册)\n\n3.实现注册的函数\n\n类似这样\n``` obj-c\n- (NSArray<NSString *> *)registerJavascriptName{\n    return @[@\"fetchMessage\",@\"show\"];\n}\n- (NSObject *)registerJavaScriptHandler{\n    return self;\n}\n- (void)fetchMessage:(NSDictionary *)dic{\n   \n}\n- (void)show{\n  \n}\n```\n\n4.JS如何调用?\n\n当OC这边都准备完毕,通过一行代码即可实现调用OC的方法\n\nOC将方法名获取后通过RunTime的机制发送消息给注册的对象\n\nhtml这边可以直接使用NativeBridge对象了,NativeBridge({name},{param})\n\nname '表示OC的函数名称'\n\nparam '表示需要传入的参数，支持Array,int,object,json'\n\n像这样\n``` javascript\n   function nativeFounction() {\n       var obj = { 'message' : 'Hello, JS!', 'numbers' : [ 1, 2, 3 ] };\n       window.NativeBridge('fetchMessage',obj)\n   }\n    function showUIFuction(){\n       window.NativeBridge('show')\n    }\n```\n\nCHWebView中使用的是WKWebView基于webkit的支持，WKWebView在加载这个Web的时候，默认会注册一个webkit.messageHandlers的对象，同时我在加载完成后注入了一个NativeBridge的对象，目的是为了webkit.messageHandlers和JSContent注入对象API的统一。当然也可以自己手动在加载web的时候导入这段JS\n``` javascript\n  window.NativeBridge = function(name,message){\n    var iosDevice = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n    if(iosDevice){\n       // Apple\n       if(this.hasOwnProperty(name)){\n            eval(\"window.\"+name+\"(message)\")\n       }else{\n            if(message == null){\n                message = ''\n           }\n            eval(\"webkit.messageHandlers.\"+name+\".postMessage(message)\")\n       }\n    }\n}\n```\n\n\n# OC调用JS方法\nWebView本身就支持调用js的方法，所以很方便，只需要实现CHWebView中的invokeJavaScript:把JS执行的方法传入就可以。\n\n# 进度条属性\nCHWebView中有一个协议是更新当前web加载进度的，UIWebView中是在web加载的时候添加一个监听器去监听每次的请求数量作为一个进度加载，WKWebView则是对系统默认的进度条属性进行监听。\n``` obj-c\n\t- (void)webView:(CHWebView *)webVie  updateProgress:(NSProgress *)progress;\n```\n\n# CHWebView设计图\n\n<img src=\"/img/CHWebView设计图.png\"  title=\"CHWebView设计图\">\n\n# Demo\n\n<img src=\"/gif/WebView.gif\"  title=\"CHWebView\">\n\n","slug":"CHWebView搞定JS与OC交互","published":1,"updated":"2016-09-05T04:29:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84ow00044x2nj4skbcq3","content":"<p>之前写过一篇文章分析<a href=\"http://chausson.github.io/2016/08/09/UIWebView%E4%B8%8EWKWebView/\">UIWebView与WKWebView</a>,在这基础之实现继承自UIView的控件<br>CHWebView ,将它作为一个Container包装UIWebView和WKWebView</p>\n<p>Github地址：<a href=\"https://github.com/chausson/CHWebView\" target=\"_blank\" rel=\"noopener\">https://github.com/chausson/CHWebView</a><br>（给开源的一个Star,谢谢）</p>\n<h1 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a>实现的功能</h1><ul>\n<li>实现JS与OC的调用</li>\n<li>自带默认进度条属性和协议</li>\n<li>将UIWebView和WKWebView统一API</li>\n</ul>\n<h1 id=\"如何调用OC的方法\"><a href=\"#如何调用OC的方法\" class=\"headerlink\" title=\"如何调用OC的方法\"></a>如何调用OC的方法</h1><p>1.Object-C需要使用CHWebView并且注册函数名称</p>\n<p>2.注册接收对象(使用CHWebViewController的话默认已经注册)</p>\n<p>3.实现注册的函数</p>\n<p>类似这样<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)registerJavascriptName&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @[<span class=\"string\">@\"fetchMessage\"</span>,<span class=\"string\">@\"show\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSObject</span> *)registerJavaScriptHandler&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchMessage:(<span class=\"built_in\">NSDictionary</span> *)dic&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)show&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.JS如何调用?</p>\n<p>当OC这边都准备完毕,通过一行代码即可实现调用OC的方法</p>\n<p>OC将方法名获取后通过RunTime的机制发送消息给注册的对象</p>\n<p>html这边可以直接使用NativeBridge对象了,NativeBridge({name},{param})</p>\n<p>name ‘表示OC的函数名称’</p>\n<p>param ‘表示需要传入的参数，支持Array,int,object,json’</p>\n<p>像这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nativeFounction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123; <span class=\"string\">'message'</span> : <span class=\"string\">'Hello, JS!'</span>, <span class=\"string\">'numbers'</span> : [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ] &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.NativeBridge(<span class=\"string\">'fetchMessage'</span>,obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showUIFuction</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.NativeBridge(<span class=\"string\">'show'</span>)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>CHWebView中使用的是WKWebView基于webkit的支持，WKWebView在加载这个Web的时候，默认会注册一个webkit.messageHandlers的对象，同时我在加载完成后注入了一个NativeBridge的对象，目的是为了webkit.messageHandlers和JSContent注入对象API的统一。当然也可以自己手动在加载web的时候导入这段JS<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"built_in\">window</span>.NativeBridge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,message</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> iosDevice = !!navigator.userAgent.match(<span class=\"regexp\">/\\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iosDevice)&#123;</span><br><span class=\"line\">       <span class=\"comment\">// Apple</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.hasOwnProperty(name))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">eval</span>(<span class=\"string\">\"window.\"</span>+name+<span class=\"string\">\"(message)\"</span>)</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(message == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                message = <span class=\"string\">''</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">            <span class=\"built_in\">eval</span>(<span class=\"string\">\"webkit.messageHandlers.\"</span>+name+<span class=\"string\">\".postMessage(message)\"</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"OC调用JS方法\"><a href=\"#OC调用JS方法\" class=\"headerlink\" title=\"OC调用JS方法\"></a>OC调用JS方法</h1><p>WebView本身就支持调用js的方法，所以很方便，只需要实现CHWebView中的invokeJavaScript:把JS执行的方法传入就可以。</p>\n<h1 id=\"进度条属性\"><a href=\"#进度条属性\" class=\"headerlink\" title=\"进度条属性\"></a>进度条属性</h1><p>CHWebView中有一个协议是更新当前web加载进度的，UIWebView中是在web加载的时候添加一个监听器去监听每次的请求数量作为一个进度加载，WKWebView则是对系统默认的进度条属性进行监听。<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(CHWebView *)webVie  updateProgress:(<span class=\"built_in\">NSProgress</span> *)progress;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"CHWebView设计图\"><a href=\"#CHWebView设计图\" class=\"headerlink\" title=\"CHWebView设计图\"></a>CHWebView设计图</h1><p><img src=\"/img/CHWebView设计图.png\" title=\"CHWebView设计图\"></p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><img src=\"/gif/WebView.gif\" title=\"CHWebView\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前写过一篇文章分析<a href=\"http://chausson.github.io/2016/08/09/UIWebView%E4%B8%8EWKWebView/\">UIWebView与WKWebView</a>,在这基础之实现继承自UIView的控件<br>CHWebView ,将它作为一个Container包装UIWebView和WKWebView</p>\n<p>Github地址：<a href=\"https://github.com/chausson/CHWebView\" target=\"_blank\" rel=\"noopener\">https://github.com/chausson/CHWebView</a><br>（给开源的一个Star,谢谢）</p>\n<h1 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a>实现的功能</h1><ul>\n<li>实现JS与OC的调用</li>\n<li>自带默认进度条属性和协议</li>\n<li>将UIWebView和WKWebView统一API</li>\n</ul>\n<h1 id=\"如何调用OC的方法\"><a href=\"#如何调用OC的方法\" class=\"headerlink\" title=\"如何调用OC的方法\"></a>如何调用OC的方法</h1><p>1.Object-C需要使用CHWebView并且注册函数名称</p>\n<p>2.注册接收对象(使用CHWebViewController的话默认已经注册)</p>\n<p>3.实现注册的函数</p>\n<p>类似这样<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)registerJavascriptName&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> @[<span class=\"string\">@\"fetchMessage\"</span>,<span class=\"string\">@\"show\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSObject</span> *)registerJavaScriptHandler&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fetchMessage:(<span class=\"built_in\">NSDictionary</span> *)dic&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)show&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.JS如何调用?</p>\n<p>当OC这边都准备完毕,通过一行代码即可实现调用OC的方法</p>\n<p>OC将方法名获取后通过RunTime的机制发送消息给注册的对象</p>\n<p>html这边可以直接使用NativeBridge对象了,NativeBridge({name},{param})</p>\n<p>name ‘表示OC的函数名称’</p>\n<p>param ‘表示需要传入的参数，支持Array,int,object,json’</p>\n<p>像这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nativeFounction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123; <span class=\"string\">'message'</span> : <span class=\"string\">'Hello, JS!'</span>, <span class=\"string\">'numbers'</span> : [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ] &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.NativeBridge(<span class=\"string\">'fetchMessage'</span>,obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showUIFuction</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.NativeBridge(<span class=\"string\">'show'</span>)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>CHWebView中使用的是WKWebView基于webkit的支持，WKWebView在加载这个Web的时候，默认会注册一个webkit.messageHandlers的对象，同时我在加载完成后注入了一个NativeBridge的对象，目的是为了webkit.messageHandlers和JSContent注入对象API的统一。当然也可以自己手动在加载web的时候导入这段JS<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"built_in\">window</span>.NativeBridge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,message</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> iosDevice = !!navigator.userAgent.match(<span class=\"regexp\">/\\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iosDevice)&#123;</span><br><span class=\"line\">       <span class=\"comment\">// Apple</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.hasOwnProperty(name))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">eval</span>(<span class=\"string\">\"window.\"</span>+name+<span class=\"string\">\"(message)\"</span>)</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(message == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                message = <span class=\"string\">''</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">            <span class=\"built_in\">eval</span>(<span class=\"string\">\"webkit.messageHandlers.\"</span>+name+<span class=\"string\">\".postMessage(message)\"</span>)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"OC调用JS方法\"><a href=\"#OC调用JS方法\" class=\"headerlink\" title=\"OC调用JS方法\"></a>OC调用JS方法</h1><p>WebView本身就支持调用js的方法，所以很方便，只需要实现CHWebView中的invokeJavaScript:把JS执行的方法传入就可以。</p>\n<h1 id=\"进度条属性\"><a href=\"#进度条属性\" class=\"headerlink\" title=\"进度条属性\"></a>进度条属性</h1><p>CHWebView中有一个协议是更新当前web加载进度的，UIWebView中是在web加载的时候添加一个监听器去监听每次的请求数量作为一个进度加载，WKWebView则是对系统默认的进度条属性进行监听。<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(CHWebView *)webVie  updateProgress:(<span class=\"built_in\">NSProgress</span> *)progress;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"CHWebView设计图\"><a href=\"#CHWebView设计图\" class=\"headerlink\" title=\"CHWebView设计图\"></a>CHWebView设计图</h1><p><img src=\"/img/CHWebView设计图.png\" title=\"CHWebView设计图\"></p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><img src=\"/gif/WebView.gif\" title=\"CHWebView\"></p>\n"},{"title":"Git从入门到进阶","date":"2017-03-16T03:05:32.000Z","_content":"\n# Git的诞生\n学习一个东西，还是先从它的历史背景开始，可以加深一些文化背景和印象。Git是一个分散式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL释出。最初目的是为更好地管理Linux内核开发而设计。不得不说下林纳斯·托瓦兹（Linux 之父)这个天才，原本Linux内核主要的版本控制系统是使用BitKeeper来维护代码。最终因为版权问题，BitKeeper的作者收回无偿使用的授权，协商未果的情况下，林纳斯·托瓦兹决定自己开发一套版本控制系统来代替BitKeeper，以十天的时间，编写出第一个git版本。天才都是任性的，你不给我用，我自己做一个。\n\n# 基础入门使用\n这里就不讲Git的安装了，先说下使用的方式，可以通过命令行的方式来操作Git，当然有的小伙伴如果没有编程基础，可以尝试使用客户端来使用也非常方便实用。推荐用的比较多的是SourceTree但是它最大的问题就是账号如果是谷歌的，很有可能被墙。\n\n## 仓库\n在使用的过程中我们需要注意一下基础的概念，每次操作的时候我们都是在一个仓库上面进行操作，或者说是版本库（Repository）。可以把它理解成一个文件夹的路径，这个文件内保存着所有你的代码或者文件，同时通过我们git的一些命令可以实现文件版本控制的功能。每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以找到并且回退。\n\n## 第一步:创建仓库\n选择一个你喜欢的路径，创建一个空的文件夹目录:\n\n``` c\n$ mkdir MyFristRepository\n$ cd MyFristRepository\n\n```\n\n\n## 第二步:初始化仓库\n在第一步完成以后，通过git init命令把这个目录变成Git可以管理的仓库：\n\n``` c\n$ git init\nInitialized empty Git repository in /Users/chausson/Documents/Blog/MyFristRepository/.git/\n\n```\n当然这只是在你本地电脑创建了这个仓库，通常我们会去初始化一个远程的仓库，这样才能协作开发\n如下是对一个远程http仓库的Clone，就是先将远端仓库的内容下载到你本地，当然也可以使用ssh方式访问。\n``` c\n$ git clone  http://gitlab.sudaotech.com/auto2/erp-web.git\n```\n\n\n当你完成第一步的时候，你可以发现在你刚刚的空目录下有一个.git的目录,这个目录是Git来跟踪管理版本库的.如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见\n\n## 第三步:把文件添加到仓库\nGit是一个非常强大好用的工具，它不止是代码版本管理系统，也是所有文件版本管理系统。对于文本文件它会跟踪其中内容的变更，版本控制系统可以告诉你每次的改动。在当前的仓库目录下，添加你所需要管理的文件\n\n``` c\n$ git add file.jpeg\n\n\n```\n\n如果你执行了该命令没有反应,不要担心，说明你已经成功了。因为这里没有消息就是好消息。\n\n## 第四步:把文件提交到本地仓库\n这里你会发现，不是打错了，第三步和第四步是两个流程，这一步是真正把文件提交到仓库，而上一步是将文件添加到仓库的暂存区，其中的区别稍后会解释。\n``` c\n$ git commit -m \"First Commit\"\n\n\n```\n 这里为什么需要分两步去做呢，其实在做add命令的时候我们只是先把文件放入暂存区,commit要做的事情就是将所有暂存区的内容提交到仓库中。因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n ``` c\n$ git add file.jpeg\n$ git add time.png\n$ git commit -m \"add 2 files.\"\n\n ```\n 比如我们要寄送一份快递文件，所有的快递都会先通过快递员收取，然后快递员统一去寄送到公司仓库运送到各个省市。当然暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n <img src=\"/img/GitSource/cache.png\">\n\n ## 第五步:把文件提交到远程仓库\n 之前的操作只是我们把文件提交到本地的仓库，最后我们要做的就是把本地电脑中的文件提交到远程服务器，提供给其他人展示下载。在我们当前仓库的目录下添加远端仓库的依赖关系:\n ``` c\n$ git remote add chausson http://gitlab.sudaotech.com/chausson/git-example.git\n$ git push -u chausson master\n\n ```\n把本地库的内容推送到远程仓库，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n# Git分支管理\n每次提交Git会把当前分支串成一条时间线，这条时间线也就是一个分支，每个仓库都会有一条主线，一般我们叫做主干即master分支。在最初的时候master一般是一条直线,Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点:\n <img src=\"/img/GitSource/master.png\">\n\n每次提交都会生成一个新的结点，随着你的提交次数，结点的个数也一直在增加。master既然作为主干，应该是要保持稳定的，仅仅是用来构建，或者打包版本使用，该分支不能用来开发。\n所以我们必须新建一个dev的分支，在上面进行开发和提交，最终完成后合并到master,每个开发建立自己的分支，开发完以后合并到dev上就可以。\n\n <img src=\"/img/GitSource/branch.png\">\n \n\n\n\n\n\n\n\n","source":"_posts/Git从入门到进阶.md","raw":"---\ntitle: Git从入门到进阶\ndate: 2017-03-16 11:05:32\ntags:\n---\n\n# Git的诞生\n学习一个东西，还是先从它的历史背景开始，可以加深一些文化背景和印象。Git是一个分散式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL释出。最初目的是为更好地管理Linux内核开发而设计。不得不说下林纳斯·托瓦兹（Linux 之父)这个天才，原本Linux内核主要的版本控制系统是使用BitKeeper来维护代码。最终因为版权问题，BitKeeper的作者收回无偿使用的授权，协商未果的情况下，林纳斯·托瓦兹决定自己开发一套版本控制系统来代替BitKeeper，以十天的时间，编写出第一个git版本。天才都是任性的，你不给我用，我自己做一个。\n\n# 基础入门使用\n这里就不讲Git的安装了，先说下使用的方式，可以通过命令行的方式来操作Git，当然有的小伙伴如果没有编程基础，可以尝试使用客户端来使用也非常方便实用。推荐用的比较多的是SourceTree但是它最大的问题就是账号如果是谷歌的，很有可能被墙。\n\n## 仓库\n在使用的过程中我们需要注意一下基础的概念，每次操作的时候我们都是在一个仓库上面进行操作，或者说是版本库（Repository）。可以把它理解成一个文件夹的路径，这个文件内保存着所有你的代码或者文件，同时通过我们git的一些命令可以实现文件版本控制的功能。每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以找到并且回退。\n\n## 第一步:创建仓库\n选择一个你喜欢的路径，创建一个空的文件夹目录:\n\n``` c\n$ mkdir MyFristRepository\n$ cd MyFristRepository\n\n```\n\n\n## 第二步:初始化仓库\n在第一步完成以后，通过git init命令把这个目录变成Git可以管理的仓库：\n\n``` c\n$ git init\nInitialized empty Git repository in /Users/chausson/Documents/Blog/MyFristRepository/.git/\n\n```\n当然这只是在你本地电脑创建了这个仓库，通常我们会去初始化一个远程的仓库，这样才能协作开发\n如下是对一个远程http仓库的Clone，就是先将远端仓库的内容下载到你本地，当然也可以使用ssh方式访问。\n``` c\n$ git clone  http://gitlab.sudaotech.com/auto2/erp-web.git\n```\n\n\n当你完成第一步的时候，你可以发现在你刚刚的空目录下有一个.git的目录,这个目录是Git来跟踪管理版本库的.如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见\n\n## 第三步:把文件添加到仓库\nGit是一个非常强大好用的工具，它不止是代码版本管理系统，也是所有文件版本管理系统。对于文本文件它会跟踪其中内容的变更，版本控制系统可以告诉你每次的改动。在当前的仓库目录下，添加你所需要管理的文件\n\n``` c\n$ git add file.jpeg\n\n\n```\n\n如果你执行了该命令没有反应,不要担心，说明你已经成功了。因为这里没有消息就是好消息。\n\n## 第四步:把文件提交到本地仓库\n这里你会发现，不是打错了，第三步和第四步是两个流程，这一步是真正把文件提交到仓库，而上一步是将文件添加到仓库的暂存区，其中的区别稍后会解释。\n``` c\n$ git commit -m \"First Commit\"\n\n\n```\n 这里为什么需要分两步去做呢，其实在做add命令的时候我们只是先把文件放入暂存区,commit要做的事情就是将所有暂存区的内容提交到仓库中。因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n ``` c\n$ git add file.jpeg\n$ git add time.png\n$ git commit -m \"add 2 files.\"\n\n ```\n 比如我们要寄送一份快递文件，所有的快递都会先通过快递员收取，然后快递员统一去寄送到公司仓库运送到各个省市。当然暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n <img src=\"/img/GitSource/cache.png\">\n\n ## 第五步:把文件提交到远程仓库\n 之前的操作只是我们把文件提交到本地的仓库，最后我们要做的就是把本地电脑中的文件提交到远程服务器，提供给其他人展示下载。在我们当前仓库的目录下添加远端仓库的依赖关系:\n ``` c\n$ git remote add chausson http://gitlab.sudaotech.com/chausson/git-example.git\n$ git push -u chausson master\n\n ```\n把本地库的内容推送到远程仓库，用git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n# Git分支管理\n每次提交Git会把当前分支串成一条时间线，这条时间线也就是一个分支，每个仓库都会有一条主线，一般我们叫做主干即master分支。在最初的时候master一般是一条直线,Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点:\n <img src=\"/img/GitSource/master.png\">\n\n每次提交都会生成一个新的结点，随着你的提交次数，结点的个数也一直在增加。master既然作为主干，应该是要保持稳定的，仅仅是用来构建，或者打包版本使用，该分支不能用来开发。\n所以我们必须新建一个dev的分支，在上面进行开发和提交，最终完成后合并到master,每个开发建立自己的分支，开发完以后合并到dev上就可以。\n\n <img src=\"/img/GitSource/branch.png\">\n \n\n\n\n\n\n\n\n","slug":"Git从入门到进阶","published":1,"updated":"2017-03-16T10:31:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84oz00054x2nfdkzc0s6","content":"<h1 id=\"Git的诞生\"><a href=\"#Git的诞生\" class=\"headerlink\" title=\"Git的诞生\"></a>Git的诞生</h1><p>学习一个东西，还是先从它的历史背景开始，可以加深一些文化背景和印象。Git是一个分散式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL释出。最初目的是为更好地管理Linux内核开发而设计。不得不说下林纳斯·托瓦兹（Linux 之父)这个天才，原本Linux内核主要的版本控制系统是使用BitKeeper来维护代码。最终因为版权问题，BitKeeper的作者收回无偿使用的授权，协商未果的情况下，林纳斯·托瓦兹决定自己开发一套版本控制系统来代替BitKeeper，以十天的时间，编写出第一个git版本。天才都是任性的，你不给我用，我自己做一个。</p>\n<h1 id=\"基础入门使用\"><a href=\"#基础入门使用\" class=\"headerlink\" title=\"基础入门使用\"></a>基础入门使用</h1><p>这里就不讲Git的安装了，先说下使用的方式，可以通过命令行的方式来操作Git，当然有的小伙伴如果没有编程基础，可以尝试使用客户端来使用也非常方便实用。推荐用的比较多的是SourceTree但是它最大的问题就是账号如果是谷歌的，很有可能被墙。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在使用的过程中我们需要注意一下基础的概念，每次操作的时候我们都是在一个仓库上面进行操作，或者说是版本库（Repository）。可以把它理解成一个文件夹的路径，这个文件内保存着所有你的代码或者文件，同时通过我们git的一些命令可以实现文件版本控制的功能。每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以找到并且回退。</p>\n<h2 id=\"第一步-创建仓库\"><a href=\"#第一步-创建仓库\" class=\"headerlink\" title=\"第一步:创建仓库\"></a>第一步:创建仓库</h2><p>选择一个你喜欢的路径，创建一个空的文件夹目录:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir MyFristRepository</span><br><span class=\"line\">$ cd MyFristRepository</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二步-初始化仓库\"><a href=\"#第二步-初始化仓库\" class=\"headerlink\" title=\"第二步:初始化仓库\"></a>第二步:初始化仓库</h2><p>在第一步完成以后，通过git init命令把这个目录变成Git可以管理的仓库：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in /Users/chausson/Documents/Blog/MyFristRepository/.git/</span><br></pre></td></tr></table></figure>\n<p>当然这只是在你本地电脑创建了这个仓库，通常我们会去初始化一个远程的仓库，这样才能协作开发<br>如下是对一个远程http仓库的Clone，就是先将远端仓库的内容下载到你本地，当然也可以使用ssh方式访问。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone  http:<span class=\"comment\">//gitlab.sudaotech.com/auto2/erp-web.git</span></span><br></pre></td></tr></table></figure></p>\n<p>当你完成第一步的时候，你可以发现在你刚刚的空目录下有一个.git的目录,这个目录是Git来跟踪管理版本库的.如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见</p>\n<h2 id=\"第三步-把文件添加到仓库\"><a href=\"#第三步-把文件添加到仓库\" class=\"headerlink\" title=\"第三步:把文件添加到仓库\"></a>第三步:把文件添加到仓库</h2><p>Git是一个非常强大好用的工具，它不止是代码版本管理系统，也是所有文件版本管理系统。对于文本文件它会跟踪其中内容的变更，版本控制系统可以告诉你每次的改动。在当前的仓库目录下，添加你所需要管理的文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file.jpeg</span><br></pre></td></tr></table></figure>\n<p>如果你执行了该命令没有反应,不要担心，说明你已经成功了。因为这里没有消息就是好消息。</p>\n<h2 id=\"第四步-把文件提交到本地仓库\"><a href=\"#第四步-把文件提交到本地仓库\" class=\"headerlink\" title=\"第四步:把文件提交到本地仓库\"></a>第四步:把文件提交到本地仓库</h2><p>这里你会发现，不是打错了，第三步和第四步是两个流程，这一步是真正把文件提交到仓库，而上一步是将文件添加到仓库的暂存区，其中的区别稍后会解释。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"First Commit\"</span></span><br></pre></td></tr></table></figure></p>\n<p> 这里为什么需要分两步去做呢，其实在做add命令的时候我们只是先把文件放入暂存区,commit要做的事情就是将所有暂存区的内容提交到仓库中。因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file.jpeg</span><br><span class=\"line\">$ git add time.png</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add 2 files.\"</span></span><br></pre></td></tr></table></figure></p>\n<p> 比如我们要寄送一份快递文件，所有的快递都会先通过快递员收取，然后快递员统一去寄送到公司仓库运送到各个省市。当然暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。<br> <img src=\"/img/GitSource/cache.png\"></p>\n<h2 id=\"第五步-把文件提交到远程仓库\"><a href=\"#第五步-把文件提交到远程仓库\" class=\"headerlink\" title=\"第五步:把文件提交到远程仓库\"></a>第五步:把文件提交到远程仓库</h2><p> 之前的操作只是我们把文件提交到本地的仓库，最后我们要做的就是把本地电脑中的文件提交到远程服务器，提供给其他人展示下载。在我们当前仓库的目录下添加远端仓库的依赖关系:<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add chausson http:<span class=\"comment\">//gitlab.sudaotech.com/chausson/git-example.git</span></span><br><span class=\"line\">$ git push -u chausson master</span><br></pre></td></tr></table></figure></p>\n<p>把本地库的内容推送到远程仓库，用git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<h1 id=\"Git分支管理\"><a href=\"#Git分支管理\" class=\"headerlink\" title=\"Git分支管理\"></a>Git分支管理</h1><p>每次提交Git会把当前分支串成一条时间线，这条时间线也就是一个分支，每个仓库都会有一条主线，一般我们叫做主干即master分支。在最初的时候master一般是一条直线,Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点:<br> <img src=\"/img/GitSource/master.png\"></p>\n<p>每次提交都会生成一个新的结点，随着你的提交次数，结点的个数也一直在增加。master既然作为主干，应该是要保持稳定的，仅仅是用来构建，或者打包版本使用，该分支不能用来开发。<br>所以我们必须新建一个dev的分支，在上面进行开发和提交，最终完成后合并到master,每个开发建立自己的分支，开发完以后合并到dev上就可以。</p>\n<p> <img src=\"/img/GitSource/branch.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Git的诞生\"><a href=\"#Git的诞生\" class=\"headerlink\" title=\"Git的诞生\"></a>Git的诞生</h1><p>学习一个东西，还是先从它的历史背景开始，可以加深一些文化背景和印象。Git是一个分散式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL释出。最初目的是为更好地管理Linux内核开发而设计。不得不说下林纳斯·托瓦兹（Linux 之父)这个天才，原本Linux内核主要的版本控制系统是使用BitKeeper来维护代码。最终因为版权问题，BitKeeper的作者收回无偿使用的授权，协商未果的情况下，林纳斯·托瓦兹决定自己开发一套版本控制系统来代替BitKeeper，以十天的时间，编写出第一个git版本。天才都是任性的，你不给我用，我自己做一个。</p>\n<h1 id=\"基础入门使用\"><a href=\"#基础入门使用\" class=\"headerlink\" title=\"基础入门使用\"></a>基础入门使用</h1><p>这里就不讲Git的安装了，先说下使用的方式，可以通过命令行的方式来操作Git，当然有的小伙伴如果没有编程基础，可以尝试使用客户端来使用也非常方便实用。推荐用的比较多的是SourceTree但是它最大的问题就是账号如果是谷歌的，很有可能被墙。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在使用的过程中我们需要注意一下基础的概念，每次操作的时候我们都是在一个仓库上面进行操作，或者说是版本库（Repository）。可以把它理解成一个文件夹的路径，这个文件内保存着所有你的代码或者文件，同时通过我们git的一些命令可以实现文件版本控制的功能。每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以找到并且回退。</p>\n<h2 id=\"第一步-创建仓库\"><a href=\"#第一步-创建仓库\" class=\"headerlink\" title=\"第一步:创建仓库\"></a>第一步:创建仓库</h2><p>选择一个你喜欢的路径，创建一个空的文件夹目录:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir MyFristRepository</span><br><span class=\"line\">$ cd MyFristRepository</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二步-初始化仓库\"><a href=\"#第二步-初始化仓库\" class=\"headerlink\" title=\"第二步:初始化仓库\"></a>第二步:初始化仓库</h2><p>在第一步完成以后，通过git init命令把这个目录变成Git可以管理的仓库：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in /Users/chausson/Documents/Blog/MyFristRepository/.git/</span><br></pre></td></tr></table></figure>\n<p>当然这只是在你本地电脑创建了这个仓库，通常我们会去初始化一个远程的仓库，这样才能协作开发<br>如下是对一个远程http仓库的Clone，就是先将远端仓库的内容下载到你本地，当然也可以使用ssh方式访问。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone  http:<span class=\"comment\">//gitlab.sudaotech.com/auto2/erp-web.git</span></span><br></pre></td></tr></table></figure></p>\n<p>当你完成第一步的时候，你可以发现在你刚刚的空目录下有一个.git的目录,这个目录是Git来跟踪管理版本库的.如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见</p>\n<h2 id=\"第三步-把文件添加到仓库\"><a href=\"#第三步-把文件添加到仓库\" class=\"headerlink\" title=\"第三步:把文件添加到仓库\"></a>第三步:把文件添加到仓库</h2><p>Git是一个非常强大好用的工具，它不止是代码版本管理系统，也是所有文件版本管理系统。对于文本文件它会跟踪其中内容的变更，版本控制系统可以告诉你每次的改动。在当前的仓库目录下，添加你所需要管理的文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file.jpeg</span><br></pre></td></tr></table></figure>\n<p>如果你执行了该命令没有反应,不要担心，说明你已经成功了。因为这里没有消息就是好消息。</p>\n<h2 id=\"第四步-把文件提交到本地仓库\"><a href=\"#第四步-把文件提交到本地仓库\" class=\"headerlink\" title=\"第四步:把文件提交到本地仓库\"></a>第四步:把文件提交到本地仓库</h2><p>这里你会发现，不是打错了，第三步和第四步是两个流程，这一步是真正把文件提交到仓库，而上一步是将文件添加到仓库的暂存区，其中的区别稍后会解释。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"First Commit\"</span></span><br></pre></td></tr></table></figure></p>\n<p> 这里为什么需要分两步去做呢，其实在做add命令的时候我们只是先把文件放入暂存区,commit要做的事情就是将所有暂存区的内容提交到仓库中。因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file.jpeg</span><br><span class=\"line\">$ git add time.png</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add 2 files.\"</span></span><br></pre></td></tr></table></figure></p>\n<p> 比如我们要寄送一份快递文件，所有的快递都会先通过快递员收取，然后快递员统一去寄送到公司仓库运送到各个省市。当然暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。<br> <img src=\"/img/GitSource/cache.png\"></p>\n<h2 id=\"第五步-把文件提交到远程仓库\"><a href=\"#第五步-把文件提交到远程仓库\" class=\"headerlink\" title=\"第五步:把文件提交到远程仓库\"></a>第五步:把文件提交到远程仓库</h2><p> 之前的操作只是我们把文件提交到本地的仓库，最后我们要做的就是把本地电脑中的文件提交到远程服务器，提供给其他人展示下载。在我们当前仓库的目录下添加远端仓库的依赖关系:<br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add chausson http:<span class=\"comment\">//gitlab.sudaotech.com/chausson/git-example.git</span></span><br><span class=\"line\">$ git push -u chausson master</span><br></pre></td></tr></table></figure></p>\n<p>把本地库的内容推送到远程仓库，用git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<h1 id=\"Git分支管理\"><a href=\"#Git分支管理\" class=\"headerlink\" title=\"Git分支管理\"></a>Git分支管理</h1><p>每次提交Git会把当前分支串成一条时间线，这条时间线也就是一个分支，每个仓库都会有一条主线，一般我们叫做主干即master分支。在最初的时候master一般是一条直线,Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点:<br> <img src=\"/img/GitSource/master.png\"></p>\n<p>每次提交都会生成一个新的结点，随着你的提交次数，结点的个数也一直在增加。master既然作为主干，应该是要保持稳定的，仅仅是用来构建，或者打包版本使用，该分支不能用来开发。<br>所以我们必须新建一个dev的分支，在上面进行开发和提交，最终完成后合并到master,每个开发建立自己的分支，开发完以后合并到dev上就可以。</p>\n<p> <img src=\"/img/GitSource/branch.png\"></p>\n"},{"title":"JSONExport 源码解析","date":"2019-03-13T16:30:27.000Z","_content":"\n## 代码生成代码——JSONExport解析\n\n因为最近想开发一款网路的大礼包，类似Mock API 到Model 的生成，通过一个按钮，或者一行命令去完成，来提高开发效率，节省重复劳动力，毕竟我们开发所有轮子的目的就在于此。\n\n其中不免需要用到代码生成文件之类的功能，那如何生成呢？\n\n答案有很多，不过大抵都是通过代码来生成代码，也有一些优秀的开源库和工具，接下来就介绍我们今天的主角**JSONExport**(https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。\n\n它是一款Mac的App,通过Swift语言来编写，需要在网站上下载工程用Xcode编译运行。\n\n运行后，大致是长这样:\n\n![](jsonexport.png)\n\n左边输入JSON，右边生成文件预览，右下角根据选择的语言，通过方法loadSupportedLanguages()来读取本地模版。\n\n作者在工程中定义了一系列的数据模版来将JSON来映射解析，类似如这样:\n\n``` json\n{\n  \"langName\": \"名称\", // 模版名称\n  \"modelStart\": \"\",\n  \"basicTypesWithSpecialFetchingNeedsReplacements\": [], // 类型转换映射\n  \"basicTypesWithSpecialStoringNeeds\": [], // 基础类型映射\n  \"importForEachCustomType\": \"\", \n  \"reservedKeywords\": [], //关键字转换\n  \"briefDescription\": \"\", //生成的描述\n  \"utilityMethods\": [],\n  \"dataTypes\": {}, // 基础类型映射\n  \"wordsToRemoveToGetArrayElementsType\": [],\n  \"constructors\": [],\n  \"constVarDefinition\": \"\",\n  \"modelDefinition\": \"\",\n  \"genericType\": \"\",\n  \"headerFileData\": {\n    \"modelDefinitionWithParent\": \"\",\n    \"modelEnd\": \"\",\n    \"instanceVarDefinition\": \"\",\n    \"utilityMethodSignatures\": [],\n    \"constructorSignatures\": [],\n    \"typesNeedSpecialDefinition\": [],\n    \"modelStart\": \"\",\n    \"importParentHeaderFile\": \"\",\n    \"headerFileExtension\": \"\",\n    \"modelDefinition\": \"\",\n    \"importForEachCustomType\": \"\",\n    \"instanceVarWithSpeicalDefinition\": \"\",\n    \"staticImports\": \"#import <UIKit/UIKit.h>\"\n  }, // OC头文件\n  \"fileExtension\": \"\", // 文件后缀，导出文件拼接用\n  \"arrayType\": \"NSArray\",\n  \"basicTypesWithSpecialFetchingNeeds\": [],\n  \"displayLangName\": \"\", //客户端显示的语言名称,如:Swift,Objective-C\n  \"instanceVarDefinition\": \"\",\n  \"supportsFirstLineStatement\": \"\",\n  \"modelEnd\": \"\",\n  \"staticImports\": \"\", // 需要导入的静态包\n  \"importHeaderFile\": \"\"\n}\n```\n\n\n\n流程大致是这样:\n\n![](progress.png)\n\n模版中有需要一些动态插入的部分，如属性名，类名等之类的，用了<!ModelName!>,<!VarName!>作为关键次，在插入字符串过程中，会映射替换JSON的内容。可以看下**SharedConstants.swift**文件中：\n\n```swif\nlet elementType = \"<!ElementType!>\"\nlet modelName = \"<!ModelName!>\"\nlet modelWithParentClassName = \"<!ParentClass!>\"\nlet varName = \"<!VarName!>\"\nlet capitalizedVarName = \"<!CapitalizedVarName!>\"\nlet varType = \"<!VarType!>\"\nlet varTypeReplacement = \"<!VarBasicTypeReplacement!>\"\nlet varTypeCast = \"<!VarBasicTypeCast!>\"\nlet capitalizedVarType = \"<!CapitalizedVarType!>\"\nlet lowerCaseVarType = \"<!LowerCaseVarType!>\"\nlet lowerCaseModelName = \"<!LowerCaseModelName!>\"\nlet jsonKeyName = \"<!JsonKeyName!>\"\nlet constKeyName = \"<!ConstKeyName!>\"\nlet additionalCustomTypeProperty = \"<!AdditionalForCustomTypeProperty!>\"\n```\n\n在上面的文件中基本是定义了大量关键词，从这里不难看出，其中的属性与JSON的模版文件来进行映射关系的，使插入的内容能够动态去生成。\n\n在生成字符串的过程中，是逐行逐行来写入文件，就像我们的打印机一样一行一行来输出，用换行符\\n和\\t来进行格式排版的控制,最后替换关键词，这样的思路确实是能够胜任代码生成代码的部分。\n\n可以知道的是在其中作者用一套解析方式，应用于多个模版，如果生成的文件需要增加的同时，也需要增加一个模版。下面具体来解析一下源码中的代码设计，整个思路大致是这样，但是作者使用的设计模式还是值得学习的。\n\n是不是现在有点疑惑，各种模型生成的方式不一样Swift,Objective-C,Java，怎么用一套规则去解析生成呢。那么我们就了解下源码中的一些代码设计方式。首先看一下一些类的结构，大致分为三组，也可以定义为三层:\n\n- Supported Languages(模版文件) => Data层\n- Lang Data Models (模版文件模型)  => Model层\n- File content generators （文件生成转化类) => Service层\n\n##### Supported Languages(模版文件) => Data层\n\n##### Lang Data Models (模版文件模型)  => Model层\n\n##### File content generators （文件生成转化类) => Service层\n\n当然还有其他文件生成的方式，如**Sourcery** 框架，但只针对于Swift文件语言写入。利用Swift中xxxxx。\n\n\n","source":"_posts/JSONExport-源码解析.md","raw":"---\ntitle: JSONExport 源码解析\ndate: 2019-03-14 00:30:27\ntags:\n---\n\n## 代码生成代码——JSONExport解析\n\n因为最近想开发一款网路的大礼包，类似Mock API 到Model 的生成，通过一个按钮，或者一行命令去完成，来提高开发效率，节省重复劳动力，毕竟我们开发所有轮子的目的就在于此。\n\n其中不免需要用到代码生成文件之类的功能，那如何生成呢？\n\n答案有很多，不过大抵都是通过代码来生成代码，也有一些优秀的开源库和工具，接下来就介绍我们今天的主角**JSONExport**(https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。\n\n它是一款Mac的App,通过Swift语言来编写，需要在网站上下载工程用Xcode编译运行。\n\n运行后，大致是长这样:\n\n![](jsonexport.png)\n\n左边输入JSON，右边生成文件预览，右下角根据选择的语言，通过方法loadSupportedLanguages()来读取本地模版。\n\n作者在工程中定义了一系列的数据模版来将JSON来映射解析，类似如这样:\n\n``` json\n{\n  \"langName\": \"名称\", // 模版名称\n  \"modelStart\": \"\",\n  \"basicTypesWithSpecialFetchingNeedsReplacements\": [], // 类型转换映射\n  \"basicTypesWithSpecialStoringNeeds\": [], // 基础类型映射\n  \"importForEachCustomType\": \"\", \n  \"reservedKeywords\": [], //关键字转换\n  \"briefDescription\": \"\", //生成的描述\n  \"utilityMethods\": [],\n  \"dataTypes\": {}, // 基础类型映射\n  \"wordsToRemoveToGetArrayElementsType\": [],\n  \"constructors\": [],\n  \"constVarDefinition\": \"\",\n  \"modelDefinition\": \"\",\n  \"genericType\": \"\",\n  \"headerFileData\": {\n    \"modelDefinitionWithParent\": \"\",\n    \"modelEnd\": \"\",\n    \"instanceVarDefinition\": \"\",\n    \"utilityMethodSignatures\": [],\n    \"constructorSignatures\": [],\n    \"typesNeedSpecialDefinition\": [],\n    \"modelStart\": \"\",\n    \"importParentHeaderFile\": \"\",\n    \"headerFileExtension\": \"\",\n    \"modelDefinition\": \"\",\n    \"importForEachCustomType\": \"\",\n    \"instanceVarWithSpeicalDefinition\": \"\",\n    \"staticImports\": \"#import <UIKit/UIKit.h>\"\n  }, // OC头文件\n  \"fileExtension\": \"\", // 文件后缀，导出文件拼接用\n  \"arrayType\": \"NSArray\",\n  \"basicTypesWithSpecialFetchingNeeds\": [],\n  \"displayLangName\": \"\", //客户端显示的语言名称,如:Swift,Objective-C\n  \"instanceVarDefinition\": \"\",\n  \"supportsFirstLineStatement\": \"\",\n  \"modelEnd\": \"\",\n  \"staticImports\": \"\", // 需要导入的静态包\n  \"importHeaderFile\": \"\"\n}\n```\n\n\n\n流程大致是这样:\n\n![](progress.png)\n\n模版中有需要一些动态插入的部分，如属性名，类名等之类的，用了<!ModelName!>,<!VarName!>作为关键次，在插入字符串过程中，会映射替换JSON的内容。可以看下**SharedConstants.swift**文件中：\n\n```swif\nlet elementType = \"<!ElementType!>\"\nlet modelName = \"<!ModelName!>\"\nlet modelWithParentClassName = \"<!ParentClass!>\"\nlet varName = \"<!VarName!>\"\nlet capitalizedVarName = \"<!CapitalizedVarName!>\"\nlet varType = \"<!VarType!>\"\nlet varTypeReplacement = \"<!VarBasicTypeReplacement!>\"\nlet varTypeCast = \"<!VarBasicTypeCast!>\"\nlet capitalizedVarType = \"<!CapitalizedVarType!>\"\nlet lowerCaseVarType = \"<!LowerCaseVarType!>\"\nlet lowerCaseModelName = \"<!LowerCaseModelName!>\"\nlet jsonKeyName = \"<!JsonKeyName!>\"\nlet constKeyName = \"<!ConstKeyName!>\"\nlet additionalCustomTypeProperty = \"<!AdditionalForCustomTypeProperty!>\"\n```\n\n在上面的文件中基本是定义了大量关键词，从这里不难看出，其中的属性与JSON的模版文件来进行映射关系的，使插入的内容能够动态去生成。\n\n在生成字符串的过程中，是逐行逐行来写入文件，就像我们的打印机一样一行一行来输出，用换行符\\n和\\t来进行格式排版的控制,最后替换关键词，这样的思路确实是能够胜任代码生成代码的部分。\n\n可以知道的是在其中作者用一套解析方式，应用于多个模版，如果生成的文件需要增加的同时，也需要增加一个模版。下面具体来解析一下源码中的代码设计，整个思路大致是这样，但是作者使用的设计模式还是值得学习的。\n\n是不是现在有点疑惑，各种模型生成的方式不一样Swift,Objective-C,Java，怎么用一套规则去解析生成呢。那么我们就了解下源码中的一些代码设计方式。首先看一下一些类的结构，大致分为三组，也可以定义为三层:\n\n- Supported Languages(模版文件) => Data层\n- Lang Data Models (模版文件模型)  => Model层\n- File content generators （文件生成转化类) => Service层\n\n##### Supported Languages(模版文件) => Data层\n\n##### Lang Data Models (模版文件模型)  => Model层\n\n##### File content generators （文件生成转化类) => Service层\n\n当然还有其他文件生成的方式，如**Sourcery** 框架，但只针对于Swift文件语言写入。利用Swift中xxxxx。\n\n\n","slug":"JSONExport-源码解析","published":1,"updated":"2019-03-13T16:42:58.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84p200064x2n3o68n2z4","content":"<h2 id=\"代码生成代码——JSONExport解析\"><a href=\"#代码生成代码——JSONExport解析\" class=\"headerlink\" title=\"代码生成代码——JSONExport解析\"></a>代码生成代码——JSONExport解析</h2><p>因为最近想开发一款网路的大礼包，类似Mock API 到Model 的生成，通过一个按钮，或者一行命令去完成，来提高开发效率，节省重复劳动力，毕竟我们开发所有轮子的目的就在于此。</p>\n<p>其中不免需要用到代码生成文件之类的功能，那如何生成呢？</p>\n<p>答案有很多，不过大抵都是通过代码来生成代码，也有一些优秀的开源库和工具，接下来就介绍我们今天的主角<strong>JSONExport</strong>(<a href=\"https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。\" target=\"_blank\" rel=\"noopener\">https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。</a></p>\n<p>它是一款Mac的App,通过Swift语言来编写，需要在网站上下载工程用Xcode编译运行。</p>\n<p>运行后，大致是长这样:</p>\n<p><img src=\"jsonexport.png\" alt></p>\n<p>左边输入JSON，右边生成文件预览，右下角根据选择的语言，通过方法loadSupportedLanguages()来读取本地模版。</p>\n<p>作者在工程中定义了一系列的数据模版来将JSON来映射解析，类似如这样:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  \"langName\": \"名称\", // 模版名称</span><br><span class=\"line\">  \"modelStart\": \"\",</span><br><span class=\"line\">  \"basicTypesWithSpecialFetchingNeedsReplacements\": [], // 类型转换映射</span><br><span class=\"line\">  \"basicTypesWithSpecialStoringNeeds\": [], // 基础类型映射</span><br><span class=\"line\">  \"importForEachCustomType\": \"\", </span><br><span class=\"line\">  \"reservedKeywords\": [], //关键字转换</span><br><span class=\"line\">  \"briefDescription\": \"\", //生成的描述</span><br><span class=\"line\">  \"utilityMethods\": [],</span><br><span class=\"line\">  \"dataTypes\": &#123;&#125;, // 基础类型映射</span><br><span class=\"line\">  \"wordsToRemoveToGetArrayElementsType\": [],</span><br><span class=\"line\">  \"constructors\": [],</span><br><span class=\"line\">  \"constVarDefinition\": \"\",</span><br><span class=\"line\">  \"modelDefinition\": \"\",</span><br><span class=\"line\">  \"genericType\": \"\",</span><br><span class=\"line\">  \"headerFileData\": &#123;</span><br><span class=\"line\">    \"modelDefinitionWithParent\": \"\",</span><br><span class=\"line\">    \"modelEnd\": \"\",</span><br><span class=\"line\">    \"instanceVarDefinition\": \"\",</span><br><span class=\"line\">    \"utilityMethodSignatures\": [],</span><br><span class=\"line\">    \"constructorSignatures\": [],</span><br><span class=\"line\">    \"typesNeedSpecialDefinition\": [],</span><br><span class=\"line\">    \"modelStart\": \"\",</span><br><span class=\"line\">    \"importParentHeaderFile\": \"\",</span><br><span class=\"line\">    \"headerFileExtension\": \"\",</span><br><span class=\"line\">    \"modelDefinition\": \"\",</span><br><span class=\"line\">    \"importForEachCustomType\": \"\",</span><br><span class=\"line\">    \"instanceVarWithSpeicalDefinition\": \"\",</span><br><span class=\"line\">    \"staticImports\": \"#import &lt;UIKit/UIKit.h&gt;\"</span><br><span class=\"line\">  &#125;, // OC头文件</span><br><span class=\"line\">  \"fileExtension\": \"\", // 文件后缀，导出文件拼接用</span><br><span class=\"line\">  \"arrayType\": \"NSArray\",</span><br><span class=\"line\">  \"basicTypesWithSpecialFetchingNeeds\": [],</span><br><span class=\"line\">  \"displayLangName\": \"\", //客户端显示的语言名称,如:Swift,Objective-C</span><br><span class=\"line\">  \"instanceVarDefinition\": \"\",</span><br><span class=\"line\">  \"supportsFirstLineStatement\": \"\",</span><br><span class=\"line\">  \"modelEnd\": \"\",</span><br><span class=\"line\">  \"staticImports\": \"\", // 需要导入的静态包</span><br><span class=\"line\">  \"importHeaderFile\": \"\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>流程大致是这样:</p>\n<p><img src=\"progress.png\" alt></p>\n<p>模版中有需要一些动态插入的部分，如属性名，类名等之类的，用了&lt;!ModelName!&gt;,&lt;!VarName!&gt;作为关键次，在插入字符串过程中，会映射替换JSON的内容。可以看下<strong>SharedConstants.swift</strong>文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let elementType = &quot;&lt;!ElementType!&gt;&quot;</span><br><span class=\"line\">let modelName = &quot;&lt;!ModelName!&gt;&quot;</span><br><span class=\"line\">let modelWithParentClassName = &quot;&lt;!ParentClass!&gt;&quot;</span><br><span class=\"line\">let varName = &quot;&lt;!VarName!&gt;&quot;</span><br><span class=\"line\">let capitalizedVarName = &quot;&lt;!CapitalizedVarName!&gt;&quot;</span><br><span class=\"line\">let varType = &quot;&lt;!VarType!&gt;&quot;</span><br><span class=\"line\">let varTypeReplacement = &quot;&lt;!VarBasicTypeReplacement!&gt;&quot;</span><br><span class=\"line\">let varTypeCast = &quot;&lt;!VarBasicTypeCast!&gt;&quot;</span><br><span class=\"line\">let capitalizedVarType = &quot;&lt;!CapitalizedVarType!&gt;&quot;</span><br><span class=\"line\">let lowerCaseVarType = &quot;&lt;!LowerCaseVarType!&gt;&quot;</span><br><span class=\"line\">let lowerCaseModelName = &quot;&lt;!LowerCaseModelName!&gt;&quot;</span><br><span class=\"line\">let jsonKeyName = &quot;&lt;!JsonKeyName!&gt;&quot;</span><br><span class=\"line\">let constKeyName = &quot;&lt;!ConstKeyName!&gt;&quot;</span><br><span class=\"line\">let additionalCustomTypeProperty = &quot;&lt;!AdditionalForCustomTypeProperty!&gt;&quot;</span><br></pre></td></tr></table></figure>\n<p>在上面的文件中基本是定义了大量关键词，从这里不难看出，其中的属性与JSON的模版文件来进行映射关系的，使插入的内容能够动态去生成。</p>\n<p>在生成字符串的过程中，是逐行逐行来写入文件，就像我们的打印机一样一行一行来输出，用换行符\\n和\\t来进行格式排版的控制,最后替换关键词，这样的思路确实是能够胜任代码生成代码的部分。</p>\n<p>可以知道的是在其中作者用一套解析方式，应用于多个模版，如果生成的文件需要增加的同时，也需要增加一个模版。下面具体来解析一下源码中的代码设计，整个思路大致是这样，但是作者使用的设计模式还是值得学习的。</p>\n<p>是不是现在有点疑惑，各种模型生成的方式不一样Swift,Objective-C,Java，怎么用一套规则去解析生成呢。那么我们就了解下源码中的一些代码设计方式。首先看一下一些类的结构，大致分为三组，也可以定义为三层:</p>\n<ul>\n<li>Supported Languages(模版文件) =&gt; Data层</li>\n<li>Lang Data Models (模版文件模型)  =&gt; Model层</li>\n<li>File content generators （文件生成转化类) =&gt; Service层</li>\n</ul>\n<h5 id=\"Supported-Languages-模版文件-gt-Data层\"><a href=\"#Supported-Languages-模版文件-gt-Data层\" class=\"headerlink\" title=\"Supported Languages(模版文件) =&gt; Data层\"></a>Supported Languages(模版文件) =&gt; Data层</h5><h5 id=\"Lang-Data-Models-模版文件模型-gt-Model层\"><a href=\"#Lang-Data-Models-模版文件模型-gt-Model层\" class=\"headerlink\" title=\"Lang Data Models (模版文件模型)  =&gt; Model层\"></a>Lang Data Models (模版文件模型)  =&gt; Model层</h5><h5 id=\"File-content-generators-（文件生成转化类-gt-Service层\"><a href=\"#File-content-generators-（文件生成转化类-gt-Service层\" class=\"headerlink\" title=\"File content generators （文件生成转化类) =&gt; Service层\"></a>File content generators （文件生成转化类) =&gt; Service层</h5><p>当然还有其他文件生成的方式，如<strong>Sourcery</strong> 框架，但只针对于Swift文件语言写入。利用Swift中xxxxx。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码生成代码——JSONExport解析\"><a href=\"#代码生成代码——JSONExport解析\" class=\"headerlink\" title=\"代码生成代码——JSONExport解析\"></a>代码生成代码——JSONExport解析</h2><p>因为最近想开发一款网路的大礼包，类似Mock API 到Model 的生成，通过一个按钮，或者一行命令去完成，来提高开发效率，节省重复劳动力，毕竟我们开发所有轮子的目的就在于此。</p>\n<p>其中不免需要用到代码生成文件之类的功能，那如何生成呢？</p>\n<p>答案有很多，不过大抵都是通过代码来生成代码，也有一些优秀的开源库和工具，接下来就介绍我们今天的主角<strong>JSONExport</strong>(<a href=\"https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。\" target=\"_blank\" rel=\"noopener\">https://github.com/Ahmed-Ali/JSONExport)，由作者[Ahmed-Ali](https://github.com/Ahmed-Ali)开发提供的优秀开源库。</a></p>\n<p>它是一款Mac的App,通过Swift语言来编写，需要在网站上下载工程用Xcode编译运行。</p>\n<p>运行后，大致是长这样:</p>\n<p><img src=\"jsonexport.png\" alt></p>\n<p>左边输入JSON，右边生成文件预览，右下角根据选择的语言，通过方法loadSupportedLanguages()来读取本地模版。</p>\n<p>作者在工程中定义了一系列的数据模版来将JSON来映射解析，类似如这样:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  \"langName\": \"名称\", // 模版名称</span><br><span class=\"line\">  \"modelStart\": \"\",</span><br><span class=\"line\">  \"basicTypesWithSpecialFetchingNeedsReplacements\": [], // 类型转换映射</span><br><span class=\"line\">  \"basicTypesWithSpecialStoringNeeds\": [], // 基础类型映射</span><br><span class=\"line\">  \"importForEachCustomType\": \"\", </span><br><span class=\"line\">  \"reservedKeywords\": [], //关键字转换</span><br><span class=\"line\">  \"briefDescription\": \"\", //生成的描述</span><br><span class=\"line\">  \"utilityMethods\": [],</span><br><span class=\"line\">  \"dataTypes\": &#123;&#125;, // 基础类型映射</span><br><span class=\"line\">  \"wordsToRemoveToGetArrayElementsType\": [],</span><br><span class=\"line\">  \"constructors\": [],</span><br><span class=\"line\">  \"constVarDefinition\": \"\",</span><br><span class=\"line\">  \"modelDefinition\": \"\",</span><br><span class=\"line\">  \"genericType\": \"\",</span><br><span class=\"line\">  \"headerFileData\": &#123;</span><br><span class=\"line\">    \"modelDefinitionWithParent\": \"\",</span><br><span class=\"line\">    \"modelEnd\": \"\",</span><br><span class=\"line\">    \"instanceVarDefinition\": \"\",</span><br><span class=\"line\">    \"utilityMethodSignatures\": [],</span><br><span class=\"line\">    \"constructorSignatures\": [],</span><br><span class=\"line\">    \"typesNeedSpecialDefinition\": [],</span><br><span class=\"line\">    \"modelStart\": \"\",</span><br><span class=\"line\">    \"importParentHeaderFile\": \"\",</span><br><span class=\"line\">    \"headerFileExtension\": \"\",</span><br><span class=\"line\">    \"modelDefinition\": \"\",</span><br><span class=\"line\">    \"importForEachCustomType\": \"\",</span><br><span class=\"line\">    \"instanceVarWithSpeicalDefinition\": \"\",</span><br><span class=\"line\">    \"staticImports\": \"#import &lt;UIKit/UIKit.h&gt;\"</span><br><span class=\"line\">  &#125;, // OC头文件</span><br><span class=\"line\">  \"fileExtension\": \"\", // 文件后缀，导出文件拼接用</span><br><span class=\"line\">  \"arrayType\": \"NSArray\",</span><br><span class=\"line\">  \"basicTypesWithSpecialFetchingNeeds\": [],</span><br><span class=\"line\">  \"displayLangName\": \"\", //客户端显示的语言名称,如:Swift,Objective-C</span><br><span class=\"line\">  \"instanceVarDefinition\": \"\",</span><br><span class=\"line\">  \"supportsFirstLineStatement\": \"\",</span><br><span class=\"line\">  \"modelEnd\": \"\",</span><br><span class=\"line\">  \"staticImports\": \"\", // 需要导入的静态包</span><br><span class=\"line\">  \"importHeaderFile\": \"\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>流程大致是这样:</p>\n<p><img src=\"progress.png\" alt></p>\n<p>模版中有需要一些动态插入的部分，如属性名，类名等之类的，用了&lt;!ModelName!&gt;,&lt;!VarName!&gt;作为关键次，在插入字符串过程中，会映射替换JSON的内容。可以看下<strong>SharedConstants.swift</strong>文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let elementType = &quot;&lt;!ElementType!&gt;&quot;</span><br><span class=\"line\">let modelName = &quot;&lt;!ModelName!&gt;&quot;</span><br><span class=\"line\">let modelWithParentClassName = &quot;&lt;!ParentClass!&gt;&quot;</span><br><span class=\"line\">let varName = &quot;&lt;!VarName!&gt;&quot;</span><br><span class=\"line\">let capitalizedVarName = &quot;&lt;!CapitalizedVarName!&gt;&quot;</span><br><span class=\"line\">let varType = &quot;&lt;!VarType!&gt;&quot;</span><br><span class=\"line\">let varTypeReplacement = &quot;&lt;!VarBasicTypeReplacement!&gt;&quot;</span><br><span class=\"line\">let varTypeCast = &quot;&lt;!VarBasicTypeCast!&gt;&quot;</span><br><span class=\"line\">let capitalizedVarType = &quot;&lt;!CapitalizedVarType!&gt;&quot;</span><br><span class=\"line\">let lowerCaseVarType = &quot;&lt;!LowerCaseVarType!&gt;&quot;</span><br><span class=\"line\">let lowerCaseModelName = &quot;&lt;!LowerCaseModelName!&gt;&quot;</span><br><span class=\"line\">let jsonKeyName = &quot;&lt;!JsonKeyName!&gt;&quot;</span><br><span class=\"line\">let constKeyName = &quot;&lt;!ConstKeyName!&gt;&quot;</span><br><span class=\"line\">let additionalCustomTypeProperty = &quot;&lt;!AdditionalForCustomTypeProperty!&gt;&quot;</span><br></pre></td></tr></table></figure>\n<p>在上面的文件中基本是定义了大量关键词，从这里不难看出，其中的属性与JSON的模版文件来进行映射关系的，使插入的内容能够动态去生成。</p>\n<p>在生成字符串的过程中，是逐行逐行来写入文件，就像我们的打印机一样一行一行来输出，用换行符\\n和\\t来进行格式排版的控制,最后替换关键词，这样的思路确实是能够胜任代码生成代码的部分。</p>\n<p>可以知道的是在其中作者用一套解析方式，应用于多个模版，如果生成的文件需要增加的同时，也需要增加一个模版。下面具体来解析一下源码中的代码设计，整个思路大致是这样，但是作者使用的设计模式还是值得学习的。</p>\n<p>是不是现在有点疑惑，各种模型生成的方式不一样Swift,Objective-C,Java，怎么用一套规则去解析生成呢。那么我们就了解下源码中的一些代码设计方式。首先看一下一些类的结构，大致分为三组，也可以定义为三层:</p>\n<ul>\n<li>Supported Languages(模版文件) =&gt; Data层</li>\n<li>Lang Data Models (模版文件模型)  =&gt; Model层</li>\n<li>File content generators （文件生成转化类) =&gt; Service层</li>\n</ul>\n<h5 id=\"Supported-Languages-模版文件-gt-Data层\"><a href=\"#Supported-Languages-模版文件-gt-Data层\" class=\"headerlink\" title=\"Supported Languages(模版文件) =&gt; Data层\"></a>Supported Languages(模版文件) =&gt; Data层</h5><h5 id=\"Lang-Data-Models-模版文件模型-gt-Model层\"><a href=\"#Lang-Data-Models-模版文件模型-gt-Model层\" class=\"headerlink\" title=\"Lang Data Models (模版文件模型)  =&gt; Model层\"></a>Lang Data Models (模版文件模型)  =&gt; Model层</h5><h5 id=\"File-content-generators-（文件生成转化类-gt-Service层\"><a href=\"#File-content-generators-（文件生成转化类-gt-Service层\" class=\"headerlink\" title=\"File content generators （文件生成转化类) =&gt; Service层\"></a>File content generators （文件生成转化类) =&gt; Service层</h5><p>当然还有其他文件生成的方式，如<strong>Sourcery</strong> 框架，但只针对于Swift文件语言写入。利用Swift中xxxxx。</p>\n"},{"title":"UIWebView与WKWebView","date":"2016-08-09T03:32:33.000Z","_content":"# UIWebView\nUIWebView是苹果继承于UIView封装的一个加载web内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在iOS8以后推出了WKWebView来加载Web，下面再详细介绍下WKWebView。\n\nUIWebView属于UIKit，封装了WebKit.framework的WebView.\n\nWebView组合管理了WebCore.framework的Page,并提供了各种Clients.\n\nPage管理了Main Frame，Main Frame管理了sub Frame（FrameTree)\n[关于详细的UIWebView介绍转自这里](http://blog.csdn.net/hursing)\n<img src=\"/img/webview.png\"  title=\"webview层级\">\nWebView继承自WAKView,WAKView类似于NSView，可以做较少的改动使得Mac和iOS共用一套。由UIWebDocumentView对WebView进行操作并接收回调事件，当数据发生变化的时候，就会通知UIWebTiledView重新绘制。\n\nUIWebTiledView和WAKWindow这两个类主要负责页面的绘制，包括布局绘图排版，交互等,WAKWindow还会做一些用户操作事件的分派。\n\nUIWebBrowserView主要负责\n* form的自动填充\n* fixed元素的位置调整\n* JavaScript的手势识别\n* 键盘弹出时的视图滚动处理，防止遮挡\n* 提供接口让UIWebView获取信息\n* 为显示PDF时添加页号标签\n通过反编译可以获得UIWebViewInternal的具体成员变量\n``` obj-c\n@interface UIWebViewInternal : NSObject  \n{  \n    UIScrollView *scroller;  \n    UIWebBrowserView *browserView;  \n    UICheckeredPatternView *checkeredPatternView;  \n    id <UIWebViewDelegate> delegate;  \n    unsigned int scalesPageToFit;  \n    unsigned int isLoading;  \n    unsigned int hasOverriddenOrientationChangeEventHandling;  \n    unsigned int drawsCheckeredPattern;  \n    unsigned int webSelectionEnabled;  \n    unsigned int drawInWebThread;  \n    unsigned int inRotation;  \n    NSURLRequest *request;  \n    int clickedAlertButtonIndex;  \n    UIWebViewWebViewDelegate *webViewDelegate;  \n    UIWebPDFViewHandler *pdfHandler;  \n} \n@end \n```\n由此可以看出UIWebViewInternal是接收WebView的事件的载体通过自身把WebView的事件传递给UIWebView.\n\n# WKWebView\n通过上面的了解，苹果终于在8.0之后开放了WKWebView应用于iOS和OSX中，它取代了UIWebView和WebView，在两个平台上支持同一套API。\n它脱离于UIWebView的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。\n\n## WKWebView相比于UIWebView\n* WKWebView的内存远远没有UIWebView的开销大,而且没有缓存\n* 拥有高达60FPS滚动刷新率及内置手势\n* 支持了更多的HTML5特性\n* 高效的app和web信息交换通道\n* 允许JavaScript的Nitro库加载并使用,UIWebView中限制了\n* WKWebView目前缺少关于页码相关的API\n* 提供加载网页进度的属性\n\n## WKWebView的协议\n### WKScriptMessageHandler协议\n``` javascript\nwindow.webkit.messageHandlers.{NAME}.postMessage()\n```\n可以把JavaScript对象通过该API自动转换成Objective-C或Swift 对象,Name可以通过addScriptMessageHandler: name:来设置\n``` obj-c\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{\n}\n```\n作为唯一响应JavaScript的协议方法，目的是为了与其它的进行分离，在该协议中响应之前注入的MessageHandlers.\n可以根据WKScriptMessage知道Js的名称和参数，来区分不同的响应事件\n### WKNavigationDelegate协议\n提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法,相当于UIWebView中webViewDidFinishLoad和webViewDidStartLoad方法,除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：\n``` obj-c\n- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;\n\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;\n\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;\n```\n第一个是服务器redirect时调用\n第二个API是根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转\n第三个API是根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转\n## WKUIDelegate协议\n提供用原生控件显示网页的方法回调,例如Alert提示可以自定义用原生的控件来实现\n``` obj-c\n- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:message preferredStyle:UIAlertControllerStyleAlert];\n    [alert addAction:[UIAlertAction actionWithTitle:@\"确定\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {\n        completionHandler();\n    }]];\n    [self presentViewController:alert animated:YES completion:NULL];\n}\n```\n# 总结\nWKWebView相较于UIWebView在整体上有较大的提升，满足OS上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和JS交互做了优化的处理。依据职责单一的原则，拆分成了三个协议去实现WebView的响应，解耦了JS交互和加载进度的响应处理。WKWebView没有做缓存处理,所以对网页需要缓存的加载性能要求没那么高的还是可以考虑UIWebView.\n","source":"_posts/UIWebView与WKWebView.md","raw":"---\ntitle: UIWebView与WKWebView\ncategories: 小知识 #分类\ndate: 2016-08-09 11:32:33\ntags:\n---\n# UIWebView\nUIWebView是苹果继承于UIView封装的一个加载web内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在iOS8以后推出了WKWebView来加载Web，下面再详细介绍下WKWebView。\n\nUIWebView属于UIKit，封装了WebKit.framework的WebView.\n\nWebView组合管理了WebCore.framework的Page,并提供了各种Clients.\n\nPage管理了Main Frame，Main Frame管理了sub Frame（FrameTree)\n[关于详细的UIWebView介绍转自这里](http://blog.csdn.net/hursing)\n<img src=\"/img/webview.png\"  title=\"webview层级\">\nWebView继承自WAKView,WAKView类似于NSView，可以做较少的改动使得Mac和iOS共用一套。由UIWebDocumentView对WebView进行操作并接收回调事件，当数据发生变化的时候，就会通知UIWebTiledView重新绘制。\n\nUIWebTiledView和WAKWindow这两个类主要负责页面的绘制，包括布局绘图排版，交互等,WAKWindow还会做一些用户操作事件的分派。\n\nUIWebBrowserView主要负责\n* form的自动填充\n* fixed元素的位置调整\n* JavaScript的手势识别\n* 键盘弹出时的视图滚动处理，防止遮挡\n* 提供接口让UIWebView获取信息\n* 为显示PDF时添加页号标签\n通过反编译可以获得UIWebViewInternal的具体成员变量\n``` obj-c\n@interface UIWebViewInternal : NSObject  \n{  \n    UIScrollView *scroller;  \n    UIWebBrowserView *browserView;  \n    UICheckeredPatternView *checkeredPatternView;  \n    id <UIWebViewDelegate> delegate;  \n    unsigned int scalesPageToFit;  \n    unsigned int isLoading;  \n    unsigned int hasOverriddenOrientationChangeEventHandling;  \n    unsigned int drawsCheckeredPattern;  \n    unsigned int webSelectionEnabled;  \n    unsigned int drawInWebThread;  \n    unsigned int inRotation;  \n    NSURLRequest *request;  \n    int clickedAlertButtonIndex;  \n    UIWebViewWebViewDelegate *webViewDelegate;  \n    UIWebPDFViewHandler *pdfHandler;  \n} \n@end \n```\n由此可以看出UIWebViewInternal是接收WebView的事件的载体通过自身把WebView的事件传递给UIWebView.\n\n# WKWebView\n通过上面的了解，苹果终于在8.0之后开放了WKWebView应用于iOS和OSX中，它取代了UIWebView和WebView，在两个平台上支持同一套API。\n它脱离于UIWebView的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。\n\n## WKWebView相比于UIWebView\n* WKWebView的内存远远没有UIWebView的开销大,而且没有缓存\n* 拥有高达60FPS滚动刷新率及内置手势\n* 支持了更多的HTML5特性\n* 高效的app和web信息交换通道\n* 允许JavaScript的Nitro库加载并使用,UIWebView中限制了\n* WKWebView目前缺少关于页码相关的API\n* 提供加载网页进度的属性\n\n## WKWebView的协议\n### WKScriptMessageHandler协议\n``` javascript\nwindow.webkit.messageHandlers.{NAME}.postMessage()\n```\n可以把JavaScript对象通过该API自动转换成Objective-C或Swift 对象,Name可以通过addScriptMessageHandler: name:来设置\n``` obj-c\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{\n}\n```\n作为唯一响应JavaScript的协议方法，目的是为了与其它的进行分离，在该协议中响应之前注入的MessageHandlers.\n可以根据WKScriptMessage知道Js的名称和参数，来区分不同的响应事件\n### WKNavigationDelegate协议\n提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法,相当于UIWebView中webViewDidFinishLoad和webViewDidStartLoad方法,除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：\n``` obj-c\n- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;\n\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;\n\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;\n```\n第一个是服务器redirect时调用\n第二个API是根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转\n第三个API是根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转\n## WKUIDelegate协议\n提供用原生控件显示网页的方法回调,例如Alert提示可以自定义用原生的控件来实现\n``` obj-c\n- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:message preferredStyle:UIAlertControllerStyleAlert];\n    [alert addAction:[UIAlertAction actionWithTitle:@\"确定\" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {\n        completionHandler();\n    }]];\n    [self presentViewController:alert animated:YES completion:NULL];\n}\n```\n# 总结\nWKWebView相较于UIWebView在整体上有较大的提升，满足OS上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和JS交互做了优化的处理。依据职责单一的原则，拆分成了三个协议去实现WebView的响应，解耦了JS交互和加载进度的响应处理。WKWebView没有做缓存处理,所以对网页需要缓存的加载性能要求没那么高的还是可以考虑UIWebView.\n","slug":"UIWebView与WKWebView","published":1,"updated":"2016-08-24T01:37:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84p500084x2no32lovb0","content":"<h1 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h1><p>UIWebView是苹果继承于UIView封装的一个加载web内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在iOS8以后推出了WKWebView来加载Web，下面再详细介绍下WKWebView。</p>\n<p>UIWebView属于UIKit，封装了WebKit.framework的WebView.</p>\n<p>WebView组合管理了WebCore.framework的Page,并提供了各种Clients.</p>\n<p>Page管理了Main Frame，Main Frame管理了sub Frame（FrameTree)<br><a href=\"http://blog.csdn.net/hursing\" target=\"_blank\" rel=\"noopener\">关于详细的UIWebView介绍转自这里</a><br><img src=\"/img/webview.png\" title=\"webview层级\"><br>WebView继承自WAKView,WAKView类似于NSView，可以做较少的改动使得Mac和iOS共用一套。由UIWebDocumentView对WebView进行操作并接收回调事件，当数据发生变化的时候，就会通知UIWebTiledView重新绘制。</p>\n<p>UIWebTiledView和WAKWindow这两个类主要负责页面的绘制，包括布局绘图排版，交互等,WAKWindow还会做一些用户操作事件的分派。</p>\n<p>UIWebBrowserView主要负责</p>\n<ul>\n<li>form的自动填充</li>\n<li>fixed元素的位置调整</li>\n<li>JavaScript的手势识别</li>\n<li>键盘弹出时的视图滚动处理，防止遮挡</li>\n<li>提供接口让UIWebView获取信息</li>\n<li>为显示PDF时添加页号标签<br>通过反编译可以获得UIWebViewInternal的具体成员变量<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIWebViewInternal</span> : <span class=\"title\">NSObject</span>  </span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UIScrollView</span> *scroller;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebBrowserView</span> *browserView;  </span><br><span class=\"line\">    <span class=\"built_in\">UICheckeredPatternView</span> *checkeredPatternView;  </span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIWebViewDelegate</span>&gt; delegate;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> scalesPageToFit;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> isLoading;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hasOverriddenOrientationChangeEventHandling;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drawsCheckeredPattern;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> webSelectionEnabled;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drawInWebThread;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> inRotation;  </span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span> *request;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> clickedAlertButtonIndex;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebViewWebViewDelegate</span> *webViewDelegate;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebPDFViewHandler</span> *pdfHandler;  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由此可以看出UIWebViewInternal是接收WebView的事件的载体通过自身把WebView的事件传递给UIWebView.</p>\n<h1 id=\"WKWebView\"><a href=\"#WKWebView\" class=\"headerlink\" title=\"WKWebView\"></a>WKWebView</h1><p>通过上面的了解，苹果终于在8.0之后开放了WKWebView应用于iOS和OSX中，它取代了UIWebView和WebView，在两个平台上支持同一套API。<br>它脱离于UIWebView的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。</p>\n<h2 id=\"WKWebView相比于UIWebView\"><a href=\"#WKWebView相比于UIWebView\" class=\"headerlink\" title=\"WKWebView相比于UIWebView\"></a>WKWebView相比于UIWebView</h2><ul>\n<li>WKWebView的内存远远没有UIWebView的开销大,而且没有缓存</li>\n<li>拥有高达60FPS滚动刷新率及内置手势</li>\n<li>支持了更多的HTML5特性</li>\n<li>高效的app和web信息交换通道</li>\n<li>允许JavaScript的Nitro库加载并使用,UIWebView中限制了</li>\n<li>WKWebView目前缺少关于页码相关的API</li>\n<li>提供加载网页进度的属性</li>\n</ul>\n<h2 id=\"WKWebView的协议\"><a href=\"#WKWebView的协议\" class=\"headerlink\" title=\"WKWebView的协议\"></a>WKWebView的协议</h2><h3 id=\"WKScriptMessageHandler协议\"><a href=\"#WKScriptMessageHandler协议\" class=\"headerlink\" title=\"WKScriptMessageHandler协议\"></a>WKScriptMessageHandler协议</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.&#123;NAME&#125;.postMessage()</span><br></pre></td></tr></table></figure>\n<p>可以把JavaScript对象通过该API自动转换成Objective-C或Swift 对象,Name可以通过addScriptMessageHandler: name:来设置<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>作为唯一响应JavaScript的协议方法，目的是为了与其它的进行分离，在该协议中响应之前注入的MessageHandlers.<br>可以根据WKScriptMessage知道Js的名称和参数，来区分不同的响应事件</p>\n<h3 id=\"WKNavigationDelegate协议\"><a href=\"#WKNavigationDelegate协议\" class=\"headerlink\" title=\"WKNavigationDelegate协议\"></a>WKNavigationDelegate协议</h3><p>提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法,相当于UIWebView中webViewDidFinishLoad和webViewDidStartLoad方法,除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> *)navigation;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class=\"built_in\">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationResponsePolicy</span>))decisionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure></p>\n<p>第一个是服务器redirect时调用<br>第二个API是根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转<br>第三个API是根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转</p>\n<h2 id=\"WKUIDelegate协议\"><a href=\"#WKUIDelegate协议\" class=\"headerlink\" title=\"WKUIDelegate协议\"></a>WKUIDelegate协议</h2><p>提供用原生控件显示网页的方法回调,例如Alert提示可以自定义用原生的控件来实现<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class=\"built_in\">NSString</span> *)message initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> *)frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))completionHandler &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertController</span> *alert = [<span class=\"built_in\">UIAlertController</span> alertControllerWithTitle:<span class=\"literal\">nil</span> message:message preferredStyle:<span class=\"built_in\">UIAlertControllerStyleAlert</span>];</span><br><span class=\"line\">    [alert addAction:[<span class=\"built_in\">UIAlertAction</span> actionWithTitle:<span class=\"string\">@\"确定\"</span> style:<span class=\"built_in\">UIAlertActionStyleDefault</span> handler:^(<span class=\"built_in\">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:alert animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>WKWebView相较于UIWebView在整体上有较大的提升，满足OS上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和JS交互做了优化的处理。依据职责单一的原则，拆分成了三个协议去实现WebView的响应，解耦了JS交互和加载进度的响应处理。WKWebView没有做缓存处理,所以对网页需要缓存的加载性能要求没那么高的还是可以考虑UIWebView.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h1><p>UIWebView是苹果继承于UIView封装的一个加载web内容的类,它可以加载任何远端的web数据展示在你的页面上，你可以像浏览器一样前进后退刷新等操作。不过苹果在iOS8以后推出了WKWebView来加载Web，下面再详细介绍下WKWebView。</p>\n<p>UIWebView属于UIKit，封装了WebKit.framework的WebView.</p>\n<p>WebView组合管理了WebCore.framework的Page,并提供了各种Clients.</p>\n<p>Page管理了Main Frame，Main Frame管理了sub Frame（FrameTree)<br><a href=\"http://blog.csdn.net/hursing\" target=\"_blank\" rel=\"noopener\">关于详细的UIWebView介绍转自这里</a><br><img src=\"/img/webview.png\" title=\"webview层级\"><br>WebView继承自WAKView,WAKView类似于NSView，可以做较少的改动使得Mac和iOS共用一套。由UIWebDocumentView对WebView进行操作并接收回调事件，当数据发生变化的时候，就会通知UIWebTiledView重新绘制。</p>\n<p>UIWebTiledView和WAKWindow这两个类主要负责页面的绘制，包括布局绘图排版，交互等,WAKWindow还会做一些用户操作事件的分派。</p>\n<p>UIWebBrowserView主要负责</p>\n<ul>\n<li>form的自动填充</li>\n<li>fixed元素的位置调整</li>\n<li>JavaScript的手势识别</li>\n<li>键盘弹出时的视图滚动处理，防止遮挡</li>\n<li>提供接口让UIWebView获取信息</li>\n<li>为显示PDF时添加页号标签<br>通过反编译可以获得UIWebViewInternal的具体成员变量<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIWebViewInternal</span> : <span class=\"title\">NSObject</span>  </span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">UIScrollView</span> *scroller;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebBrowserView</span> *browserView;  </span><br><span class=\"line\">    <span class=\"built_in\">UICheckeredPatternView</span> *checkeredPatternView;  </span><br><span class=\"line\">    <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIWebViewDelegate</span>&gt; delegate;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> scalesPageToFit;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> isLoading;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hasOverriddenOrientationChangeEventHandling;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drawsCheckeredPattern;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> webSelectionEnabled;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> drawInWebThread;  </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> inRotation;  </span><br><span class=\"line\">    <span class=\"built_in\">NSURLRequest</span> *request;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> clickedAlertButtonIndex;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebViewWebViewDelegate</span> *webViewDelegate;  </span><br><span class=\"line\">    <span class=\"built_in\">UIWebPDFViewHandler</span> *pdfHandler;  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由此可以看出UIWebViewInternal是接收WebView的事件的载体通过自身把WebView的事件传递给UIWebView.</p>\n<h1 id=\"WKWebView\"><a href=\"#WKWebView\" class=\"headerlink\" title=\"WKWebView\"></a>WKWebView</h1><p>通过上面的了解，苹果终于在8.0之后开放了WKWebView应用于iOS和OSX中，它取代了UIWebView和WebView，在两个平台上支持同一套API。<br>它脱离于UIWebView的设计，将原本的设计拆分成14个类，和3个代理协议，虽然是这样但是了解之后其实用法比较简单，依照职责单一的原则，每个协议做的事情根据功能分类。</p>\n<h2 id=\"WKWebView相比于UIWebView\"><a href=\"#WKWebView相比于UIWebView\" class=\"headerlink\" title=\"WKWebView相比于UIWebView\"></a>WKWebView相比于UIWebView</h2><ul>\n<li>WKWebView的内存远远没有UIWebView的开销大,而且没有缓存</li>\n<li>拥有高达60FPS滚动刷新率及内置手势</li>\n<li>支持了更多的HTML5特性</li>\n<li>高效的app和web信息交换通道</li>\n<li>允许JavaScript的Nitro库加载并使用,UIWebView中限制了</li>\n<li>WKWebView目前缺少关于页码相关的API</li>\n<li>提供加载网页进度的属性</li>\n</ul>\n<h2 id=\"WKWebView的协议\"><a href=\"#WKWebView的协议\" class=\"headerlink\" title=\"WKWebView的协议\"></a>WKWebView的协议</h2><h3 id=\"WKScriptMessageHandler协议\"><a href=\"#WKScriptMessageHandler协议\" class=\"headerlink\" title=\"WKScriptMessageHandler协议\"></a>WKScriptMessageHandler协议</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.&#123;NAME&#125;.postMessage()</span><br></pre></td></tr></table></figure>\n<p>可以把JavaScript对象通过该API自动转换成Objective-C或Swift 对象,Name可以通过addScriptMessageHandler: name:来设置<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>作为唯一响应JavaScript的协议方法，目的是为了与其它的进行分离，在该协议中响应之前注入的MessageHandlers.<br>可以根据WKScriptMessage知道Js的名称和参数，来区分不同的响应事件</p>\n<h3 id=\"WKNavigationDelegate协议\"><a href=\"#WKNavigationDelegate协议\" class=\"headerlink\" title=\"WKNavigationDelegate协议\"></a>WKNavigationDelegate协议</h3><p>提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法,相当于UIWebView中webViewDidFinishLoad和webViewDidStartLoad方法,除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> *)navigation;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class=\"built_in\">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationResponsePolicy</span>))decisionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure></p>\n<p>第一个是服务器redirect时调用<br>第二个API是根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转<br>第三个API是根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转</p>\n<h2 id=\"WKUIDelegate协议\"><a href=\"#WKUIDelegate协议\" class=\"headerlink\" title=\"WKUIDelegate协议\"></a>WKUIDelegate协议</h2><p>提供用原生控件显示网页的方法回调,例如Alert提示可以自定义用原生的控件来实现<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class=\"built_in\">NSString</span> *)message initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> *)frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))completionHandler &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIAlertController</span> *alert = [<span class=\"built_in\">UIAlertController</span> alertControllerWithTitle:<span class=\"literal\">nil</span> message:message preferredStyle:<span class=\"built_in\">UIAlertControllerStyleAlert</span>];</span><br><span class=\"line\">    [alert addAction:[<span class=\"built_in\">UIAlertAction</span> actionWithTitle:<span class=\"string\">@\"确定\"</span> style:<span class=\"built_in\">UIAlertActionStyleDefault</span> handler:^(<span class=\"built_in\">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:alert animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>WKWebView相较于UIWebView在整体上有较大的提升，满足OS上面使用同一套控件的功能，同时对整个内存的开销以及滚动刷新率和JS交互做了优化的处理。依据职责单一的原则，拆分成了三个协议去实现WebView的响应，解耦了JS交互和加载进度的响应处理。WKWebView没有做缓存处理,所以对网页需要缓存的加载性能要求没那么高的还是可以考虑UIWebView.</p>\n"},{"title":"Method Swizzling 理解","date":"2016-08-01T06:48:38.000Z","_content":"\n# Method Swizzling\n顾名思义方法交换,这是一种利用了runtime机制，在运行时通过修改类分发表中slector对应的函数来修改函数的实现。该机制的用途可以是在某些场景下，比如:我们需要在当前的工程中，每一个同样的方法中做埋点（在日志追踪系统中会在一些指定的地方发送一些数据），但不影响本身方法的实现，在其具体实现中并不掺入任何埋点相关的代码。或者监听哪些方法被调用多少次，我是在一次检测内存中对方法交换产生了兴趣,于是手撸了一遍代码。\n\n# Method Swizzling 的实现\nMattt Thompson写过一篇Method Swizzling的[Blog](https://github.com/chausson/CHAnimationDemo)里面实现了一套标准交换方法的代码实现\n\n``` obj-c\n#import <objc/runtime.h>\n\n@implementation UIViewController (Tracking)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        // When swizzling a class method, use the following:\n        // Class class = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(class, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);\n\n        BOOL didAddMethod =\n            class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n\n        if (didAddMethod) {\n            class_replaceMethod(class,\n                swizzledSelector,\n                method_getImplementation(originalMethod),\n                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n#pragma mark - Method Swizzling\n\n- (void)xxx_viewWillAppear:(BOOL)animated {\n    [self xxx_viewWillAppear:animated];\n    NSLog(@\"viewWillAppear: %@\", self);\n}\n\n@end\n```\n首先我们先来看\n``` obj-c\nMethod class_getInstanceMethod(Class aClass, SEL aSelector)\nMethod originalMethod = class_getClassMethod(class, originalSelector);\nBOOL didAddMethod =\n            class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n            class_replaceMethod(class,\n                            swizzledSEL,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n```\n1.class_getInstanceMethod这个官方解释是说会从父类中找到对象方法的实现，但不会从class_copyMethodList里面去找，如果找到则返回该实现方法，没有的话则会返回NULL。\n\n2.class_getClassMethod则是从类的方法中去寻找。\n\n3.class_addMethod则会为该类添加一个方法，但不会去重写已有实现的方法，如果已经有相同方法名称则会返回NO添加失败。\n\n4.class_replaceMethod的话看名称就知道这个是为替换方法开的接口，如果方法不存在则会先调用method_setImplementation。\n\n# Method Swizzling 总结\n该机制是利用了运行时的特性，使用的时候请注意避免一些坑\n1.不要在替换方法中实现类的原有方法，这样会形成死循环。\n2.所有替换的方法必须加一些前缀用来区别替换的方法。\n3.不调用苹果提供的方法实现，可能会影响到程序的其他部分。\n\n# Github Demo\n[Method Swizzling Demo](https://github.com/chausson/MethodSwizzlingDemo)\n","source":"_posts/Method Swizzling理解.md","raw":"---\ntitle: Method Swizzling 理解\ndate: 2016-08-01 14:48:38\ntags:\ncategories: 小知识 #分类\n---\n\n# Method Swizzling\n顾名思义方法交换,这是一种利用了runtime机制，在运行时通过修改类分发表中slector对应的函数来修改函数的实现。该机制的用途可以是在某些场景下，比如:我们需要在当前的工程中，每一个同样的方法中做埋点（在日志追踪系统中会在一些指定的地方发送一些数据），但不影响本身方法的实现，在其具体实现中并不掺入任何埋点相关的代码。或者监听哪些方法被调用多少次，我是在一次检测内存中对方法交换产生了兴趣,于是手撸了一遍代码。\n\n# Method Swizzling 的实现\nMattt Thompson写过一篇Method Swizzling的[Blog](https://github.com/chausson/CHAnimationDemo)里面实现了一套标准交换方法的代码实现\n\n``` obj-c\n#import <objc/runtime.h>\n\n@implementation UIViewController (Tracking)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];\n\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n\n        // When swizzling a class method, use the following:\n        // Class class = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(class, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);\n\n        BOOL didAddMethod =\n            class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n\n        if (didAddMethod) {\n            class_replaceMethod(class,\n                swizzledSelector,\n                method_getImplementation(originalMethod),\n                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n#pragma mark - Method Swizzling\n\n- (void)xxx_viewWillAppear:(BOOL)animated {\n    [self xxx_viewWillAppear:animated];\n    NSLog(@\"viewWillAppear: %@\", self);\n}\n\n@end\n```\n首先我们先来看\n``` obj-c\nMethod class_getInstanceMethod(Class aClass, SEL aSelector)\nMethod originalMethod = class_getClassMethod(class, originalSelector);\nBOOL didAddMethod =\n            class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n            class_replaceMethod(class,\n                            swizzledSEL,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n```\n1.class_getInstanceMethod这个官方解释是说会从父类中找到对象方法的实现，但不会从class_copyMethodList里面去找，如果找到则返回该实现方法，没有的话则会返回NULL。\n\n2.class_getClassMethod则是从类的方法中去寻找。\n\n3.class_addMethod则会为该类添加一个方法，但不会去重写已有实现的方法，如果已经有相同方法名称则会返回NO添加失败。\n\n4.class_replaceMethod的话看名称就知道这个是为替换方法开的接口，如果方法不存在则会先调用method_setImplementation。\n\n# Method Swizzling 总结\n该机制是利用了运行时的特性，使用的时候请注意避免一些坑\n1.不要在替换方法中实现类的原有方法，这样会形成死循环。\n2.所有替换的方法必须加一些前缀用来区别替换的方法。\n3.不调用苹果提供的方法实现，可能会影响到程序的其他部分。\n\n# Github Demo\n[Method Swizzling Demo](https://github.com/chausson/MethodSwizzlingDemo)\n","slug":"Method Swizzling理解","published":1,"updated":"2016-08-10T02:20:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84p800094x2nwsyd6wh3","content":"<h1 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h1><p>顾名思义方法交换,这是一种利用了runtime机制，在运行时通过修改类分发表中slector对应的函数来修改函数的实现。该机制的用途可以是在某些场景下，比如:我们需要在当前的工程中，每一个同样的方法中做埋点（在日志追踪系统中会在一些指定的地方发送一些数据），但不影响本身方法的实现，在其具体实现中并不掺入任何埋点相关的代码。或者监听哪些方法被调用多少次，我是在一次检测内存中对方法交换产生了兴趣,于是手撸了一遍代码。</p>\n<h1 id=\"Method-Swizzling-的实现\"><a href=\"#Method-Swizzling-的实现\" class=\"headerlink\" title=\"Method Swizzling 的实现\"></a>Method Swizzling 的实现</h1><p>Mattt Thompson写过一篇Method Swizzling的<a href=\"https://github.com/chausson/CHAnimationDemo\" target=\"_blank\" rel=\"noopener\">Blog</a>里面实现了一套标准交换方法的代码实现</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class <span class=\"keyword\">class</span> = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>, swizzledSelector);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></span><br><span class=\"line\">        <span class=\"comment\">// Class class = object_getClass((id)self);</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(class, originalSelector);</span></span><br><span class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod =</span><br><span class=\"line\">            class_addMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                originalSelector,</span><br><span class=\"line\">                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                swizzledSelector,</span><br><span class=\"line\">                method_getImplementation(originalMethod),</span><br><span class=\"line\">                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>首先我们先来看<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br><span class=\"line\">Method originalMethod = class_getClassMethod(<span class=\"keyword\">class</span>, originalSelector);</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod =</span><br><span class=\"line\">            class_addMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                originalSelector,</span><br><span class=\"line\">                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                            swizzledSEL,</span><br><span class=\"line\">                            method_getImplementation(originalMethod),</span><br><span class=\"line\">                            method_getTypeEncoding(originalMethod));</span><br></pre></td></tr></table></figure></p>\n<p>1.class_getInstanceMethod这个官方解释是说会从父类中找到对象方法的实现，但不会从class_copyMethodList里面去找，如果找到则返回该实现方法，没有的话则会返回NULL。</p>\n<p>2.class_getClassMethod则是从类的方法中去寻找。</p>\n<p>3.class_addMethod则会为该类添加一个方法，但不会去重写已有实现的方法，如果已经有相同方法名称则会返回NO添加失败。</p>\n<p>4.class_replaceMethod的话看名称就知道这个是为替换方法开的接口，如果方法不存在则会先调用method_setImplementation。</p>\n<h1 id=\"Method-Swizzling-总结\"><a href=\"#Method-Swizzling-总结\" class=\"headerlink\" title=\"Method Swizzling 总结\"></a>Method Swizzling 总结</h1><p>该机制是利用了运行时的特性，使用的时候请注意避免一些坑<br>1.不要在替换方法中实现类的原有方法，这样会形成死循环。<br>2.所有替换的方法必须加一些前缀用来区别替换的方法。<br>3.不调用苹果提供的方法实现，可能会影响到程序的其他部分。</p>\n<h1 id=\"Github-Demo\"><a href=\"#Github-Demo\" class=\"headerlink\" title=\"Github Demo\"></a>Github Demo</h1><p><a href=\"https://github.com/chausson/MethodSwizzlingDemo\" target=\"_blank\" rel=\"noopener\">Method Swizzling Demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h1><p>顾名思义方法交换,这是一种利用了runtime机制，在运行时通过修改类分发表中slector对应的函数来修改函数的实现。该机制的用途可以是在某些场景下，比如:我们需要在当前的工程中，每一个同样的方法中做埋点（在日志追踪系统中会在一些指定的地方发送一些数据），但不影响本身方法的实现，在其具体实现中并不掺入任何埋点相关的代码。或者监听哪些方法被调用多少次，我是在一次检测内存中对方法交换产生了兴趣,于是手撸了一遍代码。</p>\n<h1 id=\"Method-Swizzling-的实现\"><a href=\"#Method-Swizzling-的实现\" class=\"headerlink\" title=\"Method Swizzling 的实现\"></a>Method Swizzling 的实现</h1><p>Mattt Thompson写过一篇Method Swizzling的<a href=\"https://github.com/chausson/CHAnimationDemo\" target=\"_blank\" rel=\"noopener\">Blog</a>里面实现了一套标准交换方法的代码实现</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class <span class=\"keyword\">class</span> = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:);</span><br><span class=\"line\"></span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">class</span>, swizzledSelector);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></span><br><span class=\"line\">        <span class=\"comment\">// Class class = object_getClass((id)self);</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(class, originalSelector);</span></span><br><span class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod =</span><br><span class=\"line\">            class_addMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                originalSelector,</span><br><span class=\"line\">                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                swizzledSelector,</span><br><span class=\"line\">                method_getImplementation(originalMethod),</span><br><span class=\"line\">                method_getTypeEncoding(originalMethod));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>首先我们先来看<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br><span class=\"line\">Method originalMethod = class_getClassMethod(<span class=\"keyword\">class</span>, originalSelector);</span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod =</span><br><span class=\"line\">            class_addMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                originalSelector,</span><br><span class=\"line\">                method_getImplementation(swizzledMethod),</span><br><span class=\"line\">                method_getTypeEncoding(swizzledMethod));</span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">class</span>,</span><br><span class=\"line\">                            swizzledSEL,</span><br><span class=\"line\">                            method_getImplementation(originalMethod),</span><br><span class=\"line\">                            method_getTypeEncoding(originalMethod));</span><br></pre></td></tr></table></figure></p>\n<p>1.class_getInstanceMethod这个官方解释是说会从父类中找到对象方法的实现，但不会从class_copyMethodList里面去找，如果找到则返回该实现方法，没有的话则会返回NULL。</p>\n<p>2.class_getClassMethod则是从类的方法中去寻找。</p>\n<p>3.class_addMethod则会为该类添加一个方法，但不会去重写已有实现的方法，如果已经有相同方法名称则会返回NO添加失败。</p>\n<p>4.class_replaceMethod的话看名称就知道这个是为替换方法开的接口，如果方法不存在则会先调用method_setImplementation。</p>\n<h1 id=\"Method-Swizzling-总结\"><a href=\"#Method-Swizzling-总结\" class=\"headerlink\" title=\"Method Swizzling 总结\"></a>Method Swizzling 总结</h1><p>该机制是利用了运行时的特性，使用的时候请注意避免一些坑<br>1.不要在替换方法中实现类的原有方法，这样会形成死循环。<br>2.所有替换的方法必须加一些前缀用来区别替换的方法。<br>3.不调用苹果提供的方法实现，可能会影响到程序的其他部分。</p>\n<h1 id=\"Github-Demo\"><a href=\"#Github-Demo\" class=\"headerlink\" title=\"Github Demo\"></a>Github Demo</h1><p><a href=\"https://github.com/chausson/MethodSwizzlingDemo\" target=\"_blank\" rel=\"noopener\">Method Swizzling Demo</a></p>\n"},{"title":"代码Review系列(1)——CSChat聊天组件","date":"2016-06-28T08:05:08.000Z","_content":"\n## 背景介绍\nCSChat聊天组件是因为公司业务需要集成XMPP即时通信功能，当时仿照微信做了一个聊天的控制器，想到这个Controller会在多处以及多个项目中集成，所以按照MVVM加命令模式把收发消息的功能和UI展示的效果进行解耦，并想对其中每一部分的功能单独复用。\n以下博文是根据第二个版本功能（增加群聊功能）代码的Review以及重构建议。关于CSChat的具体设计思路在以下链接:[CSChat聊天组件设计思路](http://chausson.github.io/)\n\n## 文件夹结构\n<img src=\"http://chausson.github.io/img/fileMeum.png\"  title=\"工程文件夹目录\">\n\n* 问题:\n1.当前文件的结构混乱，作为一个展示的Demo没有达到直观的效果,第三方的类库也没有进行归档和整理。\n2.文件以及类的过多臃肿。\n3.文件夹以及类名不够明确，不能直观的明白这些文件夹和类具体是存放什么的，它的职责是什么。\n\n* 建议:\n1.文件夹的目录划分层级关系应当清晰，可以把所以都放置在一个文件夹下，里面根据功能以及层级关系进行不同的文件夹的拆分。\n2.对外引用或者暴露的类越少越好，可以将第三方依赖库大部分支持利用cocoapod管理，而将其他的工具类可以作为一个私有方法类，在内部使用,比如可以新建一个CSChatPrivate的类，里面集成所有工具类提供的方法。\n3.可以利用一些简短或者易懂的命名直观的了解这个类以及该文件夹存在的模块内容，以及职责。\n\n## 主要控制器CSChatViewController\n* CSChatViewController.h：\n``` obj-c\n#import <UIKit/UIKit.h>\n#import \"CSChatVIewModel.h\"\n#import \"CSChatToolView.h\"\n#import \"CSChatTableView.h\"\n@interface CSChatViewController : UIViewController<CSChatToolViewKeyboardProtcol, UITableViewDataSource, UITableViewDelegate>{\n    NSMutableArray *messageList;\n    \n    NSMutableDictionary *sizeList;\n}\n- (instancetype)init __unavailable;\n- (instancetype)initWithViewModel:(CSChatViewModel *)viewModel;\n\n@property (strong ,nonatomic) CSChatToolView *chatView;\n@property (strong ,nonatomic) CSChatTableView *chatTableView;\n@property (strong ,nonatomic) CSChatViewModel *viewModel;\n@end\n\n```\nh文件中只暴露公开的属性，并且禁用其他初始化方法，在新增的初始化方法中增加注释。\n\n* CSChatViewController.m：\n``` obj-c\n- (instancetype)initWithViewModel:(CSChatViewModel *)viewModel{\n    self = [super init];\n    if (self) {\n        _viewModel = viewModel;\n        self.title = viewModel.chatControllerTitle;\n        self.view.backgroundColor = [UIColor whiteColor];\n         _chatView = [[CSChatToolView alloc]initWithObserver:self];\n        _chatTableView = [[CSChatTableView alloc] init];\n        _chatTableView.delegate = self;\n        _chatTableView.dataSource = self;\n        [self layOutsubviews];\n        @weakify(self);\n        [RACObserve(self.viewModel, cellViewModels) subscribeNext:^(NSArray *cells) {\n            @strongify(self);\n            [self.chatTableView reloadData];\n            if (cells.count >5) {\n                [self.chatTableView scrollToRowAtIndexPath:\n                 [NSIndexPath indexPathForRow:[cells count]-1 inSection:0]\n                                          atScrollPosition: UITableViewScrollPositionBottom\n                                                  animated:NO];\n                \n                [self.chatTableView reloadData];\n            }\n        }];\n      \n    }\n    return self;\n}\n#pragma mark activity\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n}\n\n```\n1.可以在didload之后增加两个方法一个是ui初始化以及布局的方法(可以拆分成ui初始化配置以及增加到父容器和增加约束的方法),还有一个就是绑定VM属性相关的方法.\n2.在initWithViewModel方法中，尽量不要初始化ui相关的对象,只保持数据的初始化,将UI布局方法和数据初始化方法分离。\n\n## CSChatViewModel(主要Controller的ViewModel)\n* CSChatViewModel.h：\n``` obj-c\n#import \"CSChatCellViewModel.h\"\n#import <Foundation/Foundation.h>\n#import \"CSChatModel.h\"\n\ntypedef void(^chatBlock)(CSChatModel* list);\n\n@interface CSChatViewModel : NSObject\n- (instancetype)init __unavailable;\n- (instancetype)initWithMessageList:(CSChatModel *)list;\n/** 聊天列表VM*/\n@property (nonatomic ,strong ) NSArray <CSChatCellViewModel *>*cellViewModels;\n/** 自己用户图标*/\n@property (nonatomic ,copy ) NSString *userIcon;\n/** 接收图标*/\n@property (nonatomic ,copy ) NSString *receiverIcon;\n/** 显示标题*/\n@property (nonatomic ,copy ) NSString *chatControllerTitle;\n\n- (void)postMessageWithText:(NSString *)text;\n- (void)sendSoundWithVoice:(NSString *)path;\n\n@end\n\n```\n1.没有对增加的Block进行注释，并且通过变量名和看不出是做什么的。\n2.- (instancetype)initWithMessageList:(CSChatModel *)list; 这个初始化方法可以废弃,因为聊天列表需要的是CSChatCellViewModel的对象,并不关心CSChatModel，可以尽量不暴露和Model业务有关的方法，甚至有必要可以去除.\n\n* CSChatViewModel.m：\n``` obj-c\n#define FACE_NAME_HEAD  @\"/s\"\n// 表情转义字符的长度（ /s占2个长度，xxx占3个长度，共5个长度 ）\n#define FACE_NAME_LEN   5\n\n\nNSString * swiftDateToStr(NSDate *date){\n    \n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    formatter.dateFormat = @\"HH:mm\";\n\n    return   [formatter stringFromDate:date];\n}\nstatic const CGFloat kDefaultPlaySoundInterval = 3.0;\n\n//用来判断是否可以收发消息\nBOOL isLayout = YES;\n\n@interface CSChatViewModel()<EMChatManagerDelegate>\n\n@end\n\n\n@implementation CSChatViewModel{\n    \n    NSDate *_lastPlaySoundDate;\n}\n- (instancetype)initWithMessageList:(CSChatModel *)list{\n    \n    self = [super init];\n    if (self) {\n        if (isLayout) {\n           __weak  typeof(self) weakSelf = self;\n            [[CSChatBusinessCommnd standardChatDefaults]setReceiverBlock:^(NSString *message) {\n                __strong typeof(self) strongSelf = weakSelf;\n\n                \n                \n                [strongSelf receiverMessageWithText:message];\n            }];\n  \n        }else{\n            UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@\"TIPS\" message:@\"NON BUINESS MODEL\" delegate:nil cancelButtonTitle:@\"OK\" otherButtonTitles:nil, nil];\n            [alert show];\n        }\n        NSMutableArray *cellTempArray = [[NSMutableArray alloc ]initWithCapacity:list.chatContent.count];\n        for (int i = 0; i < list.chatContent.count; i++) {\n            CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:list.chatContent[i]];\n            if (i != 0) {\n            CSChatViewItemModel *last = list.chatContent[i-1];\n\n                \n            [cellViewModel sortOutWithTime:last.time];\n            }\n            [cellTempArray addObject:cellViewModel];\n        }\n         _cellViewModels = [NSArray arrayWithArray:cellTempArray];\n    }\n    \n//    //注册环信消息回调\n//    [[EMClient sharedClient].chatManager addDelegate:self delegateQueue:nil];\n    \n    return self;\n}\n\n\n@end\n\n```\n1.初始化方法整体较为混乱,并且ViewModel中不应该有和UI控件直接相关的东西,去除UIAlertView或者通过其他类去关联，而不应该直接使用。\n2.EMChatManagerDelegate是环信SDK中的类，不应该出现在ViewModel中。\n3.变量名在OC的语法中应该能直观的看出这个变量的作用，建议在斟酌一下。\n\n``` obj-c\n- (void)postMessageWithText:(NSString *)text{\n    CSChatViewItemModel *model = [[CSChatViewItemModel alloc] init];\n    model.content = text;\n    model.icon = self.userIcon;\n    model.type = CSMessageText;\n    model.time = swiftDateToStr([NSDate date]);\n    CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:model];\n    [cellViewModel sortOutWithTime:[_cellViewModels lastObject]?[_cellViewModels lastObject].time:nil];\n    NSMutableArray *cellTempArray = [NSMutableArray arrayWithArray:[_cellViewModels copy]];\n    [cellTempArray addObject:cellViewModel];\n    self.cellViewModels = [NSArray arrayWithArray:cellTempArray];\n    if (isLayout) {\n        \n        \n        NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n        \n        [dic setObject:[text stringByReplacingEmojiUnicodeWithCheatCodes] forKey:@\"msgContent\"];\n        \n        \n        //判断是发单聊消息还是群聊消息给服务器\n        if ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) {\n            \n            \n            [[CSChatBusinessCommnd standardChatDefaults] postMessageWithDic:dic andUrl:nil];\n        }else{\n            \n            [[CSChatBusinessCommnd standardChatDefaults] postGroupMessageWithDic:dic andUrl:nil];\n        }\n\n        \n    }\n\n}\n```\n1.CSChatGroupSet不应该利用该单例去判断群聊还是单聊，没有充分利用ViewModel自身类的作用，有点冗余。\n2.对发送消息而言不应该传dic这个变量,没有把发送和接收的方法完全解耦开，有点和业务相关了，不了解业务的情况下，不知道如何拼装dic。\n\n* CSChatConfiguration.h：\n``` obj-c\n#import <Foundation/Foundation.h>\n\n@interface CSChatConfiguration : NSObject\n\n\n//环信注册\n+(void)registerWithUsername;\n//环信登录\n+(void)loginWithUsername;\n//创建群组\n+(NSString*)bulidGroup;\n\n//发送消息到环信\n+(void)sendToHyphenate:(NSString*)text;\n//发送群聊消息到环信\n+(void)sendToHyphenateGroup:(NSString*)text;\n\n@end\n```\n1.既然是一个配置类,那所有的配置信息都应该在该类中展现,包括刚刚提到的群聊单聊，如果有必要可以开放一些获取全局配置信息的方法。\n2.不应该出现发送消息这个功能,配置类不会去做具体功能的实现。\n3.所有的配置方法都没有传入参数,那是如何进行配置，如果是静态的，那这个类的作用完全没有体现。\n4.可以为一些拓展的功能预留一些配置的接口，比如是否消息进行本地存储,是否支持拍照和上传图片,是否支持定位。\n\n* CSChatBusinessCommnd.h：\n``` obj-c\n#import <Foundation/Foundation.h>\n#import \"CSChatModel.h\"\n\ntypedef void(^ReceiverBlock)(NSString *);\n//返回数据的block\ntypedef void(^listBlock)(CSChatModel *listModel);\n\n@class CSChatBusinessCommnd;\n\n@protocol CSChatBusinessCommndDelegate <NSObject>\n- (void)receiveMessageWithText:(NSString *)message;\n\n@end\n\n\n@interface CSChatBusinessCommnd : NSObject\n+ (instancetype)standardChatDefaults;\n\n// 发送单聊消息\n- (void)postMessageWithDic:(NSDictionary *)dic andUrl:(NSString *)url;\n// 发送群聊消息\n- (void)postGroupMessageWithDic:(NSDictionary *)dic andUrl:(NSString *)url;\n\n- (void)postSoundWithData:(NSString *)path;\n- (void)setReceiverBlock:(ReceiverBlock )block;\n\n//接收消息的回调\n-(void)receiveMessage:(listBlock)dicBlock;\n\n@end\n```\n1.该类的目的应该是对执行发送和接收消息的操作执行的人和发事件的人解耦,所有的具体收发事件必须通过该类去完成。\n2.其中post的方法可以不必带入url等参数,如果需要可以利用之前建立的configuration类进行处理,可以对外部增加一些发送以及接收的接口,或者传入不同的参数。\n3.对发送成功和失败应该有一些处理。\n\n* CSChatToolView.h：\n``` obj-c\n#import <UIKit/UIKit.h>\n@class CSChatToolView;\n@protocol CSChatToolViewKeyboardProtcol <NSObject>\n@optional\n- (void)chatKeyboardWillShow;\n- (void)chatKeyboardDidShow;\n- (void)chatKeyboardWillHide;\n- (void)chatKeyboardDidHide;\n- (void)chatInputView;\n\n- (void)sendMessageWithText:(NSString *)text;\n- (void)sendSoundWithDataPath:(NSString *)voice;\n@end\n@interface CSChatToolView : UIView\n\n- (instancetype)init __unavailable;\n- (instancetype)initWithFrame:(CGRect)frame __unavailable;\n/**\n * @brief 初始化toolView并设计观察对象\n * @return toolview实例对象\n */\n- (instancetype)initWithObserver:(NSObject<CSChatToolViewKeyboardProtcol>*)object;\n/**\n * @brief 是否隐藏键盘\n */\n- (void)setKeyboardHidden:(BOOL)hidden;\n/**\n * @brief 拓展事件调用\n */\n- (void)assistanceActionWithIndex:(NSInteger )index\n                         andBlock:(void (^)())block;\n/**\n * @brief 在视图添加到父视图之后调用 约束布局\n */\n- (void)autoLayoutView __attribute((deprecated(\"这个接口等实现约束以后再启用\")));\n@end\n```\n1.该类是键盘输入框的视图,如果支持单独复用，可以为该类增加一些必要的属性提高自定义性，比如该输入框当前的状态,当前输入的文字,或者内容等。\n\n* CSChatToolView.ma\n1.该类的内容太多就不贴代码了,可以适当的把一些方法提取出来放入我们之前提到CSChatPrivate私有类中。\n2.最好与第三方HUD解耦,自己实现录音的时间效果等。\n``` obj-c\n//发送消息到环信\n-(void)sendToHyphenate:(NSString*)text{\n    \n    \n    //判断是发单聊消息还是群聊消息给环信\n    if ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) {\n        \n         [CSChatConfiguration sendToHyphenate:text];\n    }else{\n        \n        [CSChatConfiguration sendToHyphenateGroup:text];\n    }\n\n}\n```\n3.其中不应该出现与环信有关的方法,所有的发送和接收应该由刚刚提到的Command类去处理。\n\n\n","source":"_posts/代码Review系列(1)——CHChat聊天组件.md","raw":"---\ntitle: 代码Review系列(1)——CSChat聊天组件\ncategories: 组件 #分类\ndate: 2016-06-28 16:05:08\n#tags: [博客] #代码Review\n#description: \n---\n\n## 背景介绍\nCSChat聊天组件是因为公司业务需要集成XMPP即时通信功能，当时仿照微信做了一个聊天的控制器，想到这个Controller会在多处以及多个项目中集成，所以按照MVVM加命令模式把收发消息的功能和UI展示的效果进行解耦，并想对其中每一部分的功能单独复用。\n以下博文是根据第二个版本功能（增加群聊功能）代码的Review以及重构建议。关于CSChat的具体设计思路在以下链接:[CSChat聊天组件设计思路](http://chausson.github.io/)\n\n## 文件夹结构\n<img src=\"http://chausson.github.io/img/fileMeum.png\"  title=\"工程文件夹目录\">\n\n* 问题:\n1.当前文件的结构混乱，作为一个展示的Demo没有达到直观的效果,第三方的类库也没有进行归档和整理。\n2.文件以及类的过多臃肿。\n3.文件夹以及类名不够明确，不能直观的明白这些文件夹和类具体是存放什么的，它的职责是什么。\n\n* 建议:\n1.文件夹的目录划分层级关系应当清晰，可以把所以都放置在一个文件夹下，里面根据功能以及层级关系进行不同的文件夹的拆分。\n2.对外引用或者暴露的类越少越好，可以将第三方依赖库大部分支持利用cocoapod管理，而将其他的工具类可以作为一个私有方法类，在内部使用,比如可以新建一个CSChatPrivate的类，里面集成所有工具类提供的方法。\n3.可以利用一些简短或者易懂的命名直观的了解这个类以及该文件夹存在的模块内容，以及职责。\n\n## 主要控制器CSChatViewController\n* CSChatViewController.h：\n``` obj-c\n#import <UIKit/UIKit.h>\n#import \"CSChatVIewModel.h\"\n#import \"CSChatToolView.h\"\n#import \"CSChatTableView.h\"\n@interface CSChatViewController : UIViewController<CSChatToolViewKeyboardProtcol, UITableViewDataSource, UITableViewDelegate>{\n    NSMutableArray *messageList;\n    \n    NSMutableDictionary *sizeList;\n}\n- (instancetype)init __unavailable;\n- (instancetype)initWithViewModel:(CSChatViewModel *)viewModel;\n\n@property (strong ,nonatomic) CSChatToolView *chatView;\n@property (strong ,nonatomic) CSChatTableView *chatTableView;\n@property (strong ,nonatomic) CSChatViewModel *viewModel;\n@end\n\n```\nh文件中只暴露公开的属性，并且禁用其他初始化方法，在新增的初始化方法中增加注释。\n\n* CSChatViewController.m：\n``` obj-c\n- (instancetype)initWithViewModel:(CSChatViewModel *)viewModel{\n    self = [super init];\n    if (self) {\n        _viewModel = viewModel;\n        self.title = viewModel.chatControllerTitle;\n        self.view.backgroundColor = [UIColor whiteColor];\n         _chatView = [[CSChatToolView alloc]initWithObserver:self];\n        _chatTableView = [[CSChatTableView alloc] init];\n        _chatTableView.delegate = self;\n        _chatTableView.dataSource = self;\n        [self layOutsubviews];\n        @weakify(self);\n        [RACObserve(self.viewModel, cellViewModels) subscribeNext:^(NSArray *cells) {\n            @strongify(self);\n            [self.chatTableView reloadData];\n            if (cells.count >5) {\n                [self.chatTableView scrollToRowAtIndexPath:\n                 [NSIndexPath indexPathForRow:[cells count]-1 inSection:0]\n                                          atScrollPosition: UITableViewScrollPositionBottom\n                                                  animated:NO];\n                \n                [self.chatTableView reloadData];\n            }\n        }];\n      \n    }\n    return self;\n}\n#pragma mark activity\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n}\n\n```\n1.可以在didload之后增加两个方法一个是ui初始化以及布局的方法(可以拆分成ui初始化配置以及增加到父容器和增加约束的方法),还有一个就是绑定VM属性相关的方法.\n2.在initWithViewModel方法中，尽量不要初始化ui相关的对象,只保持数据的初始化,将UI布局方法和数据初始化方法分离。\n\n## CSChatViewModel(主要Controller的ViewModel)\n* CSChatViewModel.h：\n``` obj-c\n#import \"CSChatCellViewModel.h\"\n#import <Foundation/Foundation.h>\n#import \"CSChatModel.h\"\n\ntypedef void(^chatBlock)(CSChatModel* list);\n\n@interface CSChatViewModel : NSObject\n- (instancetype)init __unavailable;\n- (instancetype)initWithMessageList:(CSChatModel *)list;\n/** 聊天列表VM*/\n@property (nonatomic ,strong ) NSArray <CSChatCellViewModel *>*cellViewModels;\n/** 自己用户图标*/\n@property (nonatomic ,copy ) NSString *userIcon;\n/** 接收图标*/\n@property (nonatomic ,copy ) NSString *receiverIcon;\n/** 显示标题*/\n@property (nonatomic ,copy ) NSString *chatControllerTitle;\n\n- (void)postMessageWithText:(NSString *)text;\n- (void)sendSoundWithVoice:(NSString *)path;\n\n@end\n\n```\n1.没有对增加的Block进行注释，并且通过变量名和看不出是做什么的。\n2.- (instancetype)initWithMessageList:(CSChatModel *)list; 这个初始化方法可以废弃,因为聊天列表需要的是CSChatCellViewModel的对象,并不关心CSChatModel，可以尽量不暴露和Model业务有关的方法，甚至有必要可以去除.\n\n* CSChatViewModel.m：\n``` obj-c\n#define FACE_NAME_HEAD  @\"/s\"\n// 表情转义字符的长度（ /s占2个长度，xxx占3个长度，共5个长度 ）\n#define FACE_NAME_LEN   5\n\n\nNSString * swiftDateToStr(NSDate *date){\n    \n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    formatter.dateFormat = @\"HH:mm\";\n\n    return   [formatter stringFromDate:date];\n}\nstatic const CGFloat kDefaultPlaySoundInterval = 3.0;\n\n//用来判断是否可以收发消息\nBOOL isLayout = YES;\n\n@interface CSChatViewModel()<EMChatManagerDelegate>\n\n@end\n\n\n@implementation CSChatViewModel{\n    \n    NSDate *_lastPlaySoundDate;\n}\n- (instancetype)initWithMessageList:(CSChatModel *)list{\n    \n    self = [super init];\n    if (self) {\n        if (isLayout) {\n           __weak  typeof(self) weakSelf = self;\n            [[CSChatBusinessCommnd standardChatDefaults]setReceiverBlock:^(NSString *message) {\n                __strong typeof(self) strongSelf = weakSelf;\n\n                \n                \n                [strongSelf receiverMessageWithText:message];\n            }];\n  \n        }else{\n            UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@\"TIPS\" message:@\"NON BUINESS MODEL\" delegate:nil cancelButtonTitle:@\"OK\" otherButtonTitles:nil, nil];\n            [alert show];\n        }\n        NSMutableArray *cellTempArray = [[NSMutableArray alloc ]initWithCapacity:list.chatContent.count];\n        for (int i = 0; i < list.chatContent.count; i++) {\n            CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:list.chatContent[i]];\n            if (i != 0) {\n            CSChatViewItemModel *last = list.chatContent[i-1];\n\n                \n            [cellViewModel sortOutWithTime:last.time];\n            }\n            [cellTempArray addObject:cellViewModel];\n        }\n         _cellViewModels = [NSArray arrayWithArray:cellTempArray];\n    }\n    \n//    //注册环信消息回调\n//    [[EMClient sharedClient].chatManager addDelegate:self delegateQueue:nil];\n    \n    return self;\n}\n\n\n@end\n\n```\n1.初始化方法整体较为混乱,并且ViewModel中不应该有和UI控件直接相关的东西,去除UIAlertView或者通过其他类去关联，而不应该直接使用。\n2.EMChatManagerDelegate是环信SDK中的类，不应该出现在ViewModel中。\n3.变量名在OC的语法中应该能直观的看出这个变量的作用，建议在斟酌一下。\n\n``` obj-c\n- (void)postMessageWithText:(NSString *)text{\n    CSChatViewItemModel *model = [[CSChatViewItemModel alloc] init];\n    model.content = text;\n    model.icon = self.userIcon;\n    model.type = CSMessageText;\n    model.time = swiftDateToStr([NSDate date]);\n    CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:model];\n    [cellViewModel sortOutWithTime:[_cellViewModels lastObject]?[_cellViewModels lastObject].time:nil];\n    NSMutableArray *cellTempArray = [NSMutableArray arrayWithArray:[_cellViewModels copy]];\n    [cellTempArray addObject:cellViewModel];\n    self.cellViewModels = [NSArray arrayWithArray:cellTempArray];\n    if (isLayout) {\n        \n        \n        NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n        \n        [dic setObject:[text stringByReplacingEmojiUnicodeWithCheatCodes] forKey:@\"msgContent\"];\n        \n        \n        //判断是发单聊消息还是群聊消息给服务器\n        if ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) {\n            \n            \n            [[CSChatBusinessCommnd standardChatDefaults] postMessageWithDic:dic andUrl:nil];\n        }else{\n            \n            [[CSChatBusinessCommnd standardChatDefaults] postGroupMessageWithDic:dic andUrl:nil];\n        }\n\n        \n    }\n\n}\n```\n1.CSChatGroupSet不应该利用该单例去判断群聊还是单聊，没有充分利用ViewModel自身类的作用，有点冗余。\n2.对发送消息而言不应该传dic这个变量,没有把发送和接收的方法完全解耦开，有点和业务相关了，不了解业务的情况下，不知道如何拼装dic。\n\n* CSChatConfiguration.h：\n``` obj-c\n#import <Foundation/Foundation.h>\n\n@interface CSChatConfiguration : NSObject\n\n\n//环信注册\n+(void)registerWithUsername;\n//环信登录\n+(void)loginWithUsername;\n//创建群组\n+(NSString*)bulidGroup;\n\n//发送消息到环信\n+(void)sendToHyphenate:(NSString*)text;\n//发送群聊消息到环信\n+(void)sendToHyphenateGroup:(NSString*)text;\n\n@end\n```\n1.既然是一个配置类,那所有的配置信息都应该在该类中展现,包括刚刚提到的群聊单聊，如果有必要可以开放一些获取全局配置信息的方法。\n2.不应该出现发送消息这个功能,配置类不会去做具体功能的实现。\n3.所有的配置方法都没有传入参数,那是如何进行配置，如果是静态的，那这个类的作用完全没有体现。\n4.可以为一些拓展的功能预留一些配置的接口，比如是否消息进行本地存储,是否支持拍照和上传图片,是否支持定位。\n\n* CSChatBusinessCommnd.h：\n``` obj-c\n#import <Foundation/Foundation.h>\n#import \"CSChatModel.h\"\n\ntypedef void(^ReceiverBlock)(NSString *);\n//返回数据的block\ntypedef void(^listBlock)(CSChatModel *listModel);\n\n@class CSChatBusinessCommnd;\n\n@protocol CSChatBusinessCommndDelegate <NSObject>\n- (void)receiveMessageWithText:(NSString *)message;\n\n@end\n\n\n@interface CSChatBusinessCommnd : NSObject\n+ (instancetype)standardChatDefaults;\n\n// 发送单聊消息\n- (void)postMessageWithDic:(NSDictionary *)dic andUrl:(NSString *)url;\n// 发送群聊消息\n- (void)postGroupMessageWithDic:(NSDictionary *)dic andUrl:(NSString *)url;\n\n- (void)postSoundWithData:(NSString *)path;\n- (void)setReceiverBlock:(ReceiverBlock )block;\n\n//接收消息的回调\n-(void)receiveMessage:(listBlock)dicBlock;\n\n@end\n```\n1.该类的目的应该是对执行发送和接收消息的操作执行的人和发事件的人解耦,所有的具体收发事件必须通过该类去完成。\n2.其中post的方法可以不必带入url等参数,如果需要可以利用之前建立的configuration类进行处理,可以对外部增加一些发送以及接收的接口,或者传入不同的参数。\n3.对发送成功和失败应该有一些处理。\n\n* CSChatToolView.h：\n``` obj-c\n#import <UIKit/UIKit.h>\n@class CSChatToolView;\n@protocol CSChatToolViewKeyboardProtcol <NSObject>\n@optional\n- (void)chatKeyboardWillShow;\n- (void)chatKeyboardDidShow;\n- (void)chatKeyboardWillHide;\n- (void)chatKeyboardDidHide;\n- (void)chatInputView;\n\n- (void)sendMessageWithText:(NSString *)text;\n- (void)sendSoundWithDataPath:(NSString *)voice;\n@end\n@interface CSChatToolView : UIView\n\n- (instancetype)init __unavailable;\n- (instancetype)initWithFrame:(CGRect)frame __unavailable;\n/**\n * @brief 初始化toolView并设计观察对象\n * @return toolview实例对象\n */\n- (instancetype)initWithObserver:(NSObject<CSChatToolViewKeyboardProtcol>*)object;\n/**\n * @brief 是否隐藏键盘\n */\n- (void)setKeyboardHidden:(BOOL)hidden;\n/**\n * @brief 拓展事件调用\n */\n- (void)assistanceActionWithIndex:(NSInteger )index\n                         andBlock:(void (^)())block;\n/**\n * @brief 在视图添加到父视图之后调用 约束布局\n */\n- (void)autoLayoutView __attribute((deprecated(\"这个接口等实现约束以后再启用\")));\n@end\n```\n1.该类是键盘输入框的视图,如果支持单独复用，可以为该类增加一些必要的属性提高自定义性，比如该输入框当前的状态,当前输入的文字,或者内容等。\n\n* CSChatToolView.ma\n1.该类的内容太多就不贴代码了,可以适当的把一些方法提取出来放入我们之前提到CSChatPrivate私有类中。\n2.最好与第三方HUD解耦,自己实现录音的时间效果等。\n``` obj-c\n//发送消息到环信\n-(void)sendToHyphenate:(NSString*)text{\n    \n    \n    //判断是发单聊消息还是群聊消息给环信\n    if ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) {\n        \n         [CSChatConfiguration sendToHyphenate:text];\n    }else{\n        \n        [CSChatConfiguration sendToHyphenateGroup:text];\n    }\n\n}\n```\n3.其中不应该出现与环信有关的方法,所有的发送和接收应该由刚刚提到的Command类去处理。\n\n\n","slug":"代码Review系列(1)——CHChat聊天组件","published":1,"updated":"2016-08-10T02:19:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pb000b4x2n02drwtk2","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>CSChat聊天组件是因为公司业务需要集成XMPP即时通信功能，当时仿照微信做了一个聊天的控制器，想到这个Controller会在多处以及多个项目中集成，所以按照MVVM加命令模式把收发消息的功能和UI展示的效果进行解耦，并想对其中每一部分的功能单独复用。<br>以下博文是根据第二个版本功能（增加群聊功能）代码的Review以及重构建议。关于CSChat的具体设计思路在以下链接:<a href=\"http://chausson.github.io/\">CSChat聊天组件设计思路</a></p>\n<h2 id=\"文件夹结构\"><a href=\"#文件夹结构\" class=\"headerlink\" title=\"文件夹结构\"></a>文件夹结构</h2><p><img src=\"http://chausson.github.io/img/fileMeum.png\" title=\"工程文件夹目录\"></p>\n<ul>\n<li><p>问题:<br>1.当前文件的结构混乱，作为一个展示的Demo没有达到直观的效果,第三方的类库也没有进行归档和整理。<br>2.文件以及类的过多臃肿。<br>3.文件夹以及类名不够明确，不能直观的明白这些文件夹和类具体是存放什么的，它的职责是什么。</p>\n</li>\n<li><p>建议:<br>1.文件夹的目录划分层级关系应当清晰，可以把所以都放置在一个文件夹下，里面根据功能以及层级关系进行不同的文件夹的拆分。<br>2.对外引用或者暴露的类越少越好，可以将第三方依赖库大部分支持利用cocoapod管理，而将其他的工具类可以作为一个私有方法类，在内部使用,比如可以新建一个CSChatPrivate的类，里面集成所有工具类提供的方法。<br>3.可以利用一些简短或者易懂的命名直观的了解这个类以及该文件夹存在的模块内容，以及职责。</p>\n</li>\n</ul>\n<h2 id=\"主要控制器CSChatViewController\"><a href=\"#主要控制器CSChatViewController\" class=\"headerlink\" title=\"主要控制器CSChatViewController\"></a>主要控制器CSChatViewController</h2><ul>\n<li>CSChatViewController.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatVIewModel.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatToolView.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatTableView.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewController</span> : <span class=\"title\">UIViewController</span>&lt;<span class=\"title\">CSChatToolViewKeyboardProtcol</span>, <span class=\"title\">UITableViewDataSource</span>, <span class=\"title\">UITableViewDelegate</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *messageList;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *sizeList;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(CSChatViewModel *)viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatToolView *chatView;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatTableView *chatTableView;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatViewModel *viewModel;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>h文件中只暴露公开的属性，并且禁用其他初始化方法，在新增的初始化方法中增加注释。</p>\n<ul>\n<li>CSChatViewController.m：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(CSChatViewModel *)viewModel&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        _viewModel = viewModel;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title = viewModel.chatControllerTitle;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">         _chatView = [[CSChatToolView alloc]initWithObserver:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        _chatTableView = [[CSChatTableView alloc] init];</span><br><span class=\"line\">        _chatTableView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        _chatTableView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> layOutsubviews];</span><br><span class=\"line\">        @weakify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        [RACObserve(<span class=\"keyword\">self</span>.viewModel, cellViewModels) subscribeNext:^(<span class=\"built_in\">NSArray</span> *cells) &#123;</span><br><span class=\"line\">            @strongify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.chatTableView reloadData];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cells.count &gt;<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.chatTableView scrollToRowAtIndexPath:</span><br><span class=\"line\">                 [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:[cells count]<span class=\"number\">-1</span> inSection:<span class=\"number\">0</span>]</span><br><span class=\"line\">                                          atScrollPosition: <span class=\"built_in\">UITableViewScrollPositionBottom</span></span><br><span class=\"line\">                                                  animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">                </span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.chatTableView reloadData];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#pragma mark activity</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.可以在didload之后增加两个方法一个是ui初始化以及布局的方法(可以拆分成ui初始化配置以及增加到父容器和增加约束的方法),还有一个就是绑定VM属性相关的方法.<br>2.在initWithViewModel方法中，尽量不要初始化ui相关的对象,只保持数据的初始化,将UI布局方法和数据初始化方法分离。</p>\n<h2 id=\"CSChatViewModel-主要Controller的ViewModel\"><a href=\"#CSChatViewModel-主要Controller的ViewModel\" class=\"headerlink\" title=\"CSChatViewModel(主要Controller的ViewModel)\"></a>CSChatViewModel(主要Controller的ViewModel)</h2><ul>\n<li>CSChatViewModel.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatCellViewModel.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatModel.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^chatBlock)(CSChatModel* list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewModel</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithMessageList:(CSChatModel *)list;</span><br><span class=\"line\"><span class=\"comment\">/** 聊天列表VM*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">strong</span> ) <span class=\"built_in\">NSArray</span> &lt;CSChatCellViewModel *&gt;*cellViewModels;</span><br><span class=\"line\"><span class=\"comment\">/** 自己用户图标*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *userIcon;</span><br><span class=\"line\"><span class=\"comment\">/** 接收图标*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *receiverIcon;</span><br><span class=\"line\"><span class=\"comment\">/** 显示标题*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *chatControllerTitle;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithText:(<span class=\"built_in\">NSString</span> *)text;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendSoundWithVoice:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.没有对增加的Block进行注释，并且通过变量名和看不出是做什么的。<br>2.- (instancetype)initWithMessageList:(CSChatModel *)list; 这个初始化方法可以废弃,因为聊天列表需要的是CSChatCellViewModel的对象,并不关心CSChatModel，可以尽量不暴露和Model业务有关的方法，甚至有必要可以去除.</p>\n<ul>\n<li>CSChatViewModel.m：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define FACE_NAME_HEAD  @<span class=\"meta-string\">\"/s\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 表情转义字符的长度（ /s占2个长度，xxx占3个长度，共5个长度 ）</span></span><br><span class=\"line\"><span class=\"meta\">#define FACE_NAME_LEN   5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> * swiftDateToStr(<span class=\"built_in\">NSDate</span> *date)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    formatter.dateFormat = <span class=\"string\">@\"HH:mm\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>   [formatter stringFromDate:date];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">CGFloat</span> kDefaultPlaySoundInterval = <span class=\"number\">3.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用来判断是否可以收发消息</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> isLayout = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewModel</span>()&lt;<span class=\"title\">EMChatManagerDelegate</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CSChatViewModel</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *_lastPlaySoundDate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithMessageList:(CSChatModel *)list&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLayout) &#123;</span><br><span class=\"line\">           __<span class=\"keyword\">weak</span>  <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults]setReceiverBlock:^(<span class=\"built_in\">NSString</span> *message) &#123;</span><br><span class=\"line\">                __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) strongSelf = weakSelf;</span><br><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\">                </span><br><span class=\"line\">                [strongSelf receiverMessageWithText:message];</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]initWithTitle:<span class=\"string\">@\"TIPS\"</span> message:<span class=\"string\">@\"NON BUINESS MODEL\"</span> delegate:<span class=\"literal\">nil</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles:<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">            [alert show];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *cellTempArray = [[<span class=\"built_in\">NSMutableArray</span> alloc ]initWithCapacity:list.chatContent.count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.chatContent.count; i++) &#123;</span><br><span class=\"line\">            CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:list.chatContent[i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            CSChatViewItemModel *last = list.chatContent[i<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\">            [cellViewModel sortOutWithTime:last.time];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [cellTempArray addObject:cellViewModel];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         _cellViewModels = [<span class=\"built_in\">NSArray</span> arrayWithArray:cellTempArray];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//    //注册环信消息回调</span></span><br><span class=\"line\"><span class=\"comment\">//    [[EMClient sharedClient].chatManager addDelegate:self delegateQueue:nil];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.初始化方法整体较为混乱,并且ViewModel中不应该有和UI控件直接相关的东西,去除UIAlertView或者通过其他类去关联，而不应该直接使用。<br>2.EMChatManagerDelegate是环信SDK中的类，不应该出现在ViewModel中。<br>3.变量名在OC的语法中应该能直观的看出这个变量的作用，建议在斟酌一下。</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithText:(<span class=\"built_in\">NSString</span> *)text&#123;</span><br><span class=\"line\">    CSChatViewItemModel *model = [[CSChatViewItemModel alloc] init];</span><br><span class=\"line\">    model.content = text;</span><br><span class=\"line\">    model.icon = <span class=\"keyword\">self</span>.userIcon;</span><br><span class=\"line\">    model.type = CSMessageText;</span><br><span class=\"line\">    model.time = swiftDateToStr([<span class=\"built_in\">NSDate</span> date]);</span><br><span class=\"line\">    CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:model];</span><br><span class=\"line\">    [cellViewModel sortOutWithTime:[_cellViewModels lastObject]?[_cellViewModels lastObject].time:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *cellTempArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:[_cellViewModels <span class=\"keyword\">copy</span>]];</span><br><span class=\"line\">    [cellTempArray addObject:cellViewModel];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.cellViewModels = [<span class=\"built_in\">NSArray</span> arrayWithArray:cellTempArray];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLayout) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSMutableDictionary</span> *dic = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [dic setObject:[text stringByReplacingEmojiUnicodeWithCheatCodes] forKey:<span class=\"string\">@\"msgContent\"</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//判断是发单聊消息还是群聊消息给服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults] postMessageWithDic:dic andUrl:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults] postGroupMessageWithDic:dic andUrl:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1.CSChatGroupSet不应该利用该单例去判断群聊还是单聊，没有充分利用ViewModel自身类的作用，有点冗余。<br>2.对发送消息而言不应该传dic这个变量,没有把发送和接收的方法完全解耦开，有点和业务相关了，不了解业务的情况下，不知道如何拼装dic。</p>\n<ul>\n<li>CSChatConfiguration.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatConfiguration</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//环信注册</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)registerWithUsername;</span><br><span class=\"line\"><span class=\"comment\">//环信登录</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)loginWithUsername;</span><br><span class=\"line\"><span class=\"comment\">//创建群组</span></span><br><span class=\"line\">+(<span class=\"built_in\">NSString</span>*)bulidGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息到环信</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)sendToHyphenate:(<span class=\"built_in\">NSString</span>*)text;</span><br><span class=\"line\"><span class=\"comment\">//发送群聊消息到环信</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)sendToHyphenateGroup:(<span class=\"built_in\">NSString</span>*)text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.既然是一个配置类,那所有的配置信息都应该在该类中展现,包括刚刚提到的群聊单聊，如果有必要可以开放一些获取全局配置信息的方法。<br>2.不应该出现发送消息这个功能,配置类不会去做具体功能的实现。<br>3.所有的配置方法都没有传入参数,那是如何进行配置，如果是静态的，那这个类的作用完全没有体现。<br>4.可以为一些拓展的功能预留一些配置的接口，比如是否消息进行本地存储,是否支持拍照和上传图片,是否支持定位。</p>\n<ul>\n<li>CSChatBusinessCommnd.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatModel.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ReceiverBlock)(<span class=\"built_in\">NSString</span> *);</span><br><span class=\"line\"><span class=\"comment\">//返回数据的block</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^listBlock)(CSChatModel *listModel);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">CSChatBusinessCommnd</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CSChatBusinessCommndDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)receiveMessageWithText:(<span class=\"built_in\">NSString</span> *)message;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatBusinessCommnd</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)standardChatDefaults;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送单聊消息</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithDic:(<span class=\"built_in\">NSDictionary</span> *)dic andUrl:(<span class=\"built_in\">NSString</span> *)url;</span><br><span class=\"line\"><span class=\"comment\">// 发送群聊消息</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postGroupMessageWithDic:(<span class=\"built_in\">NSDictionary</span> *)dic andUrl:(<span class=\"built_in\">NSString</span> *)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postSoundWithData:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setReceiverBlock:(ReceiverBlock )block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接收消息的回调</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)receiveMessage:(listBlock)dicBlock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.该类的目的应该是对执行发送和接收消息的操作执行的人和发事件的人解耦,所有的具体收发事件必须通过该类去完成。<br>2.其中post的方法可以不必带入url等参数,如果需要可以利用之前建立的configuration类进行处理,可以对外部增加一些发送以及接收的接口,或者传入不同的参数。<br>3.对发送成功和失败应该有一些处理。</p>\n<ul>\n<li>CSChatToolView.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">CSChatToolView</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CSChatToolViewKeyboardProtcol</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardWillShow;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardDidShow;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardWillHide;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardDidHide;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatInputView;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendMessageWithText:(<span class=\"built_in\">NSString</span> *)text;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendSoundWithDataPath:(<span class=\"built_in\">NSString</span> *)voice;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatToolView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame __unavailable;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 初始化toolView并设计观察对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @return toolview实例对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithObserver:(<span class=\"built_in\">NSObject</span>&lt;CSChatToolViewKeyboardProtcol&gt;*)object;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 是否隐藏键盘</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setKeyboardHidden:(<span class=\"built_in\">BOOL</span>)hidden;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 拓展事件调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)assistanceActionWithIndex:(<span class=\"built_in\">NSInteger</span> )index</span><br><span class=\"line\">                         andBlock:(<span class=\"keyword\">void</span> (^)())block;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 在视图添加到父视图之后调用 约束布局</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)autoLayoutView __attribute((deprecated(<span class=\"string\">\"这个接口等实现约束以后再启用\"</span>)));</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.该类是键盘输入框的视图,如果支持单独复用，可以为该类增加一些必要的属性提高自定义性，比如该输入框当前的状态,当前输入的文字,或者内容等。</p>\n<ul>\n<li>CSChatToolView.ma<br>1.该类的内容太多就不贴代码了,可以适当的把一些方法提取出来放入我们之前提到CSChatPrivate私有类中。<br>2.最好与第三方HUD解耦,自己实现录音的时间效果等。<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息到环信</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)sendToHyphenate:(<span class=\"built_in\">NSString</span>*)text&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//判断是发单聊消息还是群聊消息给环信</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">         [CSChatConfiguration sendToHyphenate:text];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [CSChatConfiguration sendToHyphenateGroup:text];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.其中不应该出现与环信有关的方法,所有的发送和接收应该由刚刚提到的Command类去处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>CSChat聊天组件是因为公司业务需要集成XMPP即时通信功能，当时仿照微信做了一个聊天的控制器，想到这个Controller会在多处以及多个项目中集成，所以按照MVVM加命令模式把收发消息的功能和UI展示的效果进行解耦，并想对其中每一部分的功能单独复用。<br>以下博文是根据第二个版本功能（增加群聊功能）代码的Review以及重构建议。关于CSChat的具体设计思路在以下链接:<a href=\"http://chausson.github.io/\">CSChat聊天组件设计思路</a></p>\n<h2 id=\"文件夹结构\"><a href=\"#文件夹结构\" class=\"headerlink\" title=\"文件夹结构\"></a>文件夹结构</h2><p><img src=\"http://chausson.github.io/img/fileMeum.png\" title=\"工程文件夹目录\"></p>\n<ul>\n<li><p>问题:<br>1.当前文件的结构混乱，作为一个展示的Demo没有达到直观的效果,第三方的类库也没有进行归档和整理。<br>2.文件以及类的过多臃肿。<br>3.文件夹以及类名不够明确，不能直观的明白这些文件夹和类具体是存放什么的，它的职责是什么。</p>\n</li>\n<li><p>建议:<br>1.文件夹的目录划分层级关系应当清晰，可以把所以都放置在一个文件夹下，里面根据功能以及层级关系进行不同的文件夹的拆分。<br>2.对外引用或者暴露的类越少越好，可以将第三方依赖库大部分支持利用cocoapod管理，而将其他的工具类可以作为一个私有方法类，在内部使用,比如可以新建一个CSChatPrivate的类，里面集成所有工具类提供的方法。<br>3.可以利用一些简短或者易懂的命名直观的了解这个类以及该文件夹存在的模块内容，以及职责。</p>\n</li>\n</ul>\n<h2 id=\"主要控制器CSChatViewController\"><a href=\"#主要控制器CSChatViewController\" class=\"headerlink\" title=\"主要控制器CSChatViewController\"></a>主要控制器CSChatViewController</h2><ul>\n<li>CSChatViewController.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatVIewModel.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatToolView.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatTableView.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewController</span> : <span class=\"title\">UIViewController</span>&lt;<span class=\"title\">CSChatToolViewKeyboardProtcol</span>, <span class=\"title\">UITableViewDataSource</span>, <span class=\"title\">UITableViewDelegate</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *messageList;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *sizeList;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(CSChatViewModel *)viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatToolView *chatView;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatTableView *chatTableView;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span> ,<span class=\"keyword\">nonatomic</span>) CSChatViewModel *viewModel;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>h文件中只暴露公开的属性，并且禁用其他初始化方法，在新增的初始化方法中增加注释。</p>\n<ul>\n<li>CSChatViewController.m：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithViewModel:(CSChatViewModel *)viewModel&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        _viewModel = viewModel;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title = viewModel.chatControllerTitle;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">         _chatView = [[CSChatToolView alloc]initWithObserver:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        _chatTableView = [[CSChatTableView alloc] init];</span><br><span class=\"line\">        _chatTableView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        _chatTableView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> layOutsubviews];</span><br><span class=\"line\">        @weakify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        [RACObserve(<span class=\"keyword\">self</span>.viewModel, cellViewModels) subscribeNext:^(<span class=\"built_in\">NSArray</span> *cells) &#123;</span><br><span class=\"line\">            @strongify(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">            [<span class=\"keyword\">self</span>.chatTableView reloadData];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cells.count &gt;<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.chatTableView scrollToRowAtIndexPath:</span><br><span class=\"line\">                 [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:[cells count]<span class=\"number\">-1</span> inSection:<span class=\"number\">0</span>]</span><br><span class=\"line\">                                          atScrollPosition: <span class=\"built_in\">UITableViewScrollPositionBottom</span></span><br><span class=\"line\">                                                  animated:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">                </span><br><span class=\"line\">                [<span class=\"keyword\">self</span>.chatTableView reloadData];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#pragma mark activity</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.可以在didload之后增加两个方法一个是ui初始化以及布局的方法(可以拆分成ui初始化配置以及增加到父容器和增加约束的方法),还有一个就是绑定VM属性相关的方法.<br>2.在initWithViewModel方法中，尽量不要初始化ui相关的对象,只保持数据的初始化,将UI布局方法和数据初始化方法分离。</p>\n<h2 id=\"CSChatViewModel-主要Controller的ViewModel\"><a href=\"#CSChatViewModel-主要Controller的ViewModel\" class=\"headerlink\" title=\"CSChatViewModel(主要Controller的ViewModel)\"></a>CSChatViewModel(主要Controller的ViewModel)</h2><ul>\n<li>CSChatViewModel.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatCellViewModel.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatModel.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^chatBlock)(CSChatModel* list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewModel</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithMessageList:(CSChatModel *)list;</span><br><span class=\"line\"><span class=\"comment\">/** 聊天列表VM*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">strong</span> ) <span class=\"built_in\">NSArray</span> &lt;CSChatCellViewModel *&gt;*cellViewModels;</span><br><span class=\"line\"><span class=\"comment\">/** 自己用户图标*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *userIcon;</span><br><span class=\"line\"><span class=\"comment\">/** 接收图标*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *receiverIcon;</span><br><span class=\"line\"><span class=\"comment\">/** 显示标题*/</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> ,<span class=\"keyword\">copy</span> ) <span class=\"built_in\">NSString</span> *chatControllerTitle;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithText:(<span class=\"built_in\">NSString</span> *)text;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendSoundWithVoice:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.没有对增加的Block进行注释，并且通过变量名和看不出是做什么的。<br>2.- (instancetype)initWithMessageList:(CSChatModel *)list; 这个初始化方法可以废弃,因为聊天列表需要的是CSChatCellViewModel的对象,并不关心CSChatModel，可以尽量不暴露和Model业务有关的方法，甚至有必要可以去除.</p>\n<ul>\n<li>CSChatViewModel.m：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#define FACE_NAME_HEAD  @<span class=\"meta-string\">\"/s\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 表情转义字符的长度（ /s占2个长度，xxx占3个长度，共5个长度 ）</span></span><br><span class=\"line\"><span class=\"meta\">#define FACE_NAME_LEN   5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> * swiftDateToStr(<span class=\"built_in\">NSDate</span> *date)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    formatter.dateFormat = <span class=\"string\">@\"HH:mm\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>   [formatter stringFromDate:date];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">CGFloat</span> kDefaultPlaySoundInterval = <span class=\"number\">3.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用来判断是否可以收发消息</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> isLayout = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatViewModel</span>()&lt;<span class=\"title\">EMChatManagerDelegate</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CSChatViewModel</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *_lastPlaySoundDate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithMessageList:(CSChatModel *)list&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isLayout) &#123;</span><br><span class=\"line\">           __<span class=\"keyword\">weak</span>  <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults]setReceiverBlock:^(<span class=\"built_in\">NSString</span> *message) &#123;</span><br><span class=\"line\">                __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) strongSelf = weakSelf;</span><br><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\">                </span><br><span class=\"line\">                [strongSelf receiverMessageWithText:message];</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">UIAlertView</span> *alert = [[<span class=\"built_in\">UIAlertView</span> alloc]initWithTitle:<span class=\"string\">@\"TIPS\"</span> message:<span class=\"string\">@\"NON BUINESS MODEL\"</span> delegate:<span class=\"literal\">nil</span> cancelButtonTitle:<span class=\"string\">@\"OK\"</span> otherButtonTitles:<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">            [alert show];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *cellTempArray = [[<span class=\"built_in\">NSMutableArray</span> alloc ]initWithCapacity:list.chatContent.count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.chatContent.count; i++) &#123;</span><br><span class=\"line\">            CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:list.chatContent[i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            CSChatViewItemModel *last = list.chatContent[i<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                </span><br><span class=\"line\">            [cellViewModel sortOutWithTime:last.time];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [cellTempArray addObject:cellViewModel];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         _cellViewModels = [<span class=\"built_in\">NSArray</span> arrayWithArray:cellTempArray];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//    //注册环信消息回调</span></span><br><span class=\"line\"><span class=\"comment\">//    [[EMClient sharedClient].chatManager addDelegate:self delegateQueue:nil];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.初始化方法整体较为混乱,并且ViewModel中不应该有和UI控件直接相关的东西,去除UIAlertView或者通过其他类去关联，而不应该直接使用。<br>2.EMChatManagerDelegate是环信SDK中的类，不应该出现在ViewModel中。<br>3.变量名在OC的语法中应该能直观的看出这个变量的作用，建议在斟酌一下。</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithText:(<span class=\"built_in\">NSString</span> *)text&#123;</span><br><span class=\"line\">    CSChatViewItemModel *model = [[CSChatViewItemModel alloc] init];</span><br><span class=\"line\">    model.content = text;</span><br><span class=\"line\">    model.icon = <span class=\"keyword\">self</span>.userIcon;</span><br><span class=\"line\">    model.type = CSMessageText;</span><br><span class=\"line\">    model.time = swiftDateToStr([<span class=\"built_in\">NSDate</span> date]);</span><br><span class=\"line\">    CSChatCellViewModel *cellViewModel = [[CSChatCellViewModel alloc]initWithModel:model];</span><br><span class=\"line\">    [cellViewModel sortOutWithTime:[_cellViewModels lastObject]?[_cellViewModels lastObject].time:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *cellTempArray = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:[_cellViewModels <span class=\"keyword\">copy</span>]];</span><br><span class=\"line\">    [cellTempArray addObject:cellViewModel];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.cellViewModels = [<span class=\"built_in\">NSArray</span> arrayWithArray:cellTempArray];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLayout) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSMutableDictionary</span> *dic = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [dic setObject:[text stringByReplacingEmojiUnicodeWithCheatCodes] forKey:<span class=\"string\">@\"msgContent\"</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//判断是发单聊消息还是群聊消息给服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults] postMessageWithDic:dic andUrl:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            [[CSChatBusinessCommnd standardChatDefaults] postGroupMessageWithDic:dic andUrl:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1.CSChatGroupSet不应该利用该单例去判断群聊还是单聊，没有充分利用ViewModel自身类的作用，有点冗余。<br>2.对发送消息而言不应该传dic这个变量,没有把发送和接收的方法完全解耦开，有点和业务相关了，不了解业务的情况下，不知道如何拼装dic。</p>\n<ul>\n<li>CSChatConfiguration.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatConfiguration</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//环信注册</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)registerWithUsername;</span><br><span class=\"line\"><span class=\"comment\">//环信登录</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)loginWithUsername;</span><br><span class=\"line\"><span class=\"comment\">//创建群组</span></span><br><span class=\"line\">+(<span class=\"built_in\">NSString</span>*)bulidGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息到环信</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)sendToHyphenate:(<span class=\"built_in\">NSString</span>*)text;</span><br><span class=\"line\"><span class=\"comment\">//发送群聊消息到环信</span></span><br><span class=\"line\">+(<span class=\"keyword\">void</span>)sendToHyphenateGroup:(<span class=\"built_in\">NSString</span>*)text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.既然是一个配置类,那所有的配置信息都应该在该类中展现,包括刚刚提到的群聊单聊，如果有必要可以开放一些获取全局配置信息的方法。<br>2.不应该出现发送消息这个功能,配置类不会去做具体功能的实现。<br>3.所有的配置方法都没有传入参数,那是如何进行配置，如果是静态的，那这个类的作用完全没有体现。<br>4.可以为一些拓展的功能预留一些配置的接口，比如是否消息进行本地存储,是否支持拍照和上传图片,是否支持定位。</p>\n<ul>\n<li>CSChatBusinessCommnd.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CSChatModel.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ReceiverBlock)(<span class=\"built_in\">NSString</span> *);</span><br><span class=\"line\"><span class=\"comment\">//返回数据的block</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^listBlock)(CSChatModel *listModel);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">CSChatBusinessCommnd</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CSChatBusinessCommndDelegate</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)receiveMessageWithText:(<span class=\"built_in\">NSString</span> *)message;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatBusinessCommnd</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)standardChatDefaults;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送单聊消息</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postMessageWithDic:(<span class=\"built_in\">NSDictionary</span> *)dic andUrl:(<span class=\"built_in\">NSString</span> *)url;</span><br><span class=\"line\"><span class=\"comment\">// 发送群聊消息</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postGroupMessageWithDic:(<span class=\"built_in\">NSDictionary</span> *)dic andUrl:(<span class=\"built_in\">NSString</span> *)url;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)postSoundWithData:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setReceiverBlock:(ReceiverBlock )block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接收消息的回调</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)receiveMessage:(listBlock)dicBlock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.该类的目的应该是对执行发送和接收消息的操作执行的人和发事件的人解耦,所有的具体收发事件必须通过该类去完成。<br>2.其中post的方法可以不必带入url等参数,如果需要可以利用之前建立的configuration类进行处理,可以对外部增加一些发送以及接收的接口,或者传入不同的参数。<br>3.对发送成功和失败应该有一些处理。</p>\n<ul>\n<li>CSChatToolView.h：<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">CSChatToolView</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">CSChatToolViewKeyboardProtcol</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">@optional</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardWillShow;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardDidShow;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardWillHide;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatKeyboardDidHide;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)chatInputView;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendMessageWithText:(<span class=\"built_in\">NSString</span> *)text;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sendSoundWithDataPath:(<span class=\"built_in\">NSString</span> *)voice;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CSChatToolView</span> : <span class=\"title\">UIView</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init __unavailable;</span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame __unavailable;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 初始化toolView并设计观察对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @return toolview实例对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithObserver:(<span class=\"built_in\">NSObject</span>&lt;CSChatToolViewKeyboardProtcol&gt;*)object;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 是否隐藏键盘</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setKeyboardHidden:(<span class=\"built_in\">BOOL</span>)hidden;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 拓展事件调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)assistanceActionWithIndex:(<span class=\"built_in\">NSInteger</span> )index</span><br><span class=\"line\">                         andBlock:(<span class=\"keyword\">void</span> (^)())block;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 在视图添加到父视图之后调用 约束布局</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)autoLayoutView __attribute((deprecated(<span class=\"string\">\"这个接口等实现约束以后再启用\"</span>)));</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1.该类是键盘输入框的视图,如果支持单独复用，可以为该类增加一些必要的属性提高自定义性，比如该输入框当前的状态,当前输入的文字,或者内容等。</p>\n<ul>\n<li>CSChatToolView.ma<br>1.该类的内容太多就不贴代码了,可以适当的把一些方法提取出来放入我们之前提到CSChatPrivate私有类中。<br>2.最好与第三方HUD解耦,自己实现录音的时间效果等。<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息到环信</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)sendToHyphenate:(<span class=\"built_in\">NSString</span>*)text&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//判断是发单聊消息还是群聊消息给环信</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([CSChatGroupSet sharedGroupSet].chatType == CSChatCellChatTypeChat) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">         [CSChatConfiguration sendToHyphenate:text];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [CSChatConfiguration sendToHyphenateGroup:text];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>3.其中不应该出现与环信有关的方法,所有的发送和接收应该由刚刚提到的Command类去处理。</p>\n"},{"title":"iOS中的MVC架构模式","date":"2016-12-09T03:03:44.000Z","_content":"  在软件开发工程中，我们常常用到架构模式，以及设计模式，良好的架构模式会让整个项目层次清晰，维护容易。我们来谈下MVC的架构模式在iOS中的使用。\n   先简单介绍一下MVC这个模式,Model-View-Controller是我们比较常用的架构模式。这样的架构模式在一个应用程序，赋予了对象三种作用:model,view,和controller。这样不止定义了每个对象在程序中的角色，还有定义了各个对象之间的关系。三种类型的对象被抽象的划分，以及清楚的明确职责。简单来说，每个层级之间做好自己的事，不干预其他对象之间的关系，只关心我和其他层级之间的连接方式和开放的接口。具有一定的对象的集合在MVC模式中有时会被归类为层的例子，例如模型层。\n\n Cocoa框架中的核心设计就是MVC，当然在这一设计模式中有很多好处不言而喻。\n模型的复用性\n\t许多模型对象在程序中可以被重复使用，他们的接口可以被更好的定义以及理解。\n易用性和拓展性\n\t在一个工程中使用MVC会更好的扩展,此外Cocoa框架是基于MVC的架构，而且需要自定义的模型需要在其中扮演一种作用。\n\t\n\n# Apple中理想的MVC模式\n\n<img src=\"/img/mvc.png\"  title=\"mvc\">\n\n\n# Model Objects\n模型对象根据应用程序的业务场景封装了特定的数据，并且定义操作的逻辑和计算处理数据。举个例子，一个模型对象可能表示游戏中的角色或者是通讯录中的联系人。它可能有一对一或者一对多的关系，有时一个应用程序的模型层实际上是一个或者多个对象的图表。更多应用程序中的模型是一种持久的状态（无论是作为文件或者数据库中），应该在数据转换到模型上之后加载到程序中。模型应该就是本身独立于项目的存在，将业务中的实体和类型理解成类和对象的关系应用到程序中。\n\n用户在View层操作的响应和输入的数据会通过controller来创建或者改变具体的实例模型对象。当一个模型对象改变的时候（比如网络请求后的数据拿到后）会去通知到controller对象来刷新对应的View对象。\n\n# View Objects\n\n# Controller Objects\n","source":"_posts/iOS中的MVC架构模式.md","raw":"---\ntitle: iOS中的MVC架构模式\ncategories: 设计模式 #分类\ndate: 2016-12-09 11:03:44\ntags:\n---\n  在软件开发工程中，我们常常用到架构模式，以及设计模式，良好的架构模式会让整个项目层次清晰，维护容易。我们来谈下MVC的架构模式在iOS中的使用。\n   先简单介绍一下MVC这个模式,Model-View-Controller是我们比较常用的架构模式。这样的架构模式在一个应用程序，赋予了对象三种作用:model,view,和controller。这样不止定义了每个对象在程序中的角色，还有定义了各个对象之间的关系。三种类型的对象被抽象的划分，以及清楚的明确职责。简单来说，每个层级之间做好自己的事，不干预其他对象之间的关系，只关心我和其他层级之间的连接方式和开放的接口。具有一定的对象的集合在MVC模式中有时会被归类为层的例子，例如模型层。\n\n Cocoa框架中的核心设计就是MVC，当然在这一设计模式中有很多好处不言而喻。\n模型的复用性\n\t许多模型对象在程序中可以被重复使用，他们的接口可以被更好的定义以及理解。\n易用性和拓展性\n\t在一个工程中使用MVC会更好的扩展,此外Cocoa框架是基于MVC的架构，而且需要自定义的模型需要在其中扮演一种作用。\n\t\n\n# Apple中理想的MVC模式\n\n<img src=\"/img/mvc.png\"  title=\"mvc\">\n\n\n# Model Objects\n模型对象根据应用程序的业务场景封装了特定的数据，并且定义操作的逻辑和计算处理数据。举个例子，一个模型对象可能表示游戏中的角色或者是通讯录中的联系人。它可能有一对一或者一对多的关系，有时一个应用程序的模型层实际上是一个或者多个对象的图表。更多应用程序中的模型是一种持久的状态（无论是作为文件或者数据库中），应该在数据转换到模型上之后加载到程序中。模型应该就是本身独立于项目的存在，将业务中的实体和类型理解成类和对象的关系应用到程序中。\n\n用户在View层操作的响应和输入的数据会通过controller来创建或者改变具体的实例模型对象。当一个模型对象改变的时候（比如网络请求后的数据拿到后）会去通知到controller对象来刷新对应的View对象。\n\n# View Objects\n\n# Controller Objects\n","slug":"iOS中的MVC架构模式","published":1,"updated":"2016-12-21T12:29:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pf000c4x2nb80gtega","content":"<p>  在软件开发工程中，我们常常用到架构模式，以及设计模式，良好的架构模式会让整个项目层次清晰，维护容易。我们来谈下MVC的架构模式在iOS中的使用。<br>   先简单介绍一下MVC这个模式,Model-View-Controller是我们比较常用的架构模式。这样的架构模式在一个应用程序，赋予了对象三种作用:model,view,和controller。这样不止定义了每个对象在程序中的角色，还有定义了各个对象之间的关系。三种类型的对象被抽象的划分，以及清楚的明确职责。简单来说，每个层级之间做好自己的事，不干预其他对象之间的关系，只关心我和其他层级之间的连接方式和开放的接口。具有一定的对象的集合在MVC模式中有时会被归类为层的例子，例如模型层。</p>\n<p> Cocoa框架中的核心设计就是MVC，当然在这一设计模式中有很多好处不言而喻。<br>模型的复用性<br>    许多模型对象在程序中可以被重复使用，他们的接口可以被更好的定义以及理解。<br>易用性和拓展性<br>    在一个工程中使用MVC会更好的扩展,此外Cocoa框架是基于MVC的架构，而且需要自定义的模型需要在其中扮演一种作用。</p>\n<h1 id=\"Apple中理想的MVC模式\"><a href=\"#Apple中理想的MVC模式\" class=\"headerlink\" title=\"Apple中理想的MVC模式\"></a>Apple中理想的MVC模式</h1><p><img src=\"/img/mvc.png\" title=\"mvc\"></p>\n<h1 id=\"Model-Objects\"><a href=\"#Model-Objects\" class=\"headerlink\" title=\"Model Objects\"></a>Model Objects</h1><p>模型对象根据应用程序的业务场景封装了特定的数据，并且定义操作的逻辑和计算处理数据。举个例子，一个模型对象可能表示游戏中的角色或者是通讯录中的联系人。它可能有一对一或者一对多的关系，有时一个应用程序的模型层实际上是一个或者多个对象的图表。更多应用程序中的模型是一种持久的状态（无论是作为文件或者数据库中），应该在数据转换到模型上之后加载到程序中。模型应该就是本身独立于项目的存在，将业务中的实体和类型理解成类和对象的关系应用到程序中。</p>\n<p>用户在View层操作的响应和输入的数据会通过controller来创建或者改变具体的实例模型对象。当一个模型对象改变的时候（比如网络请求后的数据拿到后）会去通知到controller对象来刷新对应的View对象。</p>\n<h1 id=\"View-Objects\"><a href=\"#View-Objects\" class=\"headerlink\" title=\"View Objects\"></a>View Objects</h1><h1 id=\"Controller-Objects\"><a href=\"#Controller-Objects\" class=\"headerlink\" title=\"Controller Objects\"></a>Controller Objects</h1>","site":{"data":{}},"excerpt":"","more":"<p>  在软件开发工程中，我们常常用到架构模式，以及设计模式，良好的架构模式会让整个项目层次清晰，维护容易。我们来谈下MVC的架构模式在iOS中的使用。<br>   先简单介绍一下MVC这个模式,Model-View-Controller是我们比较常用的架构模式。这样的架构模式在一个应用程序，赋予了对象三种作用:model,view,和controller。这样不止定义了每个对象在程序中的角色，还有定义了各个对象之间的关系。三种类型的对象被抽象的划分，以及清楚的明确职责。简单来说，每个层级之间做好自己的事，不干预其他对象之间的关系，只关心我和其他层级之间的连接方式和开放的接口。具有一定的对象的集合在MVC模式中有时会被归类为层的例子，例如模型层。</p>\n<p> Cocoa框架中的核心设计就是MVC，当然在这一设计模式中有很多好处不言而喻。<br>模型的复用性<br>    许多模型对象在程序中可以被重复使用，他们的接口可以被更好的定义以及理解。<br>易用性和拓展性<br>    在一个工程中使用MVC会更好的扩展,此外Cocoa框架是基于MVC的架构，而且需要自定义的模型需要在其中扮演一种作用。</p>\n<h1 id=\"Apple中理想的MVC模式\"><a href=\"#Apple中理想的MVC模式\" class=\"headerlink\" title=\"Apple中理想的MVC模式\"></a>Apple中理想的MVC模式</h1><p><img src=\"/img/mvc.png\" title=\"mvc\"></p>\n<h1 id=\"Model-Objects\"><a href=\"#Model-Objects\" class=\"headerlink\" title=\"Model Objects\"></a>Model Objects</h1><p>模型对象根据应用程序的业务场景封装了特定的数据，并且定义操作的逻辑和计算处理数据。举个例子，一个模型对象可能表示游戏中的角色或者是通讯录中的联系人。它可能有一对一或者一对多的关系，有时一个应用程序的模型层实际上是一个或者多个对象的图表。更多应用程序中的模型是一种持久的状态（无论是作为文件或者数据库中），应该在数据转换到模型上之后加载到程序中。模型应该就是本身独立于项目的存在，将业务中的实体和类型理解成类和对象的关系应用到程序中。</p>\n<p>用户在View层操作的响应和输入的数据会通过controller来创建或者改变具体的实例模型对象。当一个模型对象改变的时候（比如网络请求后的数据拿到后）会去通知到controller对象来刷新对应的View对象。</p>\n<h1 id=\"View-Objects\"><a href=\"#View-Objects\" class=\"headerlink\" title=\"View Objects\"></a>View Objects</h1><h1 id=\"Controller-Objects\"><a href=\"#Controller-Objects\" class=\"headerlink\" title=\"Controller Objects\"></a>Controller Objects</h1>"},{"title":"函数响应式编程概念","date":"2017-01-10T07:50:12.000Z","_content":"","source":"_posts/函数响应式编程概念.md","raw":"---\ntitle: 函数响应式编程概念\ndate: 2017-01-10 15:50:12\ntags:\n---\n","slug":"函数响应式编程概念","published":1,"updated":"2017-01-10T07:50:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pg000e4x2nu440t9dd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"制作Pod类库","date":"2016-09-22T07:42:33.000Z","_content":"\t\n## 注册trunk(首先)\n 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新。trunk需要pod在0.33及以上版本，如果你不满足要求，打开Terminal使用ruby的gem命令更新pod:\n\n``` \n$ sudo gem install cocoapods\n```\n\n注册trunk\n\n```\n$ pod trunk register chaussonHi@gmail.com 'chausson'  --verbose\n```\n\n邮箱以及用户名请对号入座。用户名我使用的是Github上的用户名。\n--verbose参数是为了便于输出注册过程中的调试信息。执行上面的语句后，\n你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。\n点击邮件的链接就完成了trunk注册流程。\n使用下面命令向trunk服务器查询注册信息验证\n```\n$ pod trunk me\n```\n\n## 创建自己的github仓库\n CocoaPods都托管在github上(官方链接为：https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因 此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：\n \n<img src=\"/img/pod_image1.png\"  title=\"one\">\n\n<img src=\"/img/pod_image2.png\"  title=\"two\">\n\n上图中标了序号的共5处，对应的说明如下：\n\n* Repository name 仓库名称，这里写成CHAlertView，必填.(相应的库名)\n\n* Description仓库的描述信息，可选的.\n\n* 仓库的公开性,这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；\n\n* 是否创建一个默认的README文件一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；\n\n* 是否添加.gitignore文件.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；\n\n* 与license类型\n正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。\n\n## 二、clone仓库到本地\n为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：\n\n```\n$ git clone https://github.com/***.git\n```\n\n操作完成后，github上对应的文件都会拷贝到本地，目录结构为：\n\n<img src=\"/img/pod_image3.png\"  title=\"three\">\n\ngithub上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。\n后续我们的所有文件增、删、改都在这个目录下进行。\n## 三、向本地git仓库中添加创建Pods依赖库所需文件\n注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。\n\n1、后缀为.podspec文件\n该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的CHAlertView依赖库对应的文件名CHAlertView.podspec。\n\n1.1 如何创建podspec文件\n大家创建自己的podspec文件可以有两个途径：\n\n①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。\n\n②执行以下创建命令：\n\n```\n$ pod spec create CHAlertView \n```\n1.2 将文件导入克隆的文件夹\n\n1.3podspec文件内容\nCHAlertView.podspec的保存内容为:\n\n```\n         \n Pod::Spec.new do |s|\ns.name = 'CHEnvirSwitcherDemo'\ns.version = '0.0.1'\ns.license = 'MIT'\ns.summary = 'EnvironmentSwitcher for  iOS.'\ns.homepage = 'https://github.com/ChaussonORG/CHEnvirSwitcherDemo'\ns.authors = { 'Daxiongzyj' => '13761057550@163.com' }\ns.source = { :git => \"https://github.com/ChaussonORG/CHEnvirSwitcherDemo.git\", :tag => \"0.0.1\"}\ns.requires_arc = true\ns.ios.deployment_target = '8.0'\ns.source_files = \"CHEnvirSwitcherService\", \"*.{h,m}\"\nend\n\n  \n```\n<!-- <img src=\"/img/pod_image4.png\"  title=\"four\"> -->\n\n该文件是ruby文件，里面的条目都很容易知道含义。\n其中需要说明的又几个参数：\n\n1.通过在终端里输入命令 $ vim CHAlertView.podspec (相应的podspec文件)打开podspec文件,直接复制黏贴以上内容,修改相应的信息,千万别改动符号!很关键!!!\n\n2.s.license Pods依赖库使用的license类型，大家填上自己对应的选择即可。\n\n3.s.source_files 表示源文件的路径，注意这个路径是相对podspec文件而言的。这个地方是一个难点 \"CHEnvirSwitcherService\"是文件夹, \"*.{h,m}\"代表的是该文件夹内的.m文件与.h文件\n\n\n## 四、提交修改文件到github\n经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：\n\n1、上传步骤三中添加的文件\n执行以下命令：\n\n```\n$ git add .\n\n$ git commit -am \"Release 0.0.1\"\n\n$ git push origin master\n```\n\n1、pod验证\n执行以下命令：\n\n```\n$ set the new version to 0.0.1\n\n$ set the new tag to 0.0.1 \n```\n\n这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：\n\n```\n$ pod lib lint\n```\n\n如果一切正常，这条命令执行完后会出现下面的输出：\n\n```\n-> CHAlertView (0.0.1)\n\nCHAlertView passed validation.\n```\n\n到此，pod验证就结束了。\n需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。\n\n2、本地git仓库修改内容上传到github仓库\n依次执行以下命令：\n\n```\n$ git add . \n\n$ git tag ‘0.0.1\n\n$ git push --tags \n\n$ git push origin master\n```\n\n上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：\n\n<img src=\"/img/pod_image5.png\"  title=\"five\">\n\n## 提交你的Podspec树干\n\n```\n$  pod trunk push CHAlertView.podspec\n```\n\n## 六、查看我们自己创建的Pods依赖库\n查看是否成功可以通过cocoapods官网搜索<https://cocoapods.org>,如果显示下图表示成功\n\n<img src=\"/img/pod_image6.png\"  title=\"six\">\n\n","source":"_posts/制作Pod类库.md","raw":"---\ntitle: 制作Pod类库\ncategories: 环境搭建 #分类\ndate: 2016-09-22 15:42:33\n#tags: [博客] #PodSpec\ntags:\n---\n\t\n## 注册trunk(首先)\n 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新。trunk需要pod在0.33及以上版本，如果你不满足要求，打开Terminal使用ruby的gem命令更新pod:\n\n``` \n$ sudo gem install cocoapods\n```\n\n注册trunk\n\n```\n$ pod trunk register chaussonHi@gmail.com 'chausson'  --verbose\n```\n\n邮箱以及用户名请对号入座。用户名我使用的是Github上的用户名。\n--verbose参数是为了便于输出注册过程中的调试信息。执行上面的语句后，\n你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。\n点击邮件的链接就完成了trunk注册流程。\n使用下面命令向trunk服务器查询注册信息验证\n```\n$ pod trunk me\n```\n\n## 创建自己的github仓库\n CocoaPods都托管在github上(官方链接为：https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因 此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：\n \n<img src=\"/img/pod_image1.png\"  title=\"one\">\n\n<img src=\"/img/pod_image2.png\"  title=\"two\">\n\n上图中标了序号的共5处，对应的说明如下：\n\n* Repository name 仓库名称，这里写成CHAlertView，必填.(相应的库名)\n\n* Description仓库的描述信息，可选的.\n\n* 仓库的公开性,这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；\n\n* 是否创建一个默认的README文件一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；\n\n* 是否添加.gitignore文件.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；\n\n* 与license类型\n正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。\n\n## 二、clone仓库到本地\n为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：\n\n```\n$ git clone https://github.com/***.git\n```\n\n操作完成后，github上对应的文件都会拷贝到本地，目录结构为：\n\n<img src=\"/img/pod_image3.png\"  title=\"three\">\n\ngithub上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。\n后续我们的所有文件增、删、改都在这个目录下进行。\n## 三、向本地git仓库中添加创建Pods依赖库所需文件\n注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。\n\n1、后缀为.podspec文件\n该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的CHAlertView依赖库对应的文件名CHAlertView.podspec。\n\n1.1 如何创建podspec文件\n大家创建自己的podspec文件可以有两个途径：\n\n①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。\n\n②执行以下创建命令：\n\n```\n$ pod spec create CHAlertView \n```\n1.2 将文件导入克隆的文件夹\n\n1.3podspec文件内容\nCHAlertView.podspec的保存内容为:\n\n```\n         \n Pod::Spec.new do |s|\ns.name = 'CHEnvirSwitcherDemo'\ns.version = '0.0.1'\ns.license = 'MIT'\ns.summary = 'EnvironmentSwitcher for  iOS.'\ns.homepage = 'https://github.com/ChaussonORG/CHEnvirSwitcherDemo'\ns.authors = { 'Daxiongzyj' => '13761057550@163.com' }\ns.source = { :git => \"https://github.com/ChaussonORG/CHEnvirSwitcherDemo.git\", :tag => \"0.0.1\"}\ns.requires_arc = true\ns.ios.deployment_target = '8.0'\ns.source_files = \"CHEnvirSwitcherService\", \"*.{h,m}\"\nend\n\n  \n```\n<!-- <img src=\"/img/pod_image4.png\"  title=\"four\"> -->\n\n该文件是ruby文件，里面的条目都很容易知道含义。\n其中需要说明的又几个参数：\n\n1.通过在终端里输入命令 $ vim CHAlertView.podspec (相应的podspec文件)打开podspec文件,直接复制黏贴以上内容,修改相应的信息,千万别改动符号!很关键!!!\n\n2.s.license Pods依赖库使用的license类型，大家填上自己对应的选择即可。\n\n3.s.source_files 表示源文件的路径，注意这个路径是相对podspec文件而言的。这个地方是一个难点 \"CHEnvirSwitcherService\"是文件夹, \"*.{h,m}\"代表的是该文件夹内的.m文件与.h文件\n\n\n## 四、提交修改文件到github\n经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：\n\n1、上传步骤三中添加的文件\n执行以下命令：\n\n```\n$ git add .\n\n$ git commit -am \"Release 0.0.1\"\n\n$ git push origin master\n```\n\n1、pod验证\n执行以下命令：\n\n```\n$ set the new version to 0.0.1\n\n$ set the new tag to 0.0.1 \n```\n\n这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：\n\n```\n$ pod lib lint\n```\n\n如果一切正常，这条命令执行完后会出现下面的输出：\n\n```\n-> CHAlertView (0.0.1)\n\nCHAlertView passed validation.\n```\n\n到此，pod验证就结束了。\n需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。\n\n2、本地git仓库修改内容上传到github仓库\n依次执行以下命令：\n\n```\n$ git add . \n\n$ git tag ‘0.0.1\n\n$ git push --tags \n\n$ git push origin master\n```\n\n上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：\n\n<img src=\"/img/pod_image5.png\"  title=\"five\">\n\n## 提交你的Podspec树干\n\n```\n$  pod trunk push CHAlertView.podspec\n```\n\n## 六、查看我们自己创建的Pods依赖库\n查看是否成功可以通过cocoapods官网搜索<https://cocoapods.org>,如果显示下图表示成功\n\n<img src=\"/img/pod_image6.png\"  title=\"six\">\n\n","slug":"制作Pod类库","published":1,"updated":"2016-10-10T08:41:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pj000h4x2nh25fmtth","content":"<h2 id=\"注册trunk-首先\"><a href=\"#注册trunk-首先\" class=\"headerlink\" title=\"注册trunk(首先)\"></a>注册trunk(首先)</h2><p> 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新。trunk需要pod在0.33及以上版本，如果你不满足要求，打开Terminal使用ruby的gem命令更新pod:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>\n<p>注册trunk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod trunk register chaussonHi@gmail.com &apos;chausson&apos;  --verbose</span><br></pre></td></tr></table></figure>\n<p>邮箱以及用户名请对号入座。用户名我使用的是Github上的用户名。<br>–verbose参数是为了便于输出注册过程中的调试信息。执行上面的语句后，<br>你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。<br>点击邮件的链接就完成了trunk注册流程。<br>使用下面命令向trunk服务器查询注册信息验证<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建自己的github仓库\"><a href=\"#创建自己的github仓库\" class=\"headerlink\" title=\"创建自己的github仓库\"></a>创建自己的github仓库</h2><p> CocoaPods都托管在github上(官方链接为：<a href=\"https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因\" target=\"_blank\" rel=\"noopener\">https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因</a> 此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：</p>\n<p><img src=\"/img/pod_image1.png\" title=\"one\"></p>\n<p><img src=\"/img/pod_image2.png\" title=\"two\"></p>\n<p>上图中标了序号的共5处，对应的说明如下：</p>\n<ul>\n<li><p>Repository name 仓库名称，这里写成CHAlertView，必填.(相应的库名)</p>\n</li>\n<li><p>Description仓库的描述信息，可选的.</p>\n</li>\n<li><p>仓库的公开性,这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；</p>\n</li>\n<li><p>是否创建一个默认的README文件一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；</p>\n</li>\n<li><p>是否添加.gitignore文件.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；</p>\n</li>\n<li><p>与license类型<br>正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>\n</li>\n</ul>\n<h2 id=\"二、clone仓库到本地\"><a href=\"#二、clone仓库到本地\" class=\"headerlink\" title=\"二、clone仓库到本地\"></a>二、clone仓库到本地</h2><p>为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/***.git</span><br></pre></td></tr></table></figure>\n<p>操作完成后，github上对应的文件都会拷贝到本地，目录结构为：</p>\n<p><img src=\"/img/pod_image3.png\" title=\"three\"></p>\n<p>github上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。<br>后续我们的所有文件增、删、改都在这个目录下进行。</p>\n<h2 id=\"三、向本地git仓库中添加创建Pods依赖库所需文件\"><a href=\"#三、向本地git仓库中添加创建Pods依赖库所需文件\" class=\"headerlink\" title=\"三、向本地git仓库中添加创建Pods依赖库所需文件\"></a>三、向本地git仓库中添加创建Pods依赖库所需文件</h2><p>注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。</p>\n<p>1、后缀为.podspec文件<br>该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的CHAlertView依赖库对应的文件名CHAlertView.podspec。</p>\n<p>1.1 如何创建podspec文件<br>大家创建自己的podspec文件可以有两个途径：</p>\n<p>①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。</p>\n<p>②执行以下创建命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create CHAlertView</span><br></pre></td></tr></table></figure>\n<p>1.2 将文件导入克隆的文件夹</p>\n<p>1.3podspec文件内容<br>CHAlertView.podspec的保存内容为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         </span><br><span class=\"line\"> Pod::Spec.new do |s|</span><br><span class=\"line\">s.name = &apos;CHEnvirSwitcherDemo&apos;</span><br><span class=\"line\">s.version = &apos;0.0.1&apos;</span><br><span class=\"line\">s.license = &apos;MIT&apos;</span><br><span class=\"line\">s.summary = &apos;EnvironmentSwitcher for  iOS.&apos;</span><br><span class=\"line\">s.homepage = &apos;https://github.com/ChaussonORG/CHEnvirSwitcherDemo&apos;</span><br><span class=\"line\">s.authors = &#123; &apos;Daxiongzyj&apos; =&gt; &apos;13761057550@163.com&apos; &#125;</span><br><span class=\"line\">s.source = &#123; :git =&gt; &quot;https://github.com/ChaussonORG/CHEnvirSwitcherDemo.git&quot;, :tag =&gt; &quot;0.0.1&quot;&#125;</span><br><span class=\"line\">s.requires_arc = true</span><br><span class=\"line\">s.ios.deployment_target = &apos;8.0&apos;</span><br><span class=\"line\">s.source_files = &quot;CHEnvirSwitcherService&quot;, &quot;*.&#123;h,m&#125;&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<!-- <img src=\"/img/pod_image4.png\"  title=\"four\"> -->\n<p>该文件是ruby文件，里面的条目都很容易知道含义。<br>其中需要说明的又几个参数：</p>\n<p>1.通过在终端里输入命令 $ vim CHAlertView.podspec (相应的podspec文件)打开podspec文件,直接复制黏贴以上内容,修改相应的信息,千万别改动符号!很关键!!!</p>\n<p>2.s.license Pods依赖库使用的license类型，大家填上自己对应的选择即可。</p>\n<p>3.s.source_files 表示源文件的路径，注意这个路径是相对podspec文件而言的。这个地方是一个难点 “CHEnvirSwitcherService”是文件夹, “*.{h,m}”代表的是该文件夹内的.m文件与.h文件</p>\n<h2 id=\"四、提交修改文件到github\"><a href=\"#四、提交修改文件到github\" class=\"headerlink\" title=\"四、提交修改文件到github\"></a>四、提交修改文件到github</h2><p>经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：</p>\n<p>1、上传步骤三中添加的文件<br>执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -am &quot;Release 0.0.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>1、pod验证<br>执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ set the new version to 0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ set the new tag to 0.0.1</span><br></pre></td></tr></table></figure>\n<p>这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br></pre></td></tr></table></figure>\n<p>如果一切正常，这条命令执行完后会出现下面的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; CHAlertView (0.0.1)</span><br><span class=\"line\"></span><br><span class=\"line\">CHAlertView passed validation.</span><br></pre></td></tr></table></figure>\n<p>到此，pod验证就结束了。<br>需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。</p>\n<p>2、本地git仓库修改内容上传到github仓库<br>依次执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add . </span><br><span class=\"line\"></span><br><span class=\"line\">$ git tag ‘0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push --tags </span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：</p>\n<p><img src=\"/img/pod_image5.png\" title=\"five\"></p>\n<h2 id=\"提交你的Podspec树干\"><a href=\"#提交你的Podspec树干\" class=\"headerlink\" title=\"提交你的Podspec树干\"></a>提交你的Podspec树干</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  pod trunk push CHAlertView.podspec</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、查看我们自己创建的Pods依赖库\"><a href=\"#六、查看我们自己创建的Pods依赖库\" class=\"headerlink\" title=\"六、查看我们自己创建的Pods依赖库\"></a>六、查看我们自己创建的Pods依赖库</h2><p>查看是否成功可以通过cocoapods官网搜索<a href=\"https://cocoapods.org\" target=\"_blank\" rel=\"noopener\">https://cocoapods.org</a>,如果显示下图表示成功</p>\n<p><img src=\"/img/pod_image6.png\" title=\"six\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"注册trunk-首先\"><a href=\"#注册trunk-首先\" class=\"headerlink\" title=\"注册trunk(首先)\"></a>注册trunk(首先)</h2><p> 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新。trunk需要pod在0.33及以上版本，如果你不满足要求，打开Terminal使用ruby的gem命令更新pod:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>\n<p>注册trunk</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod trunk register chaussonHi@gmail.com &apos;chausson&apos;  --verbose</span><br></pre></td></tr></table></figure>\n<p>邮箱以及用户名请对号入座。用户名我使用的是Github上的用户名。<br>–verbose参数是为了便于输出注册过程中的调试信息。执行上面的语句后，<br>你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。<br>点击邮件的链接就完成了trunk注册流程。<br>使用下面命令向trunk服务器查询注册信息验证<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod trunk me</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建自己的github仓库\"><a href=\"#创建自己的github仓库\" class=\"headerlink\" title=\"创建自己的github仓库\"></a>创建自己的github仓库</h2><p> CocoaPods都托管在github上(官方链接为：<a href=\"https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因\" target=\"_blank\" rel=\"noopener\">https://github.com/CocoaPods)，所有的Pods依赖库也都依赖github，因</a> 此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：</p>\n<p><img src=\"/img/pod_image1.png\" title=\"one\"></p>\n<p><img src=\"/img/pod_image2.png\" title=\"two\"></p>\n<p>上图中标了序号的共5处，对应的说明如下：</p>\n<ul>\n<li><p>Repository name 仓库名称，这里写成CHAlertView，必填.(相应的库名)</p>\n</li>\n<li><p>Description仓库的描述信息，可选的.</p>\n</li>\n<li><p>仓库的公开性,这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；</p>\n</li>\n<li><p>是否创建一个默认的README文件一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；</p>\n</li>\n<li><p>是否添加.gitignore文件.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；</p>\n</li>\n<li><p>与license类型<br>正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>\n</li>\n</ul>\n<h2 id=\"二、clone仓库到本地\"><a href=\"#二、clone仓库到本地\" class=\"headerlink\" title=\"二、clone仓库到本地\"></a>二、clone仓库到本地</h2><p>为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/***.git</span><br></pre></td></tr></table></figure>\n<p>操作完成后，github上对应的文件都会拷贝到本地，目录结构为：</p>\n<p><img src=\"/img/pod_image3.png\" title=\"three\"></p>\n<p>github上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。<br>后续我们的所有文件增、删、改都在这个目录下进行。</p>\n<h2 id=\"三、向本地git仓库中添加创建Pods依赖库所需文件\"><a href=\"#三、向本地git仓库中添加创建Pods依赖库所需文件\" class=\"headerlink\" title=\"三、向本地git仓库中添加创建Pods依赖库所需文件\"></a>三、向本地git仓库中添加创建Pods依赖库所需文件</h2><p>注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。</p>\n<p>1、后缀为.podspec文件<br>该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的CHAlertView依赖库对应的文件名CHAlertView.podspec。</p>\n<p>1.1 如何创建podspec文件<br>大家创建自己的podspec文件可以有两个途径：</p>\n<p>①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。</p>\n<p>②执行以下创建命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod spec create CHAlertView</span><br></pre></td></tr></table></figure>\n<p>1.2 将文件导入克隆的文件夹</p>\n<p>1.3podspec文件内容<br>CHAlertView.podspec的保存内容为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         </span><br><span class=\"line\"> Pod::Spec.new do |s|</span><br><span class=\"line\">s.name = &apos;CHEnvirSwitcherDemo&apos;</span><br><span class=\"line\">s.version = &apos;0.0.1&apos;</span><br><span class=\"line\">s.license = &apos;MIT&apos;</span><br><span class=\"line\">s.summary = &apos;EnvironmentSwitcher for  iOS.&apos;</span><br><span class=\"line\">s.homepage = &apos;https://github.com/ChaussonORG/CHEnvirSwitcherDemo&apos;</span><br><span class=\"line\">s.authors = &#123; &apos;Daxiongzyj&apos; =&gt; &apos;13761057550@163.com&apos; &#125;</span><br><span class=\"line\">s.source = &#123; :git =&gt; &quot;https://github.com/ChaussonORG/CHEnvirSwitcherDemo.git&quot;, :tag =&gt; &quot;0.0.1&quot;&#125;</span><br><span class=\"line\">s.requires_arc = true</span><br><span class=\"line\">s.ios.deployment_target = &apos;8.0&apos;</span><br><span class=\"line\">s.source_files = &quot;CHEnvirSwitcherService&quot;, &quot;*.&#123;h,m&#125;&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<!-- <img src=\"/img/pod_image4.png\"  title=\"four\"> -->\n<p>该文件是ruby文件，里面的条目都很容易知道含义。<br>其中需要说明的又几个参数：</p>\n<p>1.通过在终端里输入命令 $ vim CHAlertView.podspec (相应的podspec文件)打开podspec文件,直接复制黏贴以上内容,修改相应的信息,千万别改动符号!很关键!!!</p>\n<p>2.s.license Pods依赖库使用的license类型，大家填上自己对应的选择即可。</p>\n<p>3.s.source_files 表示源文件的路径，注意这个路径是相对podspec文件而言的。这个地方是一个难点 “CHEnvirSwitcherService”是文件夹, “*.{h,m}”代表的是该文件夹内的.m文件与.h文件</p>\n<h2 id=\"四、提交修改文件到github\"><a href=\"#四、提交修改文件到github\" class=\"headerlink\" title=\"四、提交修改文件到github\"></a>四、提交修改文件到github</h2><p>经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：</p>\n<p>1、上传步骤三中添加的文件<br>执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -am &quot;Release 0.0.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>1、pod验证<br>执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ set the new version to 0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ set the new tag to 0.0.1</span><br></pre></td></tr></table></figure>\n<p>这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pod lib lint</span><br></pre></td></tr></table></figure>\n<p>如果一切正常，这条命令执行完后会出现下面的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; CHAlertView (0.0.1)</span><br><span class=\"line\"></span><br><span class=\"line\">CHAlertView passed validation.</span><br></pre></td></tr></table></figure>\n<p>到此，pod验证就结束了。<br>需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。</p>\n<p>2、本地git仓库修改内容上传到github仓库<br>依次执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add . </span><br><span class=\"line\"></span><br><span class=\"line\">$ git tag ‘0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push --tags </span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<p>上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：</p>\n<p><img src=\"/img/pod_image5.png\" title=\"five\"></p>\n<h2 id=\"提交你的Podspec树干\"><a href=\"#提交你的Podspec树干\" class=\"headerlink\" title=\"提交你的Podspec树干\"></a>提交你的Podspec树干</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  pod trunk push CHAlertView.podspec</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、查看我们自己创建的Pods依赖库\"><a href=\"#六、查看我们自己创建的Pods依赖库\" class=\"headerlink\" title=\"六、查看我们自己创建的Pods依赖库\"></a>六、查看我们自己创建的Pods依赖库</h2><p>查看是否成功可以通过cocoapods官网搜索<a href=\"https://cocoapods.org\" target=\"_blank\" rel=\"noopener\">https://cocoapods.org</a>,如果显示下图表示成功</p>\n<p><img src=\"/img/pod_image6.png\" title=\"six\"></p>\n"},{"title":"如何拥有一套属于自己的技术博客网站","_content":"## 序\n现在终于搭建完了自己的技术博客网站,虽然技术上没有什么难度可言，但光搭建环境和整合资源就花了很久时间。所以目前把自己所搜集的资源快捷方法给大家，大家可以根据教程尝试搭建属于自己的技术博客网站。\n\n## 安装Node.Js\n目前我的博客是用Hexo搭建的，这里有必要稍微说一下Hexo的原理。\n\nHexo是一款基于Node.js的静态博客框架,通过Hexo的命令生成静态文件，然后将静态文件部署到远端服务器。\n\nNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。\n\n安装方法上官网下载[Node.Js](http://nodejs.cn/),安装之后即可使用，我目前安装的版本是4.4。\n\n由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 \"npm -v\" 来测试是否成功安装。命令如下，出现版本提示表示安装成功:\n\n``` bash\n$ npm -v\n2.3.0\n```\n## 安装Hexo\n\n基于NPM命令，使用如下方法可以安装Hexo:\n\n``` bash\n$ sudo npm install -g hexo\n```\n部署Hexo\n\n``` bash\n$ hexo init\n```\n注：这个命令会初始化博客的目录，所以，执行这个命令时，在你想创建的目录下执行，就自动生成到对应目录下\n执行命令生，会在当前命令的路径下，生成以下文件：\n``` bash\n.\n├── _config.yml\n├── node_modules\n├── scaffolds\n├── scripts\n├── source\n|   ├── _drafts\n|   └── _posts\n├── themes\n└── package.json\n```\n### Hexo 文件目录介绍\n* public：执行hexo generate命令，输出的静态网页内容目录\n* scaffolds：layout模板文件目录，其中的md文件可以添加编辑\n* scripts：扩展脚本目录，这里可以自定义一些javascript脚本\n* source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。\n* _drafts：草稿文章\n* _posts：发布文章\n* themes：主题文件目录\n* _config.yml：全局配置文件，大多数的设置都在这里\n* package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮\n\n## Hexo命令\nHexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。\n\n* 全局设置\n在你博客目录下有一个文件名_config.yml，打开可以配置信息。\n\n* 局部页面\n在你博客目录下 \\themes\\你使用的主题\\_config.yml\n\n* Hexo常用命令\n``` bash\n$ hexo new \"postName\"   or hexo n \"postName\"    #新建文章\n$ hexo new page \"pageName\"      #新建页面\n$ hexo generate or hexo g       #生成静态页面至public目录\n$ hexo server   or hexo s       #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n$ hexo deploy   or hexo d       #将.deploy目录部署到GitHub\n```\n* 还可以复合命令：\n``` bash\n$ hexo deploy -g\n$ hexo server -g\n\n```\n有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧\n``` bash\n$ hexo clean\n```\n\n当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。\n\n注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？\n在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。\n\n## 配置Github\n* 安装Git (把本地的hexo内容提交到github)\n* 申请GitHub账号 (是用来做博客的远程创库、域名、服务器等)\n* 需要在GithHub上配置SSH Keys,如果不了解SSH Keys详见 [SSHKey的作用和生成](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&ch=&tn=baiduerr&bar=&wd=SSHKeys生成)\n* 在github上建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】\n\n## 关联Github\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo:https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch:master\n\n然后执行命令：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n有的type是github,我现在的版本是hexo: 3.1.1，执行命令\n``` bash\n$ hexo -vsersion\n```\n貌似3.0后全部改成我上面这种格式了。\n\n然后，执行配置命令：\n``` bash\n$ hexo deploy\n```\n## 报错总结\nERROR Deployer not found: git 或者 ERROR Deployer not found: github\n\n解决方法： npm install hexo-deployer-git --save\n\n如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：\n\nrm-rf.DS_Store\n\nERROR Plugin load failed: hexo-server\n\n原因：\n\nBesides,utilities are separated into a standalone module.hexo.util is not reachable anymore.\n\n解决方法，执行命令：\n``` bash\n$ sudo npm install hexo-server\n```\n执行命令hexo server，提示：Usage: hexo ....\n\n原因：\n\n我认为是没有生成本地服务\n\n解决方法，执行命令：\n``` bash\n$ npm install hexo-server--save\n```\n提示：hexo-server@0.1.2 node_modules/hexo-server\n\n....\n\n表示成功了参考\n\n这个时候再执行：\n``` bash\n$ hexo-server\n```\n得到:\n\nINFOHexois running at http://0.0.0.0:4000/.PressCtrl+C to stop.\n\n这个时候再点击http://0.0.0.0:4000\n\n## 脚本发布\n如果发布调用Hexo deploy 失败，可以尝试使用脚本部署的方式发布到Github，以下是脚本命令:\n``` bash\n$ cd /Users/Chausson/Documents/Blog #这里指的是Hexo创建文件夹的路径\n$ hexo clean\n$ hexo generate\n$ cd public\n\n$ git init\n$ git add .\n$ git commit -m \"update at `date` \"\n\n$ git remote add origin git@github.com:chausson/chausson.github.io\n$ echo \"### Pushing to Github...\"\n$ git push origin master -f\n$ echo \"### Done\"\n```\n\n\n\n\n\n\n","source":"_posts/如何建立属于自己的技术博客网站.md","raw":"---\ntitle: 如何拥有一套属于自己的技术博客网站\ncategories: 环境搭建 #分类\n#tags: [博客] #文章标签，可空，多标签请用格式，注意:后面有个空格\n#description: 附加一段文章摘要，字数最好在140字以内。\n---\n## 序\n现在终于搭建完了自己的技术博客网站,虽然技术上没有什么难度可言，但光搭建环境和整合资源就花了很久时间。所以目前把自己所搜集的资源快捷方法给大家，大家可以根据教程尝试搭建属于自己的技术博客网站。\n\n## 安装Node.Js\n目前我的博客是用Hexo搭建的，这里有必要稍微说一下Hexo的原理。\n\nHexo是一款基于Node.js的静态博客框架,通过Hexo的命令生成静态文件，然后将静态文件部署到远端服务器。\n\nNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。\n\n安装方法上官网下载[Node.Js](http://nodejs.cn/),安装之后即可使用，我目前安装的版本是4.4。\n\n由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 \"npm -v\" 来测试是否成功安装。命令如下，出现版本提示表示安装成功:\n\n``` bash\n$ npm -v\n2.3.0\n```\n## 安装Hexo\n\n基于NPM命令，使用如下方法可以安装Hexo:\n\n``` bash\n$ sudo npm install -g hexo\n```\n部署Hexo\n\n``` bash\n$ hexo init\n```\n注：这个命令会初始化博客的目录，所以，执行这个命令时，在你想创建的目录下执行，就自动生成到对应目录下\n执行命令生，会在当前命令的路径下，生成以下文件：\n``` bash\n.\n├── _config.yml\n├── node_modules\n├── scaffolds\n├── scripts\n├── source\n|   ├── _drafts\n|   └── _posts\n├── themes\n└── package.json\n```\n### Hexo 文件目录介绍\n* public：执行hexo generate命令，输出的静态网页内容目录\n* scaffolds：layout模板文件目录，其中的md文件可以添加编辑\n* scripts：扩展脚本目录，这里可以自定义一些javascript脚本\n* source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。\n* _drafts：草稿文章\n* _posts：发布文章\n* themes：主题文件目录\n* _config.yml：全局配置文件，大多数的设置都在这里\n* package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮\n\n## Hexo命令\nHexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。\n\n* 全局设置\n在你博客目录下有一个文件名_config.yml，打开可以配置信息。\n\n* 局部页面\n在你博客目录下 \\themes\\你使用的主题\\_config.yml\n\n* Hexo常用命令\n``` bash\n$ hexo new \"postName\"   or hexo n \"postName\"    #新建文章\n$ hexo new page \"pageName\"      #新建页面\n$ hexo generate or hexo g       #生成静态页面至public目录\n$ hexo server   or hexo s       #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n$ hexo deploy   or hexo d       #将.deploy目录部署到GitHub\n```\n* 还可以复合命令：\n``` bash\n$ hexo deploy -g\n$ hexo server -g\n\n```\n有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧\n``` bash\n$ hexo clean\n```\n\n当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。\n\n注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？\n在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。\n\n## 配置Github\n* 安装Git (把本地的hexo内容提交到github)\n* 申请GitHub账号 (是用来做博客的远程创库、域名、服务器等)\n* 需要在GithHub上配置SSH Keys,如果不了解SSH Keys详见 [SSHKey的作用和生成](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&ch=&tn=baiduerr&bar=&wd=SSHKeys生成)\n* 在github上建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】\n\n## 关联Github\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo:https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch:master\n\n然后执行命令：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n有的type是github,我现在的版本是hexo: 3.1.1，执行命令\n``` bash\n$ hexo -vsersion\n```\n貌似3.0后全部改成我上面这种格式了。\n\n然后，执行配置命令：\n``` bash\n$ hexo deploy\n```\n## 报错总结\nERROR Deployer not found: git 或者 ERROR Deployer not found: github\n\n解决方法： npm install hexo-deployer-git --save\n\n如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：\n\nrm-rf.DS_Store\n\nERROR Plugin load failed: hexo-server\n\n原因：\n\nBesides,utilities are separated into a standalone module.hexo.util is not reachable anymore.\n\n解决方法，执行命令：\n``` bash\n$ sudo npm install hexo-server\n```\n执行命令hexo server，提示：Usage: hexo ....\n\n原因：\n\n我认为是没有生成本地服务\n\n解决方法，执行命令：\n``` bash\n$ npm install hexo-server--save\n```\n提示：hexo-server@0.1.2 node_modules/hexo-server\n\n....\n\n表示成功了参考\n\n这个时候再执行：\n``` bash\n$ hexo-server\n```\n得到:\n\nINFOHexois running at http://0.0.0.0:4000/.PressCtrl+C to stop.\n\n这个时候再点击http://0.0.0.0:4000\n\n## 脚本发布\n如果发布调用Hexo deploy 失败，可以尝试使用脚本部署的方式发布到Github，以下是脚本命令:\n``` bash\n$ cd /Users/Chausson/Documents/Blog #这里指的是Hexo创建文件夹的路径\n$ hexo clean\n$ hexo generate\n$ cd public\n\n$ git init\n$ git add .\n$ git commit -m \"update at `date` \"\n\n$ git remote add origin git@github.com:chausson/chausson.github.io\n$ echo \"### Pushing to Github...\"\n$ git push origin master -f\n$ echo \"### Done\"\n```\n\n\n\n\n\n\n","slug":"如何建立属于自己的技术博客网站","published":1,"date":"2016-06-01T10:15:38.000Z","updated":"2016-06-01T10:15:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pl000j4x2n82pdwcb9","content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>现在终于搭建完了自己的技术博客网站,虽然技术上没有什么难度可言，但光搭建环境和整合资源就花了很久时间。所以目前把自己所搜集的资源快捷方法给大家，大家可以根据教程尝试搭建属于自己的技术博客网站。</p>\n<h2 id=\"安装Node-Js\"><a href=\"#安装Node-Js\" class=\"headerlink\" title=\"安装Node.Js\"></a>安装Node.Js</h2><p>目前我的博客是用Hexo搭建的，这里有必要稍微说一下Hexo的原理。</p>\n<p>Hexo是一款基于Node.js的静态博客框架,通过Hexo的命令生成静态文件，然后将静态文件部署到远端服务器。</p>\n<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。</p>\n<p>安装方法上官网下载<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">Node.Js</a>,安装之后即可使用，我目前安装的版本是4.4。</p>\n<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm -v</span><br><span class=\"line\">2.3.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>基于NPM命令，使用如下方法可以安装Hexo:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>部署Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n<p>注：这个命令会初始化博客的目录，所以，执行这个命令时，在你想创建的目录下执行，就自动生成到对应目录下<br>执行命令生，会在当前命令的路径下，生成以下文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">├── <span class=\"built_in\">source</span></span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">├── themes</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Hexo-文件目录介绍\"><a href=\"#Hexo-文件目录介绍\" class=\"headerlink\" title=\"Hexo 文件目录介绍\"></a>Hexo 文件目录介绍</h3><ul>\n<li>public：执行hexo generate命令，输出的静态网页内容目录</li>\n<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>\n<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>\n<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li>\n<li>_drafts：草稿文章</li>\n<li>_posts：发布文章</li>\n<li>themes：主题文件目录</li>\n<li>_config.yml：全局配置文件，大多数的设置都在这里</li>\n<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>\n</ul>\n<h2 id=\"Hexo命令\"><a href=\"#Hexo命令\" class=\"headerlink\" title=\"Hexo命令\"></a>Hexo命令</h2><p>Hexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。</p>\n<ul>\n<li><p>全局设置<br>在你博客目录下有一个文件名_config.yml，打开可以配置信息。</p>\n</li>\n<li><p>局部页面<br>在你博客目录下 \\themes\\你使用的主题_config.yml</p>\n</li>\n<li><p>Hexo常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span>   or hexo n <span class=\"string\">\"postName\"</span>    <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span>      <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">$ hexo generate or hexo g       <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">$ hexo server   or hexo s       <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">$ hexo deploy   or hexo d       <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>还可以复合命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy -g</span><br><span class=\"line\">$ hexo server -g</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。</p>\n<p>注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？<br>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p>\n<h2 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h2><ul>\n<li>安装Git (把本地的hexo内容提交到github)</li>\n<li>申请GitHub账号 (是用来做博客的远程创库、域名、服务器等)</li>\n<li>需要在GithHub上配置SSH Keys,如果不了解SSH Keys详见 <a href=\"https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;ch=&amp;tn=baiduerr&amp;bar=&amp;wd=SSHKeys生成\" target=\"_blank\" rel=\"noopener\">SSHKey的作用和生成</a></li>\n<li>在github上建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</li>\n</ul>\n<h2 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h2><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo:https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch:master\n</code></pre><p>然后执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>有的type是github,我现在的版本是hexo: 3.1.1，执行命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -vsersion</span><br></pre></td></tr></table></figure></p>\n<p>貌似3.0后全部改成我上面这种格式了。</p>\n<p>然后，执行配置命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"报错总结\"><a href=\"#报错总结\" class=\"headerlink\" title=\"报错总结\"></a>报错总结</h2><p>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</p>\n<p>解决方法： npm install hexo-deployer-git –save</p>\n<p>如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</p>\n<p>rm-rf.DS_Store</p>\n<p>ERROR Plugin load failed: hexo-server</p>\n<p>原因：</p>\n<p>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</p>\n<p>解决方法，执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install hexo-server</span><br></pre></td></tr></table></figure></p>\n<p>执行命令hexo server，提示：Usage: hexo ….</p>\n<p>原因：</p>\n<p>我认为是没有生成本地服务</p>\n<p>解决方法，执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-server--save</span><br></pre></td></tr></table></figure></p>\n<p>提示：hexo-server@0.1.2 node_modules/hexo-server</p>\n<p>….</p>\n<p>表示成功了参考</p>\n<p>这个时候再执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo-server</span><br></pre></td></tr></table></figure></p>\n<p>得到:</p>\n<p>INFOHexois running at <a href=\"http://0.0.0.0:4000/.PressCtrl+C\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000/.PressCtrl+C</a> to stop.</p>\n<p>这个时候再点击<a href=\"http://0.0.0.0:4000\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000</a></p>\n<h2 id=\"脚本发布\"><a href=\"#脚本发布\" class=\"headerlink\" title=\"脚本发布\"></a>脚本发布</h2><p>如果发布调用Hexo deploy 失败，可以尝试使用脚本部署的方式发布到Github，以下是脚本命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /Users/Chausson/Documents/B<span class=\"built_in\">log</span> <span class=\"comment\">#这里指的是Hexo创建文件夹的路径</span></span><br><span class=\"line\">$ hexo clean</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> public</span><br><span class=\"line\"></span><br><span class=\"line\">$ git init</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"update at `date` \"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git remote add origin git@github.com:chausson/chausson.github.io</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"### Pushing to Github...\"</span></span><br><span class=\"line\">$ git push origin master <span class=\"_\">-f</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"### Done\"</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>现在终于搭建完了自己的技术博客网站,虽然技术上没有什么难度可言，但光搭建环境和整合资源就花了很久时间。所以目前把自己所搜集的资源快捷方法给大家，大家可以根据教程尝试搭建属于自己的技术博客网站。</p>\n<h2 id=\"安装Node-Js\"><a href=\"#安装Node-Js\" class=\"headerlink\" title=\"安装Node.Js\"></a>安装Node.Js</h2><p>目前我的博客是用Hexo搭建的，这里有必要稍微说一下Hexo的原理。</p>\n<p>Hexo是一款基于Node.js的静态博客框架,通过Hexo的命令生成静态文件，然后将静态文件部署到远端服务器。</p>\n<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。</p>\n<p>安装方法上官网下载<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">Node.Js</a>,安装之后即可使用，我目前安装的版本是4.4。</p>\n<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm -v</span><br><span class=\"line\">2.3.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>基于NPM命令，使用如下方法可以安装Hexo:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>部署Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n<p>注：这个命令会初始化博客的目录，所以，执行这个命令时，在你想创建的目录下执行，就自动生成到对应目录下<br>执行命令生，会在当前命令的路径下，生成以下文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">├── <span class=\"built_in\">source</span></span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">├── themes</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Hexo-文件目录介绍\"><a href=\"#Hexo-文件目录介绍\" class=\"headerlink\" title=\"Hexo 文件目录介绍\"></a>Hexo 文件目录介绍</h3><ul>\n<li>public：执行hexo generate命令，输出的静态网页内容目录</li>\n<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>\n<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>\n<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li>\n<li>_drafts：草稿文章</li>\n<li>_posts：发布文章</li>\n<li>themes：主题文件目录</li>\n<li>_config.yml：全局配置文件，大多数的设置都在这里</li>\n<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>\n</ul>\n<h2 id=\"Hexo命令\"><a href=\"#Hexo命令\" class=\"headerlink\" title=\"Hexo命令\"></a>Hexo命令</h2><p>Hexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。</p>\n<ul>\n<li><p>全局设置<br>在你博客目录下有一个文件名_config.yml，打开可以配置信息。</p>\n</li>\n<li><p>局部页面<br>在你博客目录下 \\themes\\你使用的主题_config.yml</p>\n</li>\n<li><p>Hexo常用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"postName\"</span>   or hexo n <span class=\"string\">\"postName\"</span>    <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">\"pageName\"</span>      <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">$ hexo generate or hexo g       <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">$ hexo server   or hexo s       <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">$ hexo deploy   or hexo d       <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>还可以复合命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy -g</span><br><span class=\"line\">$ hexo server -g</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure></p>\n<p>当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。</p>\n<p>注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？<br>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p>\n<h2 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h2><ul>\n<li>安装Git (把本地的hexo内容提交到github)</li>\n<li>申请GitHub账号 (是用来做博客的远程创库、域名、服务器等)</li>\n<li>需要在GithHub上配置SSH Keys,如果不了解SSH Keys详见 <a href=\"https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;ch=&amp;tn=baiduerr&amp;bar=&amp;wd=SSHKeys生成\" target=\"_blank\" rel=\"noopener\">SSHKey的作用和生成</a></li>\n<li>在github上建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</li>\n</ul>\n<h2 id=\"关联Github\"><a href=\"#关联Github\" class=\"headerlink\" title=\"关联Github\"></a>关联Github</h2><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo:https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch:master\n</code></pre><p>然后执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>有的type是github,我现在的版本是hexo: 3.1.1，执行命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -vsersion</span><br></pre></td></tr></table></figure></p>\n<p>貌似3.0后全部改成我上面这种格式了。</p>\n<p>然后，执行配置命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"报错总结\"><a href=\"#报错总结\" class=\"headerlink\" title=\"报错总结\"></a>报错总结</h2><p>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</p>\n<p>解决方法： npm install hexo-deployer-git –save</p>\n<p>如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令：</p>\n<p>rm-rf.DS_Store</p>\n<p>ERROR Plugin load failed: hexo-server</p>\n<p>原因：</p>\n<p>Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore.</p>\n<p>解决方法，执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo npm install hexo-server</span><br></pre></td></tr></table></figure></p>\n<p>执行命令hexo server，提示：Usage: hexo ….</p>\n<p>原因：</p>\n<p>我认为是没有生成本地服务</p>\n<p>解决方法，执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-server--save</span><br></pre></td></tr></table></figure></p>\n<p>提示：hexo-server@0.1.2 node_modules/hexo-server</p>\n<p>….</p>\n<p>表示成功了参考</p>\n<p>这个时候再执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo-server</span><br></pre></td></tr></table></figure></p>\n<p>得到:</p>\n<p>INFOHexois running at <a href=\"http://0.0.0.0:4000/.PressCtrl+C\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000/.PressCtrl+C</a> to stop.</p>\n<p>这个时候再点击<a href=\"http://0.0.0.0:4000\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000</a></p>\n<h2 id=\"脚本发布\"><a href=\"#脚本发布\" class=\"headerlink\" title=\"脚本发布\"></a>脚本发布</h2><p>如果发布调用Hexo deploy 失败，可以尝试使用脚本部署的方式发布到Github，以下是脚本命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /Users/Chausson/Documents/B<span class=\"built_in\">log</span> <span class=\"comment\">#这里指的是Hexo创建文件夹的路径</span></span><br><span class=\"line\">$ hexo clean</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> public</span><br><span class=\"line\"></span><br><span class=\"line\">$ git init</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"update at `date` \"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git remote add origin git@github.com:chausson/chausson.github.io</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"### Pushing to Github...\"</span></span><br><span class=\"line\">$ git push origin master <span class=\"_\">-f</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"### Done\"</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"如何正确使用UIImage加载图片","date":"2016-07-04T03:37:52.000Z","_content":"\n# 关于UIImage\n首先我想先介绍一下UIImage这种数据类型,它是一种管理图片Data数据的对象,对象是不可变的,当你想要使用动画的时候一个图片的对象可能包含一个或一组照片，它的继承关系如下:\n``` bash\n├── UIImage\n|   ├── NSObject<NSSecureCoding>\n\n```\n由此可见UIImage是直接继承NSObject,没有UIResponer等响应事件，可以把它理解成一种保存图片数据的对象。\n\n## 官方文档的介绍是这样的:\n* A UIImage object manages image data in your app. You use image objects to represent image data of all kinds, and the UIImage class is capable of managing data for all image formats supported by the underlying platform. Image objects are immutable, so you always create them from existing image data, such as an image file on disk or programmatically created image data. An image object may contain a single image or a sequence of images you intend to use in an animation.\n\n在项目中经常会用到UIImage这种数据,并且包括它的一些相关api，比如\n``` obj-c\n\t[UIImage imageNamed:]\n [UIImage imageWithData:]\n\t[UIImage imageWithData: scale:]\n\t[UIImage imageWithContentsOfFile:]\n\t[UIImage imageWithCGImage:]\n\t[UIImage imageWithCIImage:];\n\t[UIImage animatedImageNamed: duration:]\n```\n# API的介绍\n``` obj-c\n  [UIImage imageNamed:]\n```\n在项目中使用最多或者最常见的API应该就是这个imageNamed了，可是你是否真的熟悉它的用法呢？下面着重的说一下的这个API。\n* 如果系统的缓存中有该图片对象，将会从缓存中获取，如果没有该对象，那它将会从沙盒中寻找该名称PNG格式的图片，保存至对象中，并加载到缓存中。\n* 它的优点是会把所有该方法创建的UIImage加载时会进行缓存,当频繁需要加载该图片资源的时候考虑使用。\n* iOS的内存非常重要并且在内存消耗过大时，首先会强制释放缓存中的图片，即会遇到memory warnings。\n* 因为从iOS9之后它的线程才变的安全,之前的线程不安全性导致出了很多内存泄露的问题,例如当一个UIView对象的animationImages是一个装有UIImage对象动态数组NSMutableArray，并进行逐帧动画。当使用imageNamed的方式加载图像到一个动态数组NSMutableArray，这将会很有可能造成内存泄露。\n* 不过当某些资源文件过大时，并且只会使用一次的情况下,会特别占用资源，所以当所需要加载的图片不频繁使用的情况下不推荐使用该方法来初始化UIImage,应使用其他方法来创建UIImage(比如imageWithContentsOfFile: or imageWithData)，这样就不会加载到内存中。\n\n``` obj-c\n  [UIImage imageWithData:]\n  [UIImage imageWithContentsOfFile:]\n```\n* Data是将传入的NSData文件数据编码成UIImage,如果不能将该数据转换成UImage的数据格式则会返回空,也可以通过如下方法控制数据的倍数:\n\n``` obj-c\n  + (UIImage *)imageWithData:(NSData *)data\n                       scale:(CGFloat)scale\n```\n\n* File是根据文件的路径去创建Image对象，和imageNamed:不同的是它不会加到系统的缓存中，用完就会被释放.\n\n\n\n``` obj-c\n  [UIImage imageWithCGImage:]\n```\n首先先介绍下CGImageRef是什么?它是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义：\n``` bash\ntypedef struct CGImage *CGImageRef;\nCGImageRef 和 struct CGImage * \n```\n它们两者是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。\n通过如下方法重新绘制图片的绘制方向和倍数:\n``` obj-c\n+ (UIImage *)imageWithCGImage:(CGImageRef)imageRef\n                        scale:(CGFloat)scale\n                  orientation:(UIImageOrientation)orientation\n```\n\n``` obj-c\n  [UIImage imageWithCIImage:]\n```\nCIImage是CoreImage框架最常用的类(这里就不对CoreImag多做介绍了,需要了解可以看这里[CoreImage](http://www.csdn.net/article/2015-02-13/2823961-core-image)),这里是将创建CIImage对象转换成UIImage对象,并且它有和CGImage相同的扩展方法,通过如下方法重新绘制图片的绘制方向和倍数:\n``` obj-c\n+ (UIImage *)imageWithCGImage:(CGImageRef)imageRef\n                        scale:(CGFloat)scale\n                  orientation:(UIImageOrientation)orientation\n```\n\n``` obj-c\n  [UIImage animatedImageNamed: duration:]\n```\n官方文档中的解释是这样的:根据给出的名称在资源包中去加载一系列图片,按照图片的名称序号从0开始一直到1024比如图片名称叫icon,那资源包中必须要有icon0,icon1,icon3等。\n为了尝试效果我进行了以下尝试，将三张图片分别命名icon0,icon1,icon3,代码如下:\n``` obj-c\n    UIImageView *image = [[UIImageView alloc]initWithImage:[UIImage animatedImageNamed:@\"icon\" duration:3]];\n    image.backgroundColor = [UIColor grayColor];\n    image.frame  = CGRectMake(130, 250, 100, 50);\n    [self.view addSubview:image];\n```\n展示效果:\n<img src=\"/gif/animation.gif\"  title=\"animation\"><a href=\"\"></a>\n\n## 内存问题\n当系统内存紧张时，UIImage会将图片数据从UIImage对象中清理出去来以节省系统内存，这里的清理行为只是清理UIImage内部存储的图片数据，并不清理UIImage对象本身。当程序使用一个图片数据被清理过的UIImage对象时，该UIImage将会自动从原始的图片文件中加载图片数据。\n\n## 总结\n尽量避免使用UIImage加载过大（如大于1024像素×1024像素）的图片，如果程序实在需要加载这种大图片，可以考虑将该图片分解成多张小图片进行加载。\n根据不同的情况需要使用不同的图片处理方式,由此衍生出各种不同的Loader。我的想法是封装一个ImageLoader类在工程中，可以增加各种不同的接口应对各种情况，如果创建的UIImage对象需要缓存我们可以加一个参数isCache。比如:\n``` obj-c\n+ (UIImage *)ch_imageName:(NSString *)name isCache:(BOOL)cache;\n```\n所有初始化UIImage或者转换UIImage的格式以及网络加载图片的方法都可以通过Loader去调用。\n","source":"_posts/如何正确使用UIImage加载图片.md","raw":"---\ntitle: 如何正确使用UIImage加载图片\ncategories: 图片 #分类\ndate: 2016-07-04 11:37:52\ntags:\n---\n\n# 关于UIImage\n首先我想先介绍一下UIImage这种数据类型,它是一种管理图片Data数据的对象,对象是不可变的,当你想要使用动画的时候一个图片的对象可能包含一个或一组照片，它的继承关系如下:\n``` bash\n├── UIImage\n|   ├── NSObject<NSSecureCoding>\n\n```\n由此可见UIImage是直接继承NSObject,没有UIResponer等响应事件，可以把它理解成一种保存图片数据的对象。\n\n## 官方文档的介绍是这样的:\n* A UIImage object manages image data in your app. You use image objects to represent image data of all kinds, and the UIImage class is capable of managing data for all image formats supported by the underlying platform. Image objects are immutable, so you always create them from existing image data, such as an image file on disk or programmatically created image data. An image object may contain a single image or a sequence of images you intend to use in an animation.\n\n在项目中经常会用到UIImage这种数据,并且包括它的一些相关api，比如\n``` obj-c\n\t[UIImage imageNamed:]\n [UIImage imageWithData:]\n\t[UIImage imageWithData: scale:]\n\t[UIImage imageWithContentsOfFile:]\n\t[UIImage imageWithCGImage:]\n\t[UIImage imageWithCIImage:];\n\t[UIImage animatedImageNamed: duration:]\n```\n# API的介绍\n``` obj-c\n  [UIImage imageNamed:]\n```\n在项目中使用最多或者最常见的API应该就是这个imageNamed了，可是你是否真的熟悉它的用法呢？下面着重的说一下的这个API。\n* 如果系统的缓存中有该图片对象，将会从缓存中获取，如果没有该对象，那它将会从沙盒中寻找该名称PNG格式的图片，保存至对象中，并加载到缓存中。\n* 它的优点是会把所有该方法创建的UIImage加载时会进行缓存,当频繁需要加载该图片资源的时候考虑使用。\n* iOS的内存非常重要并且在内存消耗过大时，首先会强制释放缓存中的图片，即会遇到memory warnings。\n* 因为从iOS9之后它的线程才变的安全,之前的线程不安全性导致出了很多内存泄露的问题,例如当一个UIView对象的animationImages是一个装有UIImage对象动态数组NSMutableArray，并进行逐帧动画。当使用imageNamed的方式加载图像到一个动态数组NSMutableArray，这将会很有可能造成内存泄露。\n* 不过当某些资源文件过大时，并且只会使用一次的情况下,会特别占用资源，所以当所需要加载的图片不频繁使用的情况下不推荐使用该方法来初始化UIImage,应使用其他方法来创建UIImage(比如imageWithContentsOfFile: or imageWithData)，这样就不会加载到内存中。\n\n``` obj-c\n  [UIImage imageWithData:]\n  [UIImage imageWithContentsOfFile:]\n```\n* Data是将传入的NSData文件数据编码成UIImage,如果不能将该数据转换成UImage的数据格式则会返回空,也可以通过如下方法控制数据的倍数:\n\n``` obj-c\n  + (UIImage *)imageWithData:(NSData *)data\n                       scale:(CGFloat)scale\n```\n\n* File是根据文件的路径去创建Image对象，和imageNamed:不同的是它不会加到系统的缓存中，用完就会被释放.\n\n\n\n``` obj-c\n  [UIImage imageWithCGImage:]\n```\n首先先介绍下CGImageRef是什么?它是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义：\n``` bash\ntypedef struct CGImage *CGImageRef;\nCGImageRef 和 struct CGImage * \n```\n它们两者是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。\n通过如下方法重新绘制图片的绘制方向和倍数:\n``` obj-c\n+ (UIImage *)imageWithCGImage:(CGImageRef)imageRef\n                        scale:(CGFloat)scale\n                  orientation:(UIImageOrientation)orientation\n```\n\n``` obj-c\n  [UIImage imageWithCIImage:]\n```\nCIImage是CoreImage框架最常用的类(这里就不对CoreImag多做介绍了,需要了解可以看这里[CoreImage](http://www.csdn.net/article/2015-02-13/2823961-core-image)),这里是将创建CIImage对象转换成UIImage对象,并且它有和CGImage相同的扩展方法,通过如下方法重新绘制图片的绘制方向和倍数:\n``` obj-c\n+ (UIImage *)imageWithCGImage:(CGImageRef)imageRef\n                        scale:(CGFloat)scale\n                  orientation:(UIImageOrientation)orientation\n```\n\n``` obj-c\n  [UIImage animatedImageNamed: duration:]\n```\n官方文档中的解释是这样的:根据给出的名称在资源包中去加载一系列图片,按照图片的名称序号从0开始一直到1024比如图片名称叫icon,那资源包中必须要有icon0,icon1,icon3等。\n为了尝试效果我进行了以下尝试，将三张图片分别命名icon0,icon1,icon3,代码如下:\n``` obj-c\n    UIImageView *image = [[UIImageView alloc]initWithImage:[UIImage animatedImageNamed:@\"icon\" duration:3]];\n    image.backgroundColor = [UIColor grayColor];\n    image.frame  = CGRectMake(130, 250, 100, 50);\n    [self.view addSubview:image];\n```\n展示效果:\n<img src=\"/gif/animation.gif\"  title=\"animation\"><a href=\"\"></a>\n\n## 内存问题\n当系统内存紧张时，UIImage会将图片数据从UIImage对象中清理出去来以节省系统内存，这里的清理行为只是清理UIImage内部存储的图片数据，并不清理UIImage对象本身。当程序使用一个图片数据被清理过的UIImage对象时，该UIImage将会自动从原始的图片文件中加载图片数据。\n\n## 总结\n尽量避免使用UIImage加载过大（如大于1024像素×1024像素）的图片，如果程序实在需要加载这种大图片，可以考虑将该图片分解成多张小图片进行加载。\n根据不同的情况需要使用不同的图片处理方式,由此衍生出各种不同的Loader。我的想法是封装一个ImageLoader类在工程中，可以增加各种不同的接口应对各种情况，如果创建的UIImage对象需要缓存我们可以加一个参数isCache。比如:\n``` obj-c\n+ (UIImage *)ch_imageName:(NSString *)name isCache:(BOOL)cache;\n```\n所有初始化UIImage或者转换UIImage的格式以及网络加载图片的方法都可以通过Loader去调用。\n","slug":"如何正确使用UIImage加载图片","published":1,"updated":"2016-08-10T02:21:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84pv000l4x2nd5cya04s","content":"<h1 id=\"关于UIImage\"><a href=\"#关于UIImage\" class=\"headerlink\" title=\"关于UIImage\"></a>关于UIImage</h1><p>首先我想先介绍一下UIImage这种数据类型,它是一种管理图片Data数据的对象,对象是不可变的,当你想要使用动画的时候一个图片的对象可能包含一个或一组照片，它的继承关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── UIImage</span><br><span class=\"line\">|   ├── NSObject&lt;NSSecureCoding&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由此可见UIImage是直接继承NSObject,没有UIResponer等响应事件，可以把它理解成一种保存图片数据的对象。</p>\n<h2 id=\"官方文档的介绍是这样的\"><a href=\"#官方文档的介绍是这样的\" class=\"headerlink\" title=\"官方文档的介绍是这样的:\"></a>官方文档的介绍是这样的:</h2><ul>\n<li>A UIImage object manages image data in your app. You use image objects to represent image data of all kinds, and the UIImage class is capable of managing data for all image formats supported by the underlying platform. Image objects are immutable, so you always create them from existing image data, such as an image file on disk or programmatically created image data. An image object may contain a single image or a sequence of images you intend to use in an animation.</li>\n</ul>\n<p>在项目中经常会用到UIImage这种数据,并且包括它的一些相关api，比如<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData: scale:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithContentsOfFile:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCGImage:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCIImage:];</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> animatedImageNamed: duration:]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"API的介绍\"><a href=\"#API的介绍\" class=\"headerlink\" title=\"API的介绍\"></a>API的介绍</h1><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:]</span><br></pre></td></tr></table></figure>\n<p>在项目中使用最多或者最常见的API应该就是这个imageNamed了，可是你是否真的熟悉它的用法呢？下面着重的说一下的这个API。</p>\n<ul>\n<li>如果系统的缓存中有该图片对象，将会从缓存中获取，如果没有该对象，那它将会从沙盒中寻找该名称PNG格式的图片，保存至对象中，并加载到缓存中。</li>\n<li>它的优点是会把所有该方法创建的UIImage加载时会进行缓存,当频繁需要加载该图片资源的时候考虑使用。</li>\n<li>iOS的内存非常重要并且在内存消耗过大时，首先会强制释放缓存中的图片，即会遇到memory warnings。</li>\n<li>因为从iOS9之后它的线程才变的安全,之前的线程不安全性导致出了很多内存泄露的问题,例如当一个UIView对象的animationImages是一个装有UIImage对象动态数组NSMutableArray，并进行逐帧动画。当使用imageNamed的方式加载图像到一个动态数组NSMutableArray，这将会很有可能造成内存泄露。</li>\n<li>不过当某些资源文件过大时，并且只会使用一次的情况下,会特别占用资源，所以当所需要加载的图片不频繁使用的情况下不推荐使用该方法来初始化UIImage,应使用其他方法来创建UIImage(比如imageWithContentsOfFile: or imageWithData)，这样就不会加载到内存中。</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithContentsOfFile:]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Data是将传入的NSData文件数据编码成UIImage,如果不能将该数据转换成UImage的数据格式则会返回空,也可以通过如下方法控制数据的倍数:</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithData:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                     scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br></pre></td></tr></table></figure>\n<ul>\n<li>File是根据文件的路径去创建Image对象，和imageNamed:不同的是它不会加到系统的缓存中，用完就会被释放.</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCGImage:]</span><br></pre></td></tr></table></figure>\n<p>首先先介绍下CGImageRef是什么?它是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct CGImage *CGImageRef;</span><br><span class=\"line\">CGImageRef 和 struct CGImage *</span><br></pre></td></tr></table></figure></p>\n<p>它们两者是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。<br>通过如下方法重新绘制图片的绘制方向和倍数:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithCGImage:(<span class=\"built_in\">CGImageRef</span>)imageRef</span><br><span class=\"line\">                        scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br><span class=\"line\">                  orientation:(<span class=\"built_in\">UIImageOrientation</span>)orientation</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCIImage:]</span><br></pre></td></tr></table></figure>\n<p>CIImage是CoreImage框架最常用的类(这里就不对CoreImag多做介绍了,需要了解可以看这里<a href=\"http://www.csdn.net/article/2015-02-13/2823961-core-image\" target=\"_blank\" rel=\"noopener\">CoreImage</a>),这里是将创建CIImage对象转换成UIImage对象,并且它有和CGImage相同的扩展方法,通过如下方法重新绘制图片的绘制方向和倍数:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithCGImage:(<span class=\"built_in\">CGImageRef</span>)imageRef</span><br><span class=\"line\">                        scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br><span class=\"line\">                  orientation:(<span class=\"built_in\">UIImageOrientation</span>)orientation</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> animatedImageNamed: duration:]</span><br></pre></td></tr></table></figure>\n<p>官方文档中的解释是这样的:根据给出的名称在资源包中去加载一系列图片,按照图片的名称序号从0开始一直到1024比如图片名称叫icon,那资源包中必须要有icon0,icon1,icon3等。<br>为了尝试效果我进行了以下尝试，将三张图片分别命名icon0,icon1,icon3,代码如下:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *image = [[<span class=\"built_in\">UIImageView</span> alloc]initWithImage:[<span class=\"built_in\">UIImage</span> animatedImageNamed:<span class=\"string\">@\"icon\"</span> duration:<span class=\"number\">3</span>]];</span><br><span class=\"line\">image.backgroundColor = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">image.frame  = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">130</span>, <span class=\"number\">250</span>, <span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:image];</span><br></pre></td></tr></table></figure></p>\n<p>展示效果:<br><img src=\"/gif/animation.gif\" title=\"animation\"><a href></a></p>\n<h2 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h2><p>当系统内存紧张时，UIImage会将图片数据从UIImage对象中清理出去来以节省系统内存，这里的清理行为只是清理UIImage内部存储的图片数据，并不清理UIImage对象本身。当程序使用一个图片数据被清理过的UIImage对象时，该UIImage将会自动从原始的图片文件中加载图片数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>尽量避免使用UIImage加载过大（如大于1024像素×1024像素）的图片，如果程序实在需要加载这种大图片，可以考虑将该图片分解成多张小图片进行加载。<br>根据不同的情况需要使用不同的图片处理方式,由此衍生出各种不同的Loader。我的想法是封装一个ImageLoader类在工程中，可以增加各种不同的接口应对各种情况，如果创建的UIImage对象需要缓存我们可以加一个参数isCache。比如:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)ch_imageName:(<span class=\"built_in\">NSString</span> *)name isCache:(<span class=\"built_in\">BOOL</span>)cache;</span><br></pre></td></tr></table></figure></p>\n<p>所有初始化UIImage或者转换UIImage的格式以及网络加载图片的方法都可以通过Loader去调用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于UIImage\"><a href=\"#关于UIImage\" class=\"headerlink\" title=\"关于UIImage\"></a>关于UIImage</h1><p>首先我想先介绍一下UIImage这种数据类型,它是一种管理图片Data数据的对象,对象是不可变的,当你想要使用动画的时候一个图片的对象可能包含一个或一组照片，它的继承关系如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── UIImage</span><br><span class=\"line\">|   ├── NSObject&lt;NSSecureCoding&gt;</span><br></pre></td></tr></table></figure></p>\n<p>由此可见UIImage是直接继承NSObject,没有UIResponer等响应事件，可以把它理解成一种保存图片数据的对象。</p>\n<h2 id=\"官方文档的介绍是这样的\"><a href=\"#官方文档的介绍是这样的\" class=\"headerlink\" title=\"官方文档的介绍是这样的:\"></a>官方文档的介绍是这样的:</h2><ul>\n<li>A UIImage object manages image data in your app. You use image objects to represent image data of all kinds, and the UIImage class is capable of managing data for all image formats supported by the underlying platform. Image objects are immutable, so you always create them from existing image data, such as an image file on disk or programmatically created image data. An image object may contain a single image or a sequence of images you intend to use in an animation.</li>\n</ul>\n<p>在项目中经常会用到UIImage这种数据,并且包括它的一些相关api，比如<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData: scale:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithContentsOfFile:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCGImage:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCIImage:];</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> animatedImageNamed: duration:]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"API的介绍\"><a href=\"#API的介绍\" class=\"headerlink\" title=\"API的介绍\"></a>API的介绍</h1><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:]</span><br></pre></td></tr></table></figure>\n<p>在项目中使用最多或者最常见的API应该就是这个imageNamed了，可是你是否真的熟悉它的用法呢？下面着重的说一下的这个API。</p>\n<ul>\n<li>如果系统的缓存中有该图片对象，将会从缓存中获取，如果没有该对象，那它将会从沙盒中寻找该名称PNG格式的图片，保存至对象中，并加载到缓存中。</li>\n<li>它的优点是会把所有该方法创建的UIImage加载时会进行缓存,当频繁需要加载该图片资源的时候考虑使用。</li>\n<li>iOS的内存非常重要并且在内存消耗过大时，首先会强制释放缓存中的图片，即会遇到memory warnings。</li>\n<li>因为从iOS9之后它的线程才变的安全,之前的线程不安全性导致出了很多内存泄露的问题,例如当一个UIView对象的animationImages是一个装有UIImage对象动态数组NSMutableArray，并进行逐帧动画。当使用imageNamed的方式加载图像到一个动态数组NSMutableArray，这将会很有可能造成内存泄露。</li>\n<li>不过当某些资源文件过大时，并且只会使用一次的情况下,会特别占用资源，所以当所需要加载的图片不频繁使用的情况下不推荐使用该方法来初始化UIImage,应使用其他方法来创建UIImage(比如imageWithContentsOfFile: or imageWithData)，这样就不会加载到内存中。</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithData:]</span><br><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithContentsOfFile:]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Data是将传入的NSData文件数据编码成UIImage,如果不能将该数据转换成UImage的数据格式则会返回空,也可以通过如下方法控制数据的倍数:</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithData:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                     scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br></pre></td></tr></table></figure>\n<ul>\n<li>File是根据文件的路径去创建Image对象，和imageNamed:不同的是它不会加到系统的缓存中，用完就会被释放.</li>\n</ul>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCGImage:]</span><br></pre></td></tr></table></figure>\n<p>首先先介绍下CGImageRef是什么?它是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct CGImage *CGImageRef;</span><br><span class=\"line\">CGImageRef 和 struct CGImage *</span><br></pre></td></tr></table></figure></p>\n<p>它们两者是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。<br>通过如下方法重新绘制图片的绘制方向和倍数:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithCGImage:(<span class=\"built_in\">CGImageRef</span>)imageRef</span><br><span class=\"line\">                        scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br><span class=\"line\">                  orientation:(<span class=\"built_in\">UIImageOrientation</span>)orientation</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> imageWithCIImage:]</span><br></pre></td></tr></table></figure>\n<p>CIImage是CoreImage框架最常用的类(这里就不对CoreImag多做介绍了,需要了解可以看这里<a href=\"http://www.csdn.net/article/2015-02-13/2823961-core-image\" target=\"_blank\" rel=\"noopener\">CoreImage</a>),这里是将创建CIImage对象转换成UIImage对象,并且它有和CGImage相同的扩展方法,通过如下方法重新绘制图片的绘制方向和倍数:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)imageWithCGImage:(<span class=\"built_in\">CGImageRef</span>)imageRef</span><br><span class=\"line\">                        scale:(<span class=\"built_in\">CGFloat</span>)scale</span><br><span class=\"line\">                  orientation:(<span class=\"built_in\">UIImageOrientation</span>)orientation</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIImage</span> animatedImageNamed: duration:]</span><br></pre></td></tr></table></figure>\n<p>官方文档中的解释是这样的:根据给出的名称在资源包中去加载一系列图片,按照图片的名称序号从0开始一直到1024比如图片名称叫icon,那资源包中必须要有icon0,icon1,icon3等。<br>为了尝试效果我进行了以下尝试，将三张图片分别命名icon0,icon1,icon3,代码如下:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *image = [[<span class=\"built_in\">UIImageView</span> alloc]initWithImage:[<span class=\"built_in\">UIImage</span> animatedImageNamed:<span class=\"string\">@\"icon\"</span> duration:<span class=\"number\">3</span>]];</span><br><span class=\"line\">image.backgroundColor = [<span class=\"built_in\">UIColor</span> grayColor];</span><br><span class=\"line\">image.frame  = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">130</span>, <span class=\"number\">250</span>, <span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:image];</span><br></pre></td></tr></table></figure></p>\n<p>展示效果:<br><img src=\"/gif/animation.gif\" title=\"animation\"><a href></a></p>\n<h2 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h2><p>当系统内存紧张时，UIImage会将图片数据从UIImage对象中清理出去来以节省系统内存，这里的清理行为只是清理UIImage内部存储的图片数据，并不清理UIImage对象本身。当程序使用一个图片数据被清理过的UIImage对象时，该UIImage将会自动从原始的图片文件中加载图片数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>尽量避免使用UIImage加载过大（如大于1024像素×1024像素）的图片，如果程序实在需要加载这种大图片，可以考虑将该图片分解成多张小图片进行加载。<br>根据不同的情况需要使用不同的图片处理方式,由此衍生出各种不同的Loader。我的想法是封装一个ImageLoader类在工程中，可以增加各种不同的接口应对各种情况，如果创建的UIImage对象需要缓存我们可以加一个参数isCache。比如:<br><figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">UIImage</span> *)ch_imageName:(<span class=\"built_in\">NSString</span> *)name isCache:(<span class=\"built_in\">BOOL</span>)cache;</span><br></pre></td></tr></table></figure></p>\n<p>所有初始化UIImage或者转换UIImage的格式以及网络加载图片的方法都可以通过Loader去调用。</p>\n"},{"title":"简单易用的HUD","date":"2016-08-17T06:44:22.000Z","_content":"# CHProgressHUD\nHUD组件是我们平时开发中必不可少的，目前iOS开发中用的比较多的还是MDProgressHUD和SVProgessHUD,两个HUD的样式和设计都不太相同。MB是将HUD作为一个对象创建，自己控制它的生命周期，","source":"_posts/简单易用的HUD.md","raw":"---\ntitle: 简单易用的HUD\ncategories: 组件 #分类\ndate: 2016-08-17 14:44:22\ntags:\n---\n# CHProgressHUD\nHUD组件是我们平时开发中必不可少的，目前iOS开发中用的比较多的还是MDProgressHUD和SVProgessHUD,两个HUD的样式和设计都不太相同。MB是将HUD作为一个对象创建，自己控制它的生命周期，","slug":"简单易用的HUD","published":1,"updated":"2016-08-17T11:49:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84px000n4x2nfb1yy6f6","content":"<h1 id=\"CHProgressHUD\"><a href=\"#CHProgressHUD\" class=\"headerlink\" title=\"CHProgressHUD\"></a>CHProgressHUD</h1><p>HUD组件是我们平时开发中必不可少的，目前iOS开发中用的比较多的还是MDProgressHUD和SVProgessHUD,两个HUD的样式和设计都不太相同。MB是将HUD作为一个对象创建，自己控制它的生命周期，</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CHProgressHUD\"><a href=\"#CHProgressHUD\" class=\"headerlink\" title=\"CHProgressHUD\"></a>CHProgressHUD</h1><p>HUD组件是我们平时开发中必不可少的，目前iOS开发中用的比较多的还是MDProgressHUD和SVProgessHUD,两个HUD的样式和设计都不太相同。MB是将HUD作为一个对象创建，自己控制它的生命周期，</p>\n"},{"title":"组件化之路的尝试","date":"2016-12-30T02:50:18.000Z","_content":"最新因为使用pod私有库来进行开发，将所有模块拆分成各个Private Pod，它的Podfile目录结构类似这样:\n\n``` bash\npod 'PrivateKit'\npod 'ModuleA'\npod 'ModuleB'\n\n```\n其中PrivateKit里面包含多个通用库，其中包含：RequestKit网络请求库（将所有请求看作一个对象）,\nConfigurationKit(包含通用的样式以及配置信息等),第三方需要引用的库如:AFNetworking，SDWebImage等。\n\n这样所有的业务模块可以进行拆分，业务模块可以选择依赖性于这个PrivateKit。这样的好处无疑是解耦模块业务之间的开发，将大的一个工程拆分成无数个小的子工程，适合多人协作的开发方式，每个开发人员无须深入理解多个业务模块之间的关系，只需要设计输出和输入的接口，这是比较理想的情况。\n\n在这个道路上进行尝试，那其中首当要解决的问题就是去模块化的耦合，我们设想一下，如果ModuleB的初始化需要根据ModuleA用户选择和计算出的结果来进行判断，那就必须先ModuleA的一些Model传递给B，这样势必会进行耦合，所以优先考虑这个的解决方案。首先会想到的自然是加中间层，所有的一切都是通过这个中间件路由，一开始的构想是这样的:\n<img src=\"/img/Mediator1.jpeg\">\n\n又或者这样:\n<img src=\"/img/Mediator2.jpeg\">\n\n这样满足了我们之前的要求，解除了模块之间的直接关联，我们只增加了Mediator这样一个类去做，仔细观察上面这个图之后，会发现Mediator的作用显然被放大了，模块之间与Mediator的耦合越来越重，ModuleA与ModuleB的耦合是没有。如果方向上是正确的话，我们需要尝试去解决模块和Mediator之间的问题，尝试之后，觉得还是增加一个协议，来减轻他们之间的耦合关系，想象的是这样:\n<img src=\"/img/Mediator3.jpeg\">\n\n既然这样做的话，看起来是挺好，模块之间都遵循同一个协议，至于如何通过Mediator去打开Module，我们还缺少一层映射关系,目前从图中看不出有任何关系，所以就必须设置代理或者target，又或者回到之前的老路，在Mediator去注册，通过协议和open方法来执行。想想都不是一个好的方案，于是尝试另一种方式，在运行时，通过查找target就是具体的实例对象,来调用其中的方法完成模块之间的依赖性。将protocol通过引用一个新的类来代替，这个类叫做Behaviour,每个module中的每个page又或者是每个控制器都有一个扩展的行为来进行模块之间的功能，这个扩展行为我们定义为Behaviour类，这个是一个抽象类，让子类去说明自己是属于哪个类的扩展行为。\n之后将它所有的扩展行为，通过Mediator的Catagetory去映射。这样我就没有必要一定要去遵守Mediator的Protocol。catagetory通过查看Behaviour的拥有者来映射这层关系。它似乎是这样\n<img src=\"/img/Mediator4.jpg\">\n\n[CHMediator GitHub地址](https://github.com/chausson/CHMediatorDemo)\n\n期间有一小插曲，可以通过performSelector来runtime机制，但不能处理多个参数，为了处理多个参数传递的映射,最后使用valist去接收参数，选择使用NSInvocation去执行和接收返回值，但在跳转Cotroller报出了很多野指针的错误，在僵尸模式调试下，发现竟然是\n``` objective-c\n[ModuleAViewController release]: message sent to deallocated instance 0x7fbb67312410\n```\n\n这样的可能就是在控制器dealloc时候找不到了，其实是NSInvocation接收返回对象会被释放两次（由于ARC模式下NSInvocation并没有管理接收对象的原因)，最后使用指针对象接收返回值，然后在用(__bridge id)转换成对象。  \n\n","source":"_posts/组件化之路的尝试.md","raw":"---\ntitle: 组件化之路的尝试\ndate: 2016-12-30 10:50:18\ntags:\ncategories:  设计模式#分类\n---\n最新因为使用pod私有库来进行开发，将所有模块拆分成各个Private Pod，它的Podfile目录结构类似这样:\n\n``` bash\npod 'PrivateKit'\npod 'ModuleA'\npod 'ModuleB'\n\n```\n其中PrivateKit里面包含多个通用库，其中包含：RequestKit网络请求库（将所有请求看作一个对象）,\nConfigurationKit(包含通用的样式以及配置信息等),第三方需要引用的库如:AFNetworking，SDWebImage等。\n\n这样所有的业务模块可以进行拆分，业务模块可以选择依赖性于这个PrivateKit。这样的好处无疑是解耦模块业务之间的开发，将大的一个工程拆分成无数个小的子工程，适合多人协作的开发方式，每个开发人员无须深入理解多个业务模块之间的关系，只需要设计输出和输入的接口，这是比较理想的情况。\n\n在这个道路上进行尝试，那其中首当要解决的问题就是去模块化的耦合，我们设想一下，如果ModuleB的初始化需要根据ModuleA用户选择和计算出的结果来进行判断，那就必须先ModuleA的一些Model传递给B，这样势必会进行耦合，所以优先考虑这个的解决方案。首先会想到的自然是加中间层，所有的一切都是通过这个中间件路由，一开始的构想是这样的:\n<img src=\"/img/Mediator1.jpeg\">\n\n又或者这样:\n<img src=\"/img/Mediator2.jpeg\">\n\n这样满足了我们之前的要求，解除了模块之间的直接关联，我们只增加了Mediator这样一个类去做，仔细观察上面这个图之后，会发现Mediator的作用显然被放大了，模块之间与Mediator的耦合越来越重，ModuleA与ModuleB的耦合是没有。如果方向上是正确的话，我们需要尝试去解决模块和Mediator之间的问题，尝试之后，觉得还是增加一个协议，来减轻他们之间的耦合关系，想象的是这样:\n<img src=\"/img/Mediator3.jpeg\">\n\n既然这样做的话，看起来是挺好，模块之间都遵循同一个协议，至于如何通过Mediator去打开Module，我们还缺少一层映射关系,目前从图中看不出有任何关系，所以就必须设置代理或者target，又或者回到之前的老路，在Mediator去注册，通过协议和open方法来执行。想想都不是一个好的方案，于是尝试另一种方式，在运行时，通过查找target就是具体的实例对象,来调用其中的方法完成模块之间的依赖性。将protocol通过引用一个新的类来代替，这个类叫做Behaviour,每个module中的每个page又或者是每个控制器都有一个扩展的行为来进行模块之间的功能，这个扩展行为我们定义为Behaviour类，这个是一个抽象类，让子类去说明自己是属于哪个类的扩展行为。\n之后将它所有的扩展行为，通过Mediator的Catagetory去映射。这样我就没有必要一定要去遵守Mediator的Protocol。catagetory通过查看Behaviour的拥有者来映射这层关系。它似乎是这样\n<img src=\"/img/Mediator4.jpg\">\n\n[CHMediator GitHub地址](https://github.com/chausson/CHMediatorDemo)\n\n期间有一小插曲，可以通过performSelector来runtime机制，但不能处理多个参数，为了处理多个参数传递的映射,最后使用valist去接收参数，选择使用NSInvocation去执行和接收返回值，但在跳转Cotroller报出了很多野指针的错误，在僵尸模式调试下，发现竟然是\n``` objective-c\n[ModuleAViewController release]: message sent to deallocated instance 0x7fbb67312410\n```\n\n这样的可能就是在控制器dealloc时候找不到了，其实是NSInvocation接收返回对象会被释放两次（由于ARC模式下NSInvocation并没有管理接收对象的原因)，最后使用指针对象接收返回值，然后在用(__bridge id)转换成对象。  \n\n","slug":"组件化之路的尝试","published":1,"updated":"2017-01-04T11:59:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84q0000o4x2noyfdgz1l","content":"<p>最新因为使用pod私有库来进行开发，将所有模块拆分成各个Private Pod，它的Podfile目录结构类似这样:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PrivateKit'</span></span><br><span class=\"line\">pod <span class=\"string\">'ModuleA'</span></span><br><span class=\"line\">pod <span class=\"string\">'ModuleB'</span></span><br></pre></td></tr></table></figure>\n<p>其中PrivateKit里面包含多个通用库，其中包含：RequestKit网络请求库（将所有请求看作一个对象）,<br>ConfigurationKit(包含通用的样式以及配置信息等),第三方需要引用的库如:AFNetworking，SDWebImage等。</p>\n<p>这样所有的业务模块可以进行拆分，业务模块可以选择依赖性于这个PrivateKit。这样的好处无疑是解耦模块业务之间的开发，将大的一个工程拆分成无数个小的子工程，适合多人协作的开发方式，每个开发人员无须深入理解多个业务模块之间的关系，只需要设计输出和输入的接口，这是比较理想的情况。</p>\n<p>在这个道路上进行尝试，那其中首当要解决的问题就是去模块化的耦合，我们设想一下，如果ModuleB的初始化需要根据ModuleA用户选择和计算出的结果来进行判断，那就必须先ModuleA的一些Model传递给B，这样势必会进行耦合，所以优先考虑这个的解决方案。首先会想到的自然是加中间层，所有的一切都是通过这个中间件路由，一开始的构想是这样的:<br><img src=\"/img/Mediator1.jpeg\"></p>\n<p>又或者这样:<br><img src=\"/img/Mediator2.jpeg\"></p>\n<p>这样满足了我们之前的要求，解除了模块之间的直接关联，我们只增加了Mediator这样一个类去做，仔细观察上面这个图之后，会发现Mediator的作用显然被放大了，模块之间与Mediator的耦合越来越重，ModuleA与ModuleB的耦合是没有。如果方向上是正确的话，我们需要尝试去解决模块和Mediator之间的问题，尝试之后，觉得还是增加一个协议，来减轻他们之间的耦合关系，想象的是这样:<br><img src=\"/img/Mediator3.jpeg\"></p>\n<p>既然这样做的话，看起来是挺好，模块之间都遵循同一个协议，至于如何通过Mediator去打开Module，我们还缺少一层映射关系,目前从图中看不出有任何关系，所以就必须设置代理或者target，又或者回到之前的老路，在Mediator去注册，通过协议和open方法来执行。想想都不是一个好的方案，于是尝试另一种方式，在运行时，通过查找target就是具体的实例对象,来调用其中的方法完成模块之间的依赖性。将protocol通过引用一个新的类来代替，这个类叫做Behaviour,每个module中的每个page又或者是每个控制器都有一个扩展的行为来进行模块之间的功能，这个扩展行为我们定义为Behaviour类，这个是一个抽象类，让子类去说明自己是属于哪个类的扩展行为。<br>之后将它所有的扩展行为，通过Mediator的Catagetory去映射。这样我就没有必要一定要去遵守Mediator的Protocol。catagetory通过查看Behaviour的拥有者来映射这层关系。它似乎是这样<br><img src=\"/img/Mediator4.jpg\"></p>\n<p><a href=\"https://github.com/chausson/CHMediatorDemo\" target=\"_blank\" rel=\"noopener\">CHMediator GitHub地址</a></p>\n<p>期间有一小插曲，可以通过performSelector来runtime机制，但不能处理多个参数，为了处理多个参数传递的映射,最后使用valist去接收参数，选择使用NSInvocation去执行和接收返回值，但在跳转Cotroller报出了很多野指针的错误，在僵尸模式调试下，发现竟然是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ModuleAViewController release]: message sent to deallocated instance 0x7fbb67312410</span><br></pre></td></tr></table></figure></p>\n<p>这样的可能就是在控制器dealloc时候找不到了，其实是NSInvocation接收返回对象会被释放两次（由于ARC模式下NSInvocation并没有管理接收对象的原因)，最后使用指针对象接收返回值，然后在用(__bridge id)转换成对象。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>最新因为使用pod私有库来进行开发，将所有模块拆分成各个Private Pod，它的Podfile目录结构类似这样:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'PrivateKit'</span></span><br><span class=\"line\">pod <span class=\"string\">'ModuleA'</span></span><br><span class=\"line\">pod <span class=\"string\">'ModuleB'</span></span><br></pre></td></tr></table></figure>\n<p>其中PrivateKit里面包含多个通用库，其中包含：RequestKit网络请求库（将所有请求看作一个对象）,<br>ConfigurationKit(包含通用的样式以及配置信息等),第三方需要引用的库如:AFNetworking，SDWebImage等。</p>\n<p>这样所有的业务模块可以进行拆分，业务模块可以选择依赖性于这个PrivateKit。这样的好处无疑是解耦模块业务之间的开发，将大的一个工程拆分成无数个小的子工程，适合多人协作的开发方式，每个开发人员无须深入理解多个业务模块之间的关系，只需要设计输出和输入的接口，这是比较理想的情况。</p>\n<p>在这个道路上进行尝试，那其中首当要解决的问题就是去模块化的耦合，我们设想一下，如果ModuleB的初始化需要根据ModuleA用户选择和计算出的结果来进行判断，那就必须先ModuleA的一些Model传递给B，这样势必会进行耦合，所以优先考虑这个的解决方案。首先会想到的自然是加中间层，所有的一切都是通过这个中间件路由，一开始的构想是这样的:<br><img src=\"/img/Mediator1.jpeg\"></p>\n<p>又或者这样:<br><img src=\"/img/Mediator2.jpeg\"></p>\n<p>这样满足了我们之前的要求，解除了模块之间的直接关联，我们只增加了Mediator这样一个类去做，仔细观察上面这个图之后，会发现Mediator的作用显然被放大了，模块之间与Mediator的耦合越来越重，ModuleA与ModuleB的耦合是没有。如果方向上是正确的话，我们需要尝试去解决模块和Mediator之间的问题，尝试之后，觉得还是增加一个协议，来减轻他们之间的耦合关系，想象的是这样:<br><img src=\"/img/Mediator3.jpeg\"></p>\n<p>既然这样做的话，看起来是挺好，模块之间都遵循同一个协议，至于如何通过Mediator去打开Module，我们还缺少一层映射关系,目前从图中看不出有任何关系，所以就必须设置代理或者target，又或者回到之前的老路，在Mediator去注册，通过协议和open方法来执行。想想都不是一个好的方案，于是尝试另一种方式，在运行时，通过查找target就是具体的实例对象,来调用其中的方法完成模块之间的依赖性。将protocol通过引用一个新的类来代替，这个类叫做Behaviour,每个module中的每个page又或者是每个控制器都有一个扩展的行为来进行模块之间的功能，这个扩展行为我们定义为Behaviour类，这个是一个抽象类，让子类去说明自己是属于哪个类的扩展行为。<br>之后将它所有的扩展行为，通过Mediator的Catagetory去映射。这样我就没有必要一定要去遵守Mediator的Protocol。catagetory通过查看Behaviour的拥有者来映射这层关系。它似乎是这样<br><img src=\"/img/Mediator4.jpg\"></p>\n<p><a href=\"https://github.com/chausson/CHMediatorDemo\" target=\"_blank\" rel=\"noopener\">CHMediator GitHub地址</a></p>\n<p>期间有一小插曲，可以通过performSelector来runtime机制，但不能处理多个参数，为了处理多个参数传递的映射,最后使用valist去接收参数，选择使用NSInvocation去执行和接收返回值，但在跳转Cotroller报出了很多野指针的错误，在僵尸模式调试下，发现竟然是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ModuleAViewController release]: message sent to deallocated instance 0x7fbb67312410</span><br></pre></td></tr></table></figure></p>\n<p>这样的可能就是在控制器dealloc时候找不到了，其实是NSInvocation接收返回对象会被释放两次（由于ARC模式下NSInvocation并没有管理接收对象的原因)，最后使用指针对象接收返回值，然后在用(__bridge id)转换成对象。  </p>\n"},{"title":"自动化构建工具Jenkins","date":"2016-10-31T10:05:50.000Z","_content":"\n### 安装\n操作系统：Windows\n注意：以下所有的安装和配置目录都尽量不要出现中文，以免有错误\n\n##### 1.0 安装JDK环境\n\n##### 1.1 下载网址：[https://jenkins.io/index.html](https://jenkins.io/index.html)\n\n##### 1.2 Jenkins安装和配置\n\n＊ 直接安装：直接解压压缩包，双击.exe文件进行安装。\n\n＊ 命令行安装：在cmd中输入：java -jar jenkins.war\n\n    java -jar jenkins.war\n          \n##### 1.3 **Jenkins** 安装验证\n\n在浏览器中输入：*http://localhost:8080* 如果能正常跳转，说明安装成功\n\n    http://localhost:8080\n\n此处的端口 **8080** 可以根据自己的需要进行修改，找到安装主目录下的 **jenkins.xml** 文件中的这段代码，找到其中的 **8080** 端口进行修改，然后保存文件，重启浏览器。\n\n    <arguments>-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar \"%BASE%\\jenkins.war\" --httpPort=8080 --webroot=\"%BASE%\\war\"</arguments>\n\n---\n### 第二部分 Jenkins的使用\n上面已经完成Jenkins的安装，下面主要介绍Jenkins的使用。\n\n\n#### 1：用户注册\n**Jenkins** 成功安装之后，会进入到下面的锁定界面。根据页面上的提示找到安装目录下的 **initialAdminPassword** 文件打开，复制里面的内容，输入到下面的方框内，\n\n![](http://i.imgur.com/ER5U0is.png)\n\n点击下一步会进入到插件的安装界面，主要有：默认安装和选择安装。请自己进行选择，我选择的是默认安装，会比较慢。\n\n![](http://i.imgur.com/aVemMoL.png)\n\n插件安装之后，会进入到用户注册界面。此处可能插件不一定能够全部安装成功，会卡主安装界面。\n\n![](http://i.imgur.com/UnW2IqV.png)\n\n不用担心。我的解决方式是，关闭浏览器，重新打开Jenkins。会进入到下面界面\n\n![](http://i.imgur.com/myb4x4F.png)\n\n注意一定要点击 **continue** ，才会进入到用户注册界面，点击Retry又会回到插件下载界面\n\n![](http://i.imgur.com/hdaGxc9.png)\n\n注册信息填写好之后，选择**Save and Finish** 就会进入到Jenkins的主界面。\n\n#### 2：插件下载\n进入到jenkins首先要进行相应的插件下载，不然后期工作无法展开。Android需要的插件主要有：**Git Plugin**、**Gradle Plugin**、**SSH Credentials Plugin**。 进入到Jenkins主界面选择 **系统管理** \n\n![](http://i.imgur.com/NsUi08u.png)\n\n进入之后选择 **管理插件**，进入到插件下载界面，进行相应插件下载。\n\n![](http://i.imgur.com/37JT32x.png)\n\n#### 3：系统设置（重点）\n在插件下载完成之后，进入到 **系统设置** 界面，这里可以设置 **JDK**、**Gradle**、**Android SDK**的环境变量，如果在安装这些软件的时候已经配置好了系统变量，那么这里就不需要进行设置了。\n\n![](http://i.imgur.com/tPPMXfJ.png)\n\n","source":"_posts/自动化构建工具Jenkins.md","raw":"---\ntitle: 自动化构建工具Jenkins\ndate: 2016-10-31 18:05:50\ntags:\ncategories: 环境搭建 #分类\n---\n\n### 安装\n操作系统：Windows\n注意：以下所有的安装和配置目录都尽量不要出现中文，以免有错误\n\n##### 1.0 安装JDK环境\n\n##### 1.1 下载网址：[https://jenkins.io/index.html](https://jenkins.io/index.html)\n\n##### 1.2 Jenkins安装和配置\n\n＊ 直接安装：直接解压压缩包，双击.exe文件进行安装。\n\n＊ 命令行安装：在cmd中输入：java -jar jenkins.war\n\n    java -jar jenkins.war\n          \n##### 1.3 **Jenkins** 安装验证\n\n在浏览器中输入：*http://localhost:8080* 如果能正常跳转，说明安装成功\n\n    http://localhost:8080\n\n此处的端口 **8080** 可以根据自己的需要进行修改，找到安装主目录下的 **jenkins.xml** 文件中的这段代码，找到其中的 **8080** 端口进行修改，然后保存文件，重启浏览器。\n\n    <arguments>-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar \"%BASE%\\jenkins.war\" --httpPort=8080 --webroot=\"%BASE%\\war\"</arguments>\n\n---\n### 第二部分 Jenkins的使用\n上面已经完成Jenkins的安装，下面主要介绍Jenkins的使用。\n\n\n#### 1：用户注册\n**Jenkins** 成功安装之后，会进入到下面的锁定界面。根据页面上的提示找到安装目录下的 **initialAdminPassword** 文件打开，复制里面的内容，输入到下面的方框内，\n\n![](http://i.imgur.com/ER5U0is.png)\n\n点击下一步会进入到插件的安装界面，主要有：默认安装和选择安装。请自己进行选择，我选择的是默认安装，会比较慢。\n\n![](http://i.imgur.com/aVemMoL.png)\n\n插件安装之后，会进入到用户注册界面。此处可能插件不一定能够全部安装成功，会卡主安装界面。\n\n![](http://i.imgur.com/UnW2IqV.png)\n\n不用担心。我的解决方式是，关闭浏览器，重新打开Jenkins。会进入到下面界面\n\n![](http://i.imgur.com/myb4x4F.png)\n\n注意一定要点击 **continue** ，才会进入到用户注册界面，点击Retry又会回到插件下载界面\n\n![](http://i.imgur.com/hdaGxc9.png)\n\n注册信息填写好之后，选择**Save and Finish** 就会进入到Jenkins的主界面。\n\n#### 2：插件下载\n进入到jenkins首先要进行相应的插件下载，不然后期工作无法展开。Android需要的插件主要有：**Git Plugin**、**Gradle Plugin**、**SSH Credentials Plugin**。 进入到Jenkins主界面选择 **系统管理** \n\n![](http://i.imgur.com/NsUi08u.png)\n\n进入之后选择 **管理插件**，进入到插件下载界面，进行相应插件下载。\n\n![](http://i.imgur.com/37JT32x.png)\n\n#### 3：系统设置（重点）\n在插件下载完成之后，进入到 **系统设置** 界面，这里可以设置 **JDK**、**Gradle**、**Android SDK**的环境变量，如果在安装这些软件的时候已经配置好了系统变量，那么这里就不需要进行设置了。\n\n![](http://i.imgur.com/tPPMXfJ.png)\n\n","slug":"自动化构建工具Jenkins","published":1,"updated":"2016-10-31T10:11:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84q3000r4x2npt3tbbjk","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>操作系统：Windows<br>注意：以下所有的安装和配置目录都尽量不要出现中文，以免有错误</p>\n<h5 id=\"1-0-安装JDK环境\"><a href=\"#1-0-安装JDK环境\" class=\"headerlink\" title=\"1.0 安装JDK环境\"></a>1.0 安装JDK环境</h5><h5 id=\"1-1-下载网址：https-jenkins-io-index-html\"><a href=\"#1-1-下载网址：https-jenkins-io-index-html\" class=\"headerlink\" title=\"1.1 下载网址：https://jenkins.io/index.html\"></a>1.1 下载网址：<a href=\"https://jenkins.io/index.html\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/index.html</a></h5><h5 id=\"1-2-Jenkins安装和配置\"><a href=\"#1-2-Jenkins安装和配置\" class=\"headerlink\" title=\"1.2 Jenkins安装和配置\"></a>1.2 Jenkins安装和配置</h5><p>＊ 直接安装：直接解压压缩包，双击.exe文件进行安装。</p>\n<p>＊ 命令行安装：在cmd中输入：java -jar jenkins.war</p>\n<pre><code>java -jar jenkins.war\n</code></pre><h5 id=\"1-3-Jenkins-安装验证\"><a href=\"#1-3-Jenkins-安装验证\" class=\"headerlink\" title=\"1.3 Jenkins 安装验证\"></a>1.3 <strong>Jenkins</strong> 安装验证</h5><p>在浏览器中输入：<em><a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a></em> 如果能正常跳转，说明安装成功</p>\n<pre><code>http://localhost:8080\n</code></pre><p>此处的端口 <strong>8080</strong> 可以根据自己的需要进行修改，找到安装主目录下的 <strong>jenkins.xml</strong> 文件中的这段代码，找到其中的 <strong>8080</strong> 端口进行修改，然后保存文件，重启浏览器。</p>\n<pre><code>&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar &quot;%BASE%\\jenkins.war&quot; --httpPort=8080 --webroot=&quot;%BASE%\\war&quot;&lt;/arguments&gt;\n</code></pre><hr>\n<h3 id=\"第二部分-Jenkins的使用\"><a href=\"#第二部分-Jenkins的使用\" class=\"headerlink\" title=\"第二部分 Jenkins的使用\"></a>第二部分 Jenkins的使用</h3><p>上面已经完成Jenkins的安装，下面主要介绍Jenkins的使用。</p>\n<h4 id=\"1：用户注册\"><a href=\"#1：用户注册\" class=\"headerlink\" title=\"1：用户注册\"></a>1：用户注册</h4><p><strong>Jenkins</strong> 成功安装之后，会进入到下面的锁定界面。根据页面上的提示找到安装目录下的 <strong>initialAdminPassword</strong> 文件打开，复制里面的内容，输入到下面的方框内，</p>\n<p><img src=\"http://i.imgur.com/ER5U0is.png\" alt></p>\n<p>点击下一步会进入到插件的安装界面，主要有：默认安装和选择安装。请自己进行选择，我选择的是默认安装，会比较慢。</p>\n<p><img src=\"http://i.imgur.com/aVemMoL.png\" alt></p>\n<p>插件安装之后，会进入到用户注册界面。此处可能插件不一定能够全部安装成功，会卡主安装界面。</p>\n<p><img src=\"http://i.imgur.com/UnW2IqV.png\" alt></p>\n<p>不用担心。我的解决方式是，关闭浏览器，重新打开Jenkins。会进入到下面界面</p>\n<p><img src=\"http://i.imgur.com/myb4x4F.png\" alt></p>\n<p>注意一定要点击 <strong>continue</strong> ，才会进入到用户注册界面，点击Retry又会回到插件下载界面</p>\n<p><img src=\"http://i.imgur.com/hdaGxc9.png\" alt></p>\n<p>注册信息填写好之后，选择<strong>Save and Finish</strong> 就会进入到Jenkins的主界面。</p>\n<h4 id=\"2：插件下载\"><a href=\"#2：插件下载\" class=\"headerlink\" title=\"2：插件下载\"></a>2：插件下载</h4><p>进入到jenkins首先要进行相应的插件下载，不然后期工作无法展开。Android需要的插件主要有：<strong>Git Plugin</strong>、<strong>Gradle Plugin</strong>、<strong>SSH Credentials Plugin</strong>。 进入到Jenkins主界面选择 <strong>系统管理</strong> </p>\n<p><img src=\"http://i.imgur.com/NsUi08u.png\" alt></p>\n<p>进入之后选择 <strong>管理插件</strong>，进入到插件下载界面，进行相应插件下载。</p>\n<p><img src=\"http://i.imgur.com/37JT32x.png\" alt></p>\n<h4 id=\"3：系统设置（重点）\"><a href=\"#3：系统设置（重点）\" class=\"headerlink\" title=\"3：系统设置（重点）\"></a>3：系统设置（重点）</h4><p>在插件下载完成之后，进入到 <strong>系统设置</strong> 界面，这里可以设置 <strong>JDK</strong>、<strong>Gradle</strong>、<strong>Android SDK</strong>的环境变量，如果在安装这些软件的时候已经配置好了系统变量，那么这里就不需要进行设置了。</p>\n<p><img src=\"http://i.imgur.com/tPPMXfJ.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>操作系统：Windows<br>注意：以下所有的安装和配置目录都尽量不要出现中文，以免有错误</p>\n<h5 id=\"1-0-安装JDK环境\"><a href=\"#1-0-安装JDK环境\" class=\"headerlink\" title=\"1.0 安装JDK环境\"></a>1.0 安装JDK环境</h5><h5 id=\"1-1-下载网址：https-jenkins-io-index-html\"><a href=\"#1-1-下载网址：https-jenkins-io-index-html\" class=\"headerlink\" title=\"1.1 下载网址：https://jenkins.io/index.html\"></a>1.1 下载网址：<a href=\"https://jenkins.io/index.html\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/index.html</a></h5><h5 id=\"1-2-Jenkins安装和配置\"><a href=\"#1-2-Jenkins安装和配置\" class=\"headerlink\" title=\"1.2 Jenkins安装和配置\"></a>1.2 Jenkins安装和配置</h5><p>＊ 直接安装：直接解压压缩包，双击.exe文件进行安装。</p>\n<p>＊ 命令行安装：在cmd中输入：java -jar jenkins.war</p>\n<pre><code>java -jar jenkins.war\n</code></pre><h5 id=\"1-3-Jenkins-安装验证\"><a href=\"#1-3-Jenkins-安装验证\" class=\"headerlink\" title=\"1.3 Jenkins 安装验证\"></a>1.3 <strong>Jenkins</strong> 安装验证</h5><p>在浏览器中输入：<em><a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a></em> 如果能正常跳转，说明安装成功</p>\n<pre><code>http://localhost:8080\n</code></pre><p>此处的端口 <strong>8080</strong> 可以根据自己的需要进行修改，找到安装主目录下的 <strong>jenkins.xml</strong> 文件中的这段代码，找到其中的 <strong>8080</strong> 端口进行修改，然后保存文件，重启浏览器。</p>\n<pre><code>&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar &quot;%BASE%\\jenkins.war&quot; --httpPort=8080 --webroot=&quot;%BASE%\\war&quot;&lt;/arguments&gt;\n</code></pre><hr>\n<h3 id=\"第二部分-Jenkins的使用\"><a href=\"#第二部分-Jenkins的使用\" class=\"headerlink\" title=\"第二部分 Jenkins的使用\"></a>第二部分 Jenkins的使用</h3><p>上面已经完成Jenkins的安装，下面主要介绍Jenkins的使用。</p>\n<h4 id=\"1：用户注册\"><a href=\"#1：用户注册\" class=\"headerlink\" title=\"1：用户注册\"></a>1：用户注册</h4><p><strong>Jenkins</strong> 成功安装之后，会进入到下面的锁定界面。根据页面上的提示找到安装目录下的 <strong>initialAdminPassword</strong> 文件打开，复制里面的内容，输入到下面的方框内，</p>\n<p><img src=\"http://i.imgur.com/ER5U0is.png\" alt></p>\n<p>点击下一步会进入到插件的安装界面，主要有：默认安装和选择安装。请自己进行选择，我选择的是默认安装，会比较慢。</p>\n<p><img src=\"http://i.imgur.com/aVemMoL.png\" alt></p>\n<p>插件安装之后，会进入到用户注册界面。此处可能插件不一定能够全部安装成功，会卡主安装界面。</p>\n<p><img src=\"http://i.imgur.com/UnW2IqV.png\" alt></p>\n<p>不用担心。我的解决方式是，关闭浏览器，重新打开Jenkins。会进入到下面界面</p>\n<p><img src=\"http://i.imgur.com/myb4x4F.png\" alt></p>\n<p>注意一定要点击 <strong>continue</strong> ，才会进入到用户注册界面，点击Retry又会回到插件下载界面</p>\n<p><img src=\"http://i.imgur.com/hdaGxc9.png\" alt></p>\n<p>注册信息填写好之后，选择<strong>Save and Finish</strong> 就会进入到Jenkins的主界面。</p>\n<h4 id=\"2：插件下载\"><a href=\"#2：插件下载\" class=\"headerlink\" title=\"2：插件下载\"></a>2：插件下载</h4><p>进入到jenkins首先要进行相应的插件下载，不然后期工作无法展开。Android需要的插件主要有：<strong>Git Plugin</strong>、<strong>Gradle Plugin</strong>、<strong>SSH Credentials Plugin</strong>。 进入到Jenkins主界面选择 <strong>系统管理</strong> </p>\n<p><img src=\"http://i.imgur.com/NsUi08u.png\" alt></p>\n<p>进入之后选择 <strong>管理插件</strong>，进入到插件下载界面，进行相应插件下载。</p>\n<p><img src=\"http://i.imgur.com/37JT32x.png\" alt></p>\n<h4 id=\"3：系统设置（重点）\"><a href=\"#3：系统设置（重点）\" class=\"headerlink\" title=\"3：系统设置（重点）\"></a>3：系统设置（重点）</h4><p>在插件下载完成之后，进入到 <strong>系统设置</strong> 界面，这里可以设置 <strong>JDK</strong>、<strong>Gradle</strong>、<strong>Android SDK</strong>的环境变量，如果在安装这些软件的时候已经配置好了系统变量，那么这里就不需要进行设置了。</p>\n<p><img src=\"http://i.imgur.com/tPPMXfJ.png\" alt></p>\n"},{"title":"面向协议(POP)以面向对象(OOP)","date":"2017-03-01T06:28:40.000Z","_content":"# 序\n  使用Swift的开发者可能都在讨论面向协议开发，为什么会使用这种开发模式，与我们之前所了解的面向对象的概念会有何区别。\n\n# 何为面向协议？\n面向协议编程 (Protocol Oriented Programming，以下简称 POP),是苹果提出的Swift的一种编程范式。\n\n## 编程范式\n是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。编程范型提供了（同时决定了）程序员对程序执行的看法。简单来说就是统一编程的价值观，以及编程方法。\n例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。面向协议也是一种编程范式，将程序看作依赖各个协议需要遵循的事情。\n\n# 简单认识面向协议\n从字面上来看用协议来编程，在我觉得和面向接口编程是类似的，将面向对象的思想抽离出来，转换成面向更高级的接口。Swift将这种编程思想运用了很巧妙的方式去做，其中Swift自身的标准库也是基于Protocol，绝大多类型都是满足各个Protocol。\n一个比较常见的错误类型的协议\n``` swift\npublic protocol Error {\n}\n\nextension Error {\n}\n```\n# 面向对象与面向协议的差异\n用面向对象的编程思想来设计下面的业务场景，有飞机，汽车，自行车三种交通工具，它们都有出行的功能，并且有各自的出行费用，但是在古时候或者大草原上，马也有出行的功能，并且有它的费用价格，可是马又不属于交通工具。\n<img src=\"/img/protocol/1.png\">\n马也需要有代步的功能，但在面向对象的世界中，必须要继承交通工具才能实现代步。这有一定的局限性，如何的更好的抽离代步功能，如同Java中实现的接口的方式，将代步方法抽离。面向协议就是这样的抽离方式，更好的划分职责，更加具像化，职责单一，在定义协议的时候，需要明确协议的职责。\n\n在面向协议的编程中可以这样定义:\n<img src=\"/img/protocol/2.png\">\n\n# 怎样使用?\nSwift中绝大多数定义协议的命名方式是以able作为结尾，或者ible。我们需要为每个协议定义它的职责范围。比如以下定义(Requestable)\n \n\n\n","source":"_posts/面向协议-POP-以面向对象-OOP.md","raw":"---\ntitle: 面向协议(POP)以面向对象(OOP)\ndate: 2017-03-01 14:28:40\ntags:\n---\n# 序\n  使用Swift的开发者可能都在讨论面向协议开发，为什么会使用这种开发模式，与我们之前所了解的面向对象的概念会有何区别。\n\n# 何为面向协议？\n面向协议编程 (Protocol Oriented Programming，以下简称 POP),是苹果提出的Swift的一种编程范式。\n\n## 编程范式\n是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。编程范型提供了（同时决定了）程序员对程序执行的看法。简单来说就是统一编程的价值观，以及编程方法。\n例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。面向协议也是一种编程范式，将程序看作依赖各个协议需要遵循的事情。\n\n# 简单认识面向协议\n从字面上来看用协议来编程，在我觉得和面向接口编程是类似的，将面向对象的思想抽离出来，转换成面向更高级的接口。Swift将这种编程思想运用了很巧妙的方式去做，其中Swift自身的标准库也是基于Protocol，绝大多类型都是满足各个Protocol。\n一个比较常见的错误类型的协议\n``` swift\npublic protocol Error {\n}\n\nextension Error {\n}\n```\n# 面向对象与面向协议的差异\n用面向对象的编程思想来设计下面的业务场景，有飞机，汽车，自行车三种交通工具，它们都有出行的功能，并且有各自的出行费用，但是在古时候或者大草原上，马也有出行的功能，并且有它的费用价格，可是马又不属于交通工具。\n<img src=\"/img/protocol/1.png\">\n马也需要有代步的功能，但在面向对象的世界中，必须要继承交通工具才能实现代步。这有一定的局限性，如何的更好的抽离代步功能，如同Java中实现的接口的方式，将代步方法抽离。面向协议就是这样的抽离方式，更好的划分职责，更加具像化，职责单一，在定义协议的时候，需要明确协议的职责。\n\n在面向协议的编程中可以这样定义:\n<img src=\"/img/protocol/2.png\">\n\n# 怎样使用?\nSwift中绝大多数定义协议的命名方式是以able作为结尾，或者ible。我们需要为每个协议定义它的职责范围。比如以下定义(Requestable)\n \n\n\n","slug":"面向协议-POP-以面向对象-OOP","published":1,"updated":"2017-03-01T12:28:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7g84q6000s4x2npmmciox0","content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>  使用Swift的开发者可能都在讨论面向协议开发，为什么会使用这种开发模式，与我们之前所了解的面向对象的概念会有何区别。</p>\n<h1 id=\"何为面向协议？\"><a href=\"#何为面向协议？\" class=\"headerlink\" title=\"何为面向协议？\"></a>何为面向协议？</h1><p>面向协议编程 (Protocol Oriented Programming，以下简称 POP),是苹果提出的Swift的一种编程范式。</p>\n<h2 id=\"编程范式\"><a href=\"#编程范式\" class=\"headerlink\" title=\"编程范式\"></a>编程范式</h2><p>是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。编程范型提供了（同时决定了）程序员对程序执行的看法。简单来说就是统一编程的价值观，以及编程方法。<br>例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。面向协议也是一种编程范式，将程序看作依赖各个协议需要遵循的事情。</p>\n<h1 id=\"简单认识面向协议\"><a href=\"#简单认识面向协议\" class=\"headerlink\" title=\"简单认识面向协议\"></a>简单认识面向协议</h1><p>从字面上来看用协议来编程，在我觉得和面向接口编程是类似的，将面向对象的思想抽离出来，转换成面向更高级的接口。Swift将这种编程思想运用了很巧妙的方式去做，其中Swift自身的标准库也是基于Protocol，绝大多类型都是满足各个Protocol。<br>一个比较常见的错误类型的协议<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"面向对象与面向协议的差异\"><a href=\"#面向对象与面向协议的差异\" class=\"headerlink\" title=\"面向对象与面向协议的差异\"></a>面向对象与面向协议的差异</h1><p>用面向对象的编程思想来设计下面的业务场景，有飞机，汽车，自行车三种交通工具，它们都有出行的功能，并且有各自的出行费用，但是在古时候或者大草原上，马也有出行的功能，并且有它的费用价格，可是马又不属于交通工具。<br><img src=\"/img/protocol/1.png\"><br>马也需要有代步的功能，但在面向对象的世界中，必须要继承交通工具才能实现代步。这有一定的局限性，如何的更好的抽离代步功能，如同Java中实现的接口的方式，将代步方法抽离。面向协议就是这样的抽离方式，更好的划分职责，更加具像化，职责单一，在定义协议的时候，需要明确协议的职责。</p>\n<p>在面向协议的编程中可以这样定义:<br><img src=\"/img/protocol/2.png\"></p>\n<h1 id=\"怎样使用\"><a href=\"#怎样使用\" class=\"headerlink\" title=\"怎样使用?\"></a>怎样使用?</h1><p>Swift中绝大多数定义协议的命名方式是以able作为结尾，或者ible。我们需要为每个协议定义它的职责范围。比如以下定义(Requestable)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>  使用Swift的开发者可能都在讨论面向协议开发，为什么会使用这种开发模式，与我们之前所了解的面向对象的概念会有何区别。</p>\n<h1 id=\"何为面向协议？\"><a href=\"#何为面向协议？\" class=\"headerlink\" title=\"何为面向协议？\"></a>何为面向协议？</h1><p>面向协议编程 (Protocol Oriented Programming，以下简称 POP),是苹果提出的Swift的一种编程范式。</p>\n<h2 id=\"编程范式\"><a href=\"#编程范式\" class=\"headerlink\" title=\"编程范式\"></a>编程范式</h2><p>是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。编程范型提供了（同时决定了）程序员对程序执行的看法。简单来说就是统一编程的价值观，以及编程方法。<br>例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。面向协议也是一种编程范式，将程序看作依赖各个协议需要遵循的事情。</p>\n<h1 id=\"简单认识面向协议\"><a href=\"#简单认识面向协议\" class=\"headerlink\" title=\"简单认识面向协议\"></a>简单认识面向协议</h1><p>从字面上来看用协议来编程，在我觉得和面向接口编程是类似的，将面向对象的思想抽离出来，转换成面向更高级的接口。Swift将这种编程思想运用了很巧妙的方式去做，其中Swift自身的标准库也是基于Protocol，绝大多类型都是满足各个Protocol。<br>一个比较常见的错误类型的协议<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"面向对象与面向协议的差异\"><a href=\"#面向对象与面向协议的差异\" class=\"headerlink\" title=\"面向对象与面向协议的差异\"></a>面向对象与面向协议的差异</h1><p>用面向对象的编程思想来设计下面的业务场景，有飞机，汽车，自行车三种交通工具，它们都有出行的功能，并且有各自的出行费用，但是在古时候或者大草原上，马也有出行的功能，并且有它的费用价格，可是马又不属于交通工具。<br><img src=\"/img/protocol/1.png\"><br>马也需要有代步的功能，但在面向对象的世界中，必须要继承交通工具才能实现代步。这有一定的局限性，如何的更好的抽离代步功能，如同Java中实现的接口的方式，将代步方法抽离。面向协议就是这样的抽离方式，更好的划分职责，更加具像化，职责单一，在定义协议的时候，需要明确协议的职责。</p>\n<p>在面向协议的编程中可以这样定义:<br><img src=\"/img/protocol/2.png\"></p>\n<h1 id=\"怎样使用\"><a href=\"#怎样使用\" class=\"headerlink\" title=\"怎样使用?\"></a>怎样使用?</h1><p>Swift中绝大多数定义协议的命名方式是以able作为结尾，或者ible。我们需要为每个协议定义它的职责范围。比如以下定义(Requestable)</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjt7g84od00004x2nikht6aiy","category_id":"cjt7g84or00034x2ntoeooaps","_id":"cjt7g84pa000a4x2nxs1pf6kq"},{"post_id":"cjt7g84p500084x2no32lovb0","category_id":"cjt7g84or00034x2ntoeooaps","_id":"cjt7g84pg000d4x2niu6zjoqz"},{"post_id":"cjt7g84ow00044x2nj4skbcq3","category_id":"cjt7g84p400074x2nlqjf6qkm","_id":"cjt7g84pi000f4x2nw4qy9ns0"},{"post_id":"cjt7g84p800094x2nwsyd6wh3","category_id":"cjt7g84or00034x2ntoeooaps","_id":"cjt7g84pl000i4x2n3wkv771d"},{"post_id":"cjt7g84pb000b4x2n02drwtk2","category_id":"cjt7g84p400074x2nlqjf6qkm","_id":"cjt7g84pn000k4x2nphfsuksj"},{"post_id":"cjt7g84pf000c4x2nb80gtega","category_id":"cjt7g84pi000g4x2ncfbw8nis","_id":"cjt7g84q2000p4x2nocqkb16j"},{"post_id":"cjt7g84px000n4x2nfb1yy6f6","category_id":"cjt7g84p400074x2nlqjf6qkm","_id":"cjt7g84q7000t4x2ndkcx5mi0"},{"post_id":"cjt7g84pj000h4x2nh25fmtth","category_id":"cjt7g84px000m4x2nytg15l46","_id":"cjt7g84q8000v4x2nxwkp6jr2"},{"post_id":"cjt7g84q3000r4x2npt3tbbjk","category_id":"cjt7g84px000m4x2nytg15l46","_id":"cjt7g84q8000w4x2nodcmjeuh"},{"post_id":"cjt7g84pl000j4x2n82pdwcb9","category_id":"cjt7g84px000m4x2nytg15l46","_id":"cjt7g84q9000y4x2n00am8zob"},{"post_id":"cjt7g84pv000l4x2nd5cya04s","category_id":"cjt7g84q8000u4x2n43hi2l38","_id":"cjt7g84q9000z4x2nnu3n90qq"},{"post_id":"cjt7g84q0000o4x2noyfdgz1l","category_id":"cjt7g84q9000x4x2nloek4es1","_id":"cjt7g84qb00104x2n4mvvjdw0"}],"PostTag":[],"Tag":[]}}